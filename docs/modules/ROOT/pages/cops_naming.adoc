////
  Do NOT edit this file by hand directly, as it is automatically generated.

  Please make any necessary changes to the cop documentation within the source files themselves.
////

= Naming

[#namingaccessormethodname]
== Naming/AccessorMethodName

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.50
| -
|===

Avoid prefixing accessor method names with `get_` or `set_`.
Applies to both instance and class methods.

NOTE: Method names starting with `get_` or `set_` only register an offense
when the methods match the expected arity for getters and setters respectively.
Getters (`get_attribute`) must have no arguments to be registered,
and setters (`set_attribute(value)`) must have exactly one.

[#examples-namingaccessormethodname]
=== Examples

[source,ruby]
----
# bad
def set_attribute(value)
end

# good
def attribute=(value)
end

# bad
def get_attribute
end

# good
def attribute
end

# accepted, incorrect arity for getter
def get_value(attr)
end

# accepted, incorrect arity for setter
def set_value
end
----

[#references-namingaccessormethodname]
=== References

* https://rubystyle.guide#accessor_mutator_method_names

[#namingasciiidentifiers]
== Naming/AsciiIdentifiers

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.50
| 0.87
|===

Checks for non-ascii characters in identifier and constant names.
Identifiers are always checked and whether constants are checked
can be controlled using AsciiConstants config.

[#examples-namingasciiidentifiers]
=== Examples

[source,ruby]
----
# bad
def Œ∫Œ±ŒªŒ∑ŒºŒµœÅŒ± # Greek alphabet (non-ascii)
end

# bad
def „Åì„Çì„Å´„Å°„ÅØ„Å®Ë®Ä„ÅÜ # Japanese character (non-ascii)
end

# bad
def hello_üç£ # Emoji (non-ascii)
end

# good
def say_hello
end

# bad
Ïã†Ïû• = 10 # Hangul character (non-ascii)

# good
height = 10

# bad
params[:ÿπÿ±ÿ∂_gteq] # Arabic character (non-ascii)

# good
params[:width_gteq]
----

[#asciiconstants_-true-_default_-namingasciiidentifiers]
==== AsciiConstants: true (default)

[source,ruby]
----
# bad
class Fo√∂
end

FO√ñ = "foo"
----

[#asciiconstants_-false-namingasciiidentifiers]
==== AsciiConstants: false

[source,ruby]
----
# good
class Fo√∂
end

FO√ñ = "foo"
----

[#configurable-attributes-namingasciiidentifiers]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AsciiConstants
| `true`
| Boolean
|===

[#references-namingasciiidentifiers]
=== References

* https://rubystyle.guide#english-identifiers

[#namingbinaryoperatorparametername]
== Naming/BinaryOperatorParameterName

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.50
| 1.2
|===

Makes sure that certain binary operator methods have their
sole  parameter named `other`.

[#examples-namingbinaryoperatorparametername]
=== Examples

[source,ruby]
----
# bad
def +(amount); end

# good
def +(other); end
----

[#references-namingbinaryoperatorparametername]
=== References

* https://rubystyle.guide#other-arg

[#namingblockforwarding]
== Naming/BlockForwarding

NOTE: Requires Ruby version 3.1

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.24
| -
|===

In Ruby 3.1, anonymous block forwarding has been added.

This cop identifies places where `do_something(&block)` can be replaced
by `do_something(&)`.

It also supports the opposite style by alternative `explicit` option.
You can specify the block variable name for autocorrection with `BlockForwardingName`.
The default variable name is `block`. If the name is already in use, it will not be
autocorrected.

[NOTE]
====
Because of a bug in Ruby 3.3.0, when a block is referenced inside of another block,
no offense will be registered until Ruby 3.4:

[source,ruby]
----
def foo(&block)
  # Using an anonymous block would be a syntax error on Ruby 3.3.0
  block_method { bar(&block) }
end
----
====

[#examples-namingblockforwarding]
=== Examples

[#enforcedstyle_-anonymous-_default_-namingblockforwarding]
==== EnforcedStyle: anonymous (default)

[source,ruby]
----
# bad
def foo(&block)
  bar(&block)
end

# good
def foo(&)
  bar(&)
end
----

[#enforcedstyle_-explicit-namingblockforwarding]
==== EnforcedStyle: explicit

[source,ruby]
----
# bad
def foo(&)
  bar(&)
end

# good
def foo(&block)
  bar(&block)
end
----

[#configurable-attributes-namingblockforwarding]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `anonymous`
| `anonymous`, `explicit`

| BlockForwardingName
| `block`
| String
|===

[#references-namingblockforwarding]
=== References

* https://rubystyle.guide#block-forwarding

[#namingblockparametername]
== Naming/BlockParameterName

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.53
| 0.77
|===

Checks block parameter names for how descriptive they
are. It is highly configurable.

The `MinNameLength` config option takes an integer. It represents
the minimum amount of characters the name must be. Its default is 1.
The `AllowNamesEndingInNumbers` config option takes a boolean. When
set to false, this cop will register offenses for names ending with
numbers. Its default is false. The `AllowedNames` config option
takes an array of permitted names that will never register an
offense. The `ForbiddenNames` config option takes an array of
restricted names that will always register an offense.

[#examples-namingblockparametername]
=== Examples

[source,ruby]
----
# bad
bar do |varOne, varTwo|
  varOne + varTwo
end

# With `AllowNamesEndingInNumbers` set to false
foo { |num1, num2| num1 * num2 }

# With `MinNameLength` set to number greater than 1
baz { |a, b, c| do_stuff(a, b, c) }

# good
bar do |thud, fred|
  thud + fred
end

foo { |speed, distance| speed * distance }

baz { |age, height, gender| do_stuff(age, height, gender) }
----

[#configurable-attributes-namingblockparametername]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| MinNameLength
| `1`
| Integer

| AllowNamesEndingInNumbers
| `true`
| Boolean

| AllowedNames
| `[]`
| Array

| ForbiddenNames
| `[]`
| Array
|===

[#namingclassandmodulecamelcase]
== Naming/ClassAndModuleCamelCase

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.50
| 0.85
|===

Checks for class and module names with
an underscore in them.

`AllowedNames` config takes an array of permitted names.
Its default value is `['module_parent']`.
These names can be full class/module names or part of the name.
eg. Adding `my_class` to the `AllowedNames` config will allow names like
`my_class`, `my_class::User`, `App::my_class`, `App::my_class::User`, etc.

[#examples-namingclassandmodulecamelcase]
=== Examples

[source,ruby]
----
# bad
class My_Class
end
module My_Module
end

# good
class MyClass
end
module MyModule
end
class module_parent::MyModule
end
----

[#configurable-attributes-namingclassandmodulecamelcase]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedNames
| `module_parent`
| Array
|===

[#references-namingclassandmodulecamelcase]
=== References

* https://rubystyle.guide#camelcase-classes

[#namingconstantname]
== Naming/ConstantName

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.50
| -
|===

Checks whether constant names are written using
SCREAMING_SNAKE_CASE.

To avoid false positives, it ignores cases in which we cannot know
for certain the type of value that would be assigned to a constant.

[#examples-namingconstantname]
=== Examples

[source,ruby]
----
# bad
InchInCm = 2.54
INCHinCM = 2.54
Inch_In_Cm = 2.54

# good
INCH_IN_CM = 2.54
----

[#references-namingconstantname]
=== References

* https://rubystyle.guide#screaming-snake-case

[#namingfilename]
== Naming/FileName

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.50
| 1.23
|===

Makes sure that Ruby source files have snake_case
names. Ruby scripts (i.e. source files with a shebang in the
first line) are ignored.

The cop also ignores `.gemspec` files, because Bundler
recommends using dashes to separate namespaces in nested gems
(i.e. `bundler-console` becomes `Bundler::Console`). As such, the
gemspec is supposed to be named `bundler-console.gemspec`.

When `ExpectMatchingDefinition` (default: `false`) is `true`, the cop requires
each file to have a class, module or `Struct` defined in it that matches
the filename. This can be further configured using
`CheckDefinitionPathHierarchy` (default: `true`) to determine whether the
path should match the namespace of the above definition.

When `IgnoreExecutableScripts` (default: `true`) is `true`, files that start
with a shebang line are not considered by the cop.

When `Regex` is set, the cop will flag any filename that does not match
the regular expression.

[#examples-namingfilename]
=== Examples

[source,ruby]
----
# bad
lib/layoutManager.rb

anything/usingCamelCase

# good
lib/layout_manager.rb

anything/using_snake_case.rake
----

[#configurable-attributes-namingfilename]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| Exclude
| `Rakefile.rb`
| Array

| ExpectMatchingDefinition
| `false`
| Boolean

| CheckDefinitionPathHierarchy
| `true`
| Boolean

| CheckDefinitionPathHierarchyRoots
| `lib`, `spec`, `test`, `src`
| Array

| Regex
| `<none>`
| 

| IgnoreExecutableScripts
| `true`
| Boolean

| AllowedAcronyms
| `CLI`, `DSL`, `ACL`, `API`, `ASCII`, `CPU`, `CSS`, `DNS`, `EOF`, `GUID`, `HTML`, `HTTP`, `HTTPS`, `ID`, `IP`, `JSON`, `LHS`, `QPS`, `RAM`, `RHS`, `RPC`, `SLA`, `SMTP`, `SQL`, `SSH`, `TCP`, `TLS`, `TTL`, `UDP`, `UI`, `UID`, `UUID`, `URI`, `URL`, `UTF8`, `VM`, `XML`, `XMPP`, `XSRF`, `XSS`
| Array
|===

[#references-namingfilename]
=== References

* https://rubystyle.guide#snake-case-files

[#namingheredocdelimitercase]
== Naming/HeredocDelimiterCase

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.50
| 1.2
|===

Checks that your heredocs are using the configured case.
By default it is configured to enforce uppercase heredocs.

[#examples-namingheredocdelimitercase]
=== Examples

[#enforcedstyle_-uppercase-_default_-namingheredocdelimitercase]
==== EnforcedStyle: uppercase (default)

[source,ruby]
----
# bad
<<-sql
  SELECT * FROM foo
sql

# good
<<-SQL
  SELECT * FROM foo
SQL
----

[#enforcedstyle_-lowercase-namingheredocdelimitercase]
==== EnforcedStyle: lowercase

[source,ruby]
----
# bad
<<-SQL
  SELECT * FROM foo
SQL

# good
<<-sql
  SELECT * FROM foo
sql
----

[#configurable-attributes-namingheredocdelimitercase]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `uppercase`
| `lowercase`, `uppercase`
|===

[#references-namingheredocdelimitercase]
=== References

* https://rubystyle.guide#heredoc-delimiters

[#namingheredocdelimiternaming]
== Naming/HeredocDelimiterNaming

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.50
| -
|===

Checks that your heredocs are using meaningful delimiters.
By default it disallows `END` and `EO*`, and can be configured through
forbidden listing additional delimiters.

[#examples-namingheredocdelimiternaming]
=== Examples

[source,ruby]
----
# good
<<-SQL
  SELECT * FROM foo
SQL

# bad
<<-END
  SELECT * FROM foo
END

# bad
<<-EOS
  SELECT * FROM foo
EOS
----

[#configurable-attributes-namingheredocdelimiternaming]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| ForbiddenDelimiters
| `(?i-mx:(^\|\s)(EO[A-Z]{1}\|END)(\s\|$))`
| Array
|===

[#references-namingheredocdelimiternaming]
=== References

* https://rubystyle.guide#heredoc-delimiters

[#naminginclusivelanguage]
== Naming/InclusiveLanguage

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| Always
| 1.18
| 1.49
|===

Recommends the use of inclusive language instead of problematic terms.
The cop can check the following locations for offenses:

- identifiers
- constants
- variables
- strings
- symbols
- comments
- file paths

Each of these locations can be individually enabled/disabled via configuration,
for example CheckIdentifiers = true/false.

Flagged terms are configurable for the cop. For each flagged term an optional
Regex can be specified to identify offenses. Suggestions for replacing a flagged term can
be configured and will be displayed as part of the offense message.
An AllowedRegex can be specified for a flagged term to exempt allowed uses of the term.
`WholeWord: true` can be set on a flagged term to indicate the cop should only match when
a term matches the whole word (partial matches will not be offenses).

The cop supports autocorrection when there is only one suggestion. When there are multiple
suggestions, the best suggestion cannot be identified and will not be autocorrected.

[#examples-naminginclusivelanguage]
=== Examples

[#flaggedterms_-_-whitelist_-_-suggestions_-__allowlist__-_-_-naminginclusivelanguage]
==== FlaggedTerms: { whitelist: { Suggestions: ['allowlist'] } }

[source,ruby]
----
# Suggest replacing identifier whitelist with allowlist

# bad
whitelist_users = %w(user1 user1)

# good
allowlist_users = %w(user1 user2)
----

[#flaggedterms_-_-master_-_-suggestions_-__main__-_primary__-_leader__-_-_-naminginclusivelanguage]
==== FlaggedTerms: { master: { Suggestions: ['main', 'primary', 'leader'] } }

[source,ruby]
----
# Suggest replacing master in an instance variable name with main, primary, or leader

# bad
@master_node = 'node1.example.com'

# good
@primary_node = 'node1.example.com'
----

[#flaggedterms_-_-whitelist_-_-regex_-_rubyregexp-_white_-__s__list_-_-_-naminginclusivelanguage]
==== FlaggedTerms: { whitelist: { Regex: !ruby/regexp '/white[-_\s]?list' } }

[source,ruby]
----
# Identify problematic terms using a Regexp

# bad
white_list = %w(user1 user2)

# good
allow_list = %w(user1 user2)
----

[#flaggedterms_-_-master_-_-allowedregex_-_master___s-degree_-_-_-naminginclusivelanguage]
==== FlaggedTerms: { master: { AllowedRegex: 'master\'?s degree' } }

[source,ruby]
----
# Specify allowed uses of the flagged term as a string or regexp.

# bad
# They had a masters

# good
# They had a master's degree
----

[#flaggedterms_-_-slave_-_-wholeword_-true-_-_-naminginclusivelanguage]
==== FlaggedTerms: { slave: { WholeWord: true } }

[source,ruby]
----
# Specify that only terms that are full matches will be flagged.

# bad
Slave

# good (won't be flagged despite containing `slave`)
TeslaVehicle
----

[#configurable-attributes-naminginclusivelanguage]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| CheckIdentifiers
| `true`
| Boolean

| CheckConstants
| `true`
| Boolean

| CheckVariables
| `true`
| Boolean

| CheckStrings
| `false`
| Boolean

| CheckSymbols
| `true`
| Boolean

| CheckComments
| `true`
| Boolean

| CheckFilepaths
| `true`
| Boolean

| FlaggedTerms
| `{"whitelist" => {"Regex" => /white[-_\s]?list/, "Suggestions" => ["allowlist", "permit"]}, "blacklist" => {"Regex" => /black[-_\s]?list/, "Suggestions" => ["denylist", "block"]}, "slave" => {"WholeWord" => true, "Suggestions" => ["replica", "secondary", "follower"]}}`
| 
|===

[#namingmemoizedinstancevariablename]
== Naming/MemoizedInstanceVariableName

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.53
| 1.2
|===

Checks for memoized methods whose instance variable name
does not match the method name. Applies to both regular methods
(defined with `def`) and dynamic methods (defined with
`define_method` or `define_singleton_method`).

This cop can be configured with the EnforcedStyleForLeadingUnderscores
directive. It can be configured to allow for memoized instance variables
prefixed with an underscore. Prefixing ivars with an underscore is a
convention that is used to implicitly indicate that an ivar should not
be set or referenced outside of the memoization method.

[#safety-namingmemoizedinstancevariablename]
=== Safety

This cop relies on the pattern `@instance_var ||= ...`,
but this is sometimes used for other purposes than memoization
so this cop is considered unsafe. Also, its autocorrection is unsafe
because it may conflict with instance variable names already in use.

[#examples-namingmemoizedinstancevariablename]
=== Examples

[#enforcedstyleforleadingunderscores_-disallowed-_default_-namingmemoizedinstancevariablename]
==== EnforcedStyleForLeadingUnderscores: disallowed (default)

[source,ruby]
----
# bad
# Method foo is memoized using an instance variable that is
# not `@foo`. This can cause confusion and bugs.
def foo
  @something ||= calculate_expensive_thing
end

def foo
  return @something if defined?(@something)
  @something = calculate_expensive_thing
end

# good
def _foo
  @foo ||= calculate_expensive_thing
end

# good
def foo
  @foo ||= calculate_expensive_thing
end

# good
def foo
  @foo ||= begin
    calculate_expensive_thing
  end
end

# good
def foo
  helper_variable = something_we_need_to_calculate_foo
  @foo ||= calculate_expensive_thing(helper_variable)
end

# good
define_method(:foo) do
  @foo ||= calculate_expensive_thing
end

# good
define_method(:foo) do
  return @foo if defined?(@foo)
  @foo = calculate_expensive_thing
end
----

[#enforcedstyleforleadingunderscores_-required-namingmemoizedinstancevariablename]
==== EnforcedStyleForLeadingUnderscores: required

[source,ruby]
----
# bad
def foo
  @something ||= calculate_expensive_thing
end

# bad
def foo
  @foo ||= calculate_expensive_thing
end

def foo
  return @foo if defined?(@foo)
  @foo = calculate_expensive_thing
end

# good
def foo
  @_foo ||= calculate_expensive_thing
end

# good
def _foo
  @_foo ||= calculate_expensive_thing
end

def foo
  return @_foo if defined?(@_foo)
  @_foo = calculate_expensive_thing
end

# good
define_method(:foo) do
  @_foo ||= calculate_expensive_thing
end

# good
define_method(:foo) do
  return @_foo if defined?(@_foo)
  @_foo = calculate_expensive_thing
end
----

[#enforcedstyleforleadingunderscores-_optional-namingmemoizedinstancevariablename]
==== EnforcedStyleForLeadingUnderscores :optional

[source,ruby]
----
# bad
def foo
  @something ||= calculate_expensive_thing
end

# good
def foo
  @foo ||= calculate_expensive_thing
end

# good
def foo
  @_foo ||= calculate_expensive_thing
end

# good
def _foo
  @_foo ||= calculate_expensive_thing
end

# good
def foo
  return @_foo if defined?(@_foo)
  @_foo = calculate_expensive_thing
end

# good
define_method(:foo) do
  @foo ||= calculate_expensive_thing
end

# good
define_method(:foo) do
  @_foo ||= calculate_expensive_thing
end
----

[#configurable-attributes-namingmemoizedinstancevariablename]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyleForLeadingUnderscores
| `disallowed`
| `disallowed`, `required`, `optional`
|===

[#namingmethodname]
== Naming/MethodName

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.50
| 1.75
|===

Makes sure that all methods use the configured style,
snake_case or camelCase, for their names.

Method names matching patterns are always allowed.

The cop can be configured with `AllowedPatterns` to allow certain regexp patterns:

[source,yaml]
----
Naming/MethodName:
  AllowedPatterns:
    - '\AonSelectionBulkChange\z'
    - '\AonSelectionCleared\z'
----

As well, you can also forbid specific method names or regexp patterns
using `ForbiddenIdentifiers` or `ForbiddenPatterns`:

[source,yaml]
----
Naming/MethodName:
  ForbiddenIdentifiers:
    - 'def'
    - 'super'
  ForbiddenPatterns:
    - '_v1\z'
    - '_gen1\z'
----

[#examples-namingmethodname]
=== Examples

[#enforcedstyle_-snake_case-_default_-namingmethodname]
==== EnforcedStyle: snake_case (default)

[source,ruby]
----
# bad
def fooBar; end

# good
def foo_bar; end

# bad
define_method :fooBar do
end

# good
define_method :foo_bar do
end

# bad
Struct.new(:fooBar)

# good
Struct.new(:foo_bar)

# bad
alias_method :fooBar, :some_method

# good
alias_method :foo_bar, :some_method
----

[#enforcedstyle_-camelcase-namingmethodname]
==== EnforcedStyle: camelCase

[source,ruby]
----
# bad
def foo_bar; end

# good
def fooBar; end

# bad
define_method :foo_bar do
end

# good
define_method :fooBar do
end

# bad
Struct.new(:foo_bar)

# good
Struct.new(:fooBar)

# bad
alias_method :foo_bar, :some_method

# good
alias_method :fooBar, :some_method
----

[#forbiddenidentifiers_-__def__-_super__-namingmethodname]
==== ForbiddenIdentifiers: ['def', 'super']

[source,ruby]
----
# bad
def def; end
def super; end
----

[#forbiddenpatterns_-___v1_z__-__gen1_z__-namingmethodname]
==== ForbiddenPatterns: ['_v1\z', '_gen1\z']

[source,ruby]
----
# bad
def release_v1; end
def api_gen1; end
----

[#configurable-attributes-namingmethodname]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `snake_case`
| `snake_case`, `camelCase`

| AllowedPatterns
| `[]`
| Array

| ForbiddenIdentifiers
| `__id__`, `__send__`
| Array

| ForbiddenPatterns
| `[]`
| Array
|===

[#references-namingmethodname]
=== References

* https://rubystyle.guide#snake-case-symbols-methods-vars

[#namingmethodparametername]
== Naming/MethodParameterName

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.53
| 0.77
|===

Checks method parameter names for how descriptive they
are. It is highly configurable.

The `MinNameLength` config option takes an integer. It represents
the minimum amount of characters the name must be. Its default is 3.
The `AllowNamesEndingInNumbers` config option takes a boolean. When
set to false, this cop will register offenses for names ending with
numbers. Its default is false. The `AllowedNames` config option
takes an array of permitted names that will never register an
offense. The `ForbiddenNames` config option takes an array of
restricted names that will always register an offense.

[#examples-namingmethodparametername]
=== Examples

[source,ruby]
----
# bad
def bar(varOne, varTwo)
  varOne + varTwo
end

# With `AllowNamesEndingInNumbers` set to false
def foo(num1, num2)
  num1 * num2
end

# With `MinNameLength` set to number greater than 1
def baz(a, b, c)
  do_stuff(a, b, c)
end

# good
def bar(thud, fred)
  thud + fred
end

def foo(speed, distance)
  speed * distance
end

def baz(age_a, height_b, gender_c)
  do_stuff(age_a, height_b, gender_c)
end
----

[#configurable-attributes-namingmethodparametername]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| MinNameLength
| `3`
| Integer

| AllowNamesEndingInNumbers
| `true`
| Boolean

| AllowedNames
| `as`, `at`, `by`, `cc`, `db`, `id`, `if`, `in`, `io`, `ip`, `of`, `on`, `os`, `pp`, `to`
| Array

| ForbiddenNames
| `[]`
| Array
|===

[#namingpredicatemethod]
== Naming/PredicateMethod

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| No
| 1.76
| 1.78
|===

Checks that predicate methods end with `?` and non-predicate methods do not.

The names of predicate methods (methods that return a boolean value) should end
in a question mark. Methods that don't return a boolean, shouldn't
end in a question mark.

The cop assesses a predicate method as one that returns boolean values. Likewise,
a method that only returns literal values is assessed as non-predicate. Other predicate
method calls are assumed to return boolean values. The cop does not make an assessment
if the return type is unknown (non-predicate method calls, variables, etc.).

NOTE: The `initialize` method and operator methods (`def ==`, etc.) are ignored.

By default, the cop runs in `conservative` mode, which allows a method to be named
with a question mark as long as at least one return value is boolean. In `aggressive`
mode, methods with a question mark will register an offense if any known non-boolean
return values are detected.

The cop also has `AllowedMethods` configuration in order to prevent the cop from
registering an offense from a method name that does not confirm to the naming
guidelines. By default, `call` is allowed. The cop also has `AllowedPatterns`
configuration to allow method names by regular expression.

Although returning a call to another predicate method is treated as a boolean value,
certain method names can be known to not return a boolean, despite ending in a `?`
(for example, `Numeric#nonzero?` returns `self` or `nil`). These methods can be
configured using `NonBooleanPredicates`.

The cop can furthermore be configured to allow all bang methods (method names
ending with `!`), with `AllowBangMethods: true` (default false).

[#examples-namingpredicatemethod]
=== Examples

[#mode_-conservative-_default_-namingpredicatemethod]
==== Mode: conservative (default)

[source,ruby]
----
# bad
def foo
  bar == baz
end

# good
def foo?
  bar == baz
end

# bad
def foo?
  5
end

# good
def foo
  5
end

# bad
def foo
  x == y
end

# good
def foo?
  x == y
end

# bad
def foo
  !x
end

# good
def foo?
  !x
end

# bad - returns the value of another predicate method
def foo
  bar?
end

# good
def foo?
  bar?
end

# good - operator method
def ==(other)
  hash == other.hash
end

# good - at least one return value is boolean
def foo?
  return unless bar?
  true
end

# ok - return type is not known
def foo?
  bar
end

# ok - return type is not known
def foo
  bar?
end
----

[#mode_-aggressive-namingpredicatemethod]
==== Mode: aggressive

[source,ruby]
----
# bad - the method returns nil in some cases
def foo?
  return unless bar?
  true
end
----

[#allowedmethods_-_call_-_default_-namingpredicatemethod]
==== AllowedMethods: [call] (default)

[source,ruby]
----
# good
def call
  foo == bar
end
----

[#allowedpatterns_-__afoo_-namingpredicatemethod]
==== AllowedPatterns: [\Afoo]

[source,ruby]
----
# good
def foo?
  'foo'
end
----

[#allowbangmethods_-false-_default_-namingpredicatemethod]
==== AllowBangMethods: false (default)

[source,ruby]
----
# bad
def save!
  true
end
----

[#allowbangmethods_-true-namingpredicatemethod]
==== AllowBangMethods: true

[source,ruby]
----
# good
def save!
  true
end
----

[#configurable-attributes-namingpredicatemethod]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| Mode
| `conservative`
| String

| AllowedMethods
| `call`
| Array

| AllowedPatterns
| `[]`
| Array

| AllowBangMethods
| `false`
| Boolean

| WaywardPredicates
| `nonzero?`
| Array
|===

[#namingpredicateprefix]
== Naming/PredicatePrefix

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.50
| 1.75
|===

Checks that predicate method names end with a question mark and
do not start with a forbidden prefix.

A method is determined to be a predicate method if its name starts with
one of the prefixes listed in the `NamePrefix` configuration. The list
defaults to `is_`, `has_`, and `have_` but may be overridden.

Predicate methods must end with a question mark.

When `ForbiddenPrefixes` is also set (as it is by default), predicate
methods which begin with a forbidden prefix are not allowed, even if
they end with a `?`. These methods should be changed to remove the
prefix.

When `UseSorbetSigs` set to true (optional), the cop will only report
offenses if the method has a Sorbet `sig` with a return type of
`T::Boolean`. Dynamic methods are not supported with this configuration.

[#examples-namingpredicateprefix]
=== Examples

[#nameprefix_-__is___-_has___-_have___-_default_-namingpredicateprefix]
==== NamePrefix: ['is_', 'has_', 'have_'] (default)

[source,ruby]
----
# bad
def is_even(value)
end

# When ForbiddenPrefixes: ['is_', 'has_', 'have_'] (default)
# good
def even?(value)
end

# When ForbiddenPrefixes: []
# good
def is_even?(value)
end
----

[#nameprefix_-__seems_to_be___-namingpredicateprefix]
==== NamePrefix: ['seems_to_be_']

[source,ruby]
----
# bad
def seems_to_be_even(value)
end

# When ForbiddenPrefixes: ['seems_to_be_']
# good
def even?(value)
end

# When ForbiddenPrefixes: []
# good
def seems_to_be_even?(value)
end
----

[#allowedmethods_-__is_a___-_default_-namingpredicateprefix]
==== AllowedMethods: ['is_a?'] (default)

[source,ruby]
----
# Despite starting with the `is_` prefix, this method is allowed
# good
def is_a?(value)
end
----

[#allowedmethods_-__is_even___-namingpredicateprefix]
==== AllowedMethods: ['is_even?']

[source,ruby]
----
# good
def is_even?(value)
end
----

[#usesorbetsigs_-false-_default_-namingpredicateprefix]
==== UseSorbetSigs: false (default)

[source,ruby]
----
# bad
sig { returns(String) }
def is_this_thing_on
  "yes"
end

# good - Sorbet signature is not evaluated
sig { returns(String) }
def is_this_thing_on?
  "yes"
end
----

[#usesorbetsigs_-true-namingpredicateprefix]
==== UseSorbetSigs: true

[source,ruby]
----
# bad
sig { returns(T::Boolean) }
def odd(value)
end

# good
sig { returns(T::Boolean) }
def odd?(value)
end
----

[#methoddefinitionmacros_-__define_method__-_define_singleton_method__-_default_-namingpredicateprefix]
==== MethodDefinitionMacros: ['define_method', 'define_singleton_method'] (default)

[source,ruby]
----
# bad
define_method(:is_even) { |value| }

# good
define_method(:even?) { |value| }
----

[#methoddefinitionmacros_-__def_node_matcher__-namingpredicateprefix]
==== MethodDefinitionMacros: ['def_node_matcher']

[source,ruby]
----
# bad
def_node_matcher(:is_even) { |value| }

# good
def_node_matcher(:even?) { |value| }
----

[#configurable-attributes-namingpredicateprefix]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| NamePrefix
| `is_`, `has_`, `have_`, `does_`
| Array

| ForbiddenPrefixes
| `is_`, `has_`, `have_`, `does_`
| Array

| AllowedMethods
| `is_a?`
| Array

| MethodDefinitionMacros
| `define_method`, `define_singleton_method`
| Array

| UseSorbetSigs
| `false`
| Boolean

| Exclude
| `+spec/**/*+`
| Array
|===

[#references-namingpredicateprefix]
=== References

* https://rubystyle.guide#bool-methods-qmark

[#namingrescuedexceptionsvariablename]
== Naming/RescuedExceptionsVariableName

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.67
| 0.68
|===

Makes sure that rescued exceptions variables are named as
expected.

The `PreferredName` config option takes a `String`. It represents
the required name of the variable. Its default is `e`.

NOTE: This cop does not consider nested rescues because it cannot
guarantee that the variable from the outer rescue is not used within
the inner rescue (in which case, changing the inner variable would
shadow the outer variable).

[#examples-namingrescuedexceptionsvariablename]
=== Examples

[#preferredname_-e-_default_-namingrescuedexceptionsvariablename]
==== PreferredName: e (default)

[source,ruby]
----
# bad
begin
  # do something
rescue MyException => exception
  # do something
end

# good
begin
  # do something
rescue MyException => e
  # do something
end

# good
begin
  # do something
rescue MyException => _e
  # do something
end
----

[#preferredname_-exception-namingrescuedexceptionsvariablename]
==== PreferredName: exception

[source,ruby]
----
# bad
begin
  # do something
rescue MyException => e
  # do something
end

# good
begin
  # do something
rescue MyException => exception
  # do something
end

# good
begin
  # do something
rescue MyException => _exception
  # do something
end
----

[#configurable-attributes-namingrescuedexceptionsvariablename]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| PreferredName
| `e`
| String
|===

[#namingvariablename]
== Naming/VariableName

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.50
| 1.73
|===

Checks that the configured style (snake_case or camelCase) is used for all variable names.
This includes local variables, instance variables, class variables, method arguments
(positional, keyword, rest or block), and block arguments.

The cop can also be configured to forbid using specific names for variables, using
`ForbiddenIdentifiers` or `ForbiddenPatterns`. In addition to the above, this applies
to global variables as well.

Method definitions and method calls are not affected by this cop.

[#examples-namingvariablename]
=== Examples

[#enforcedstyle_-snake_case-_default_-namingvariablename]
==== EnforcedStyle: snake_case (default)

[source,ruby]
----
# bad
fooBar = 1

# good
foo_bar = 1
----

[#enforcedstyle_-camelcase-namingvariablename]
==== EnforcedStyle: camelCase

[source,ruby]
----
# bad
foo_bar = 1

# good
fooBar = 1
----

[#allowedidentifiers_-__foobar__-namingvariablename]
==== AllowedIdentifiers: ['fooBar']

[source,ruby]
----
# good (with EnforcedStyle: snake_case)
fooBar = 1
----

[#allowedpatterns_-___v_d__z__-namingvariablename]
==== AllowedPatterns: ['_v\d+\z']

[source,ruby]
----
# good (with EnforcedStyle: camelCase)
release_v1 = true
----

[#forbiddenidentifiers_-__foobar__-namingvariablename]
==== ForbiddenIdentifiers: ['fooBar']

[source,ruby]
----
# bad (in all cases)
fooBar = 1
@fooBar = 1
@@fooBar = 1
$fooBar = 1
----

[#forbiddenpatterns_-___v_d__z__-namingvariablename]
==== ForbiddenPatterns: ['_v\d+\z']

[source,ruby]
----
# bad (in all cases)
release_v1 = true
@release_v1 = true
@@release_v1 = true
$release_v1 = true
----

[#configurable-attributes-namingvariablename]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `snake_case`
| `snake_case`, `camelCase`

| AllowedIdentifiers
| `[]`
| Array

| AllowedPatterns
| `[]`
| Array

| ForbiddenIdentifiers
| `[]`
| Array

| ForbiddenPatterns
| `[]`
| Array
|===

[#references-namingvariablename]
=== References

* https://rubystyle.guide#snake-case-symbols-methods-vars

[#namingvariablenumber]
== Naming/VariableNumber

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.50
| 1.4
|===

Makes sure that all numbered variables use the
configured style, snake_case, normalcase, or non_integer,
for their numbering.

Additionally, `CheckMethodNames` and `CheckSymbols` configuration options
can be used to specify whether method names and symbols should be checked.
Both are enabled by default.

[#examples-namingvariablenumber]
=== Examples

[#enforcedstyle_-normalcase-_default_-namingvariablenumber]
==== EnforcedStyle: normalcase (default)

[source,ruby]
----
# bad
:some_sym_1
variable_1 = 1

def some_method_1; end

def some_method1(arg_1); end

# good
:some_sym1
variable1 = 1

def some_method1; end

def some_method1(arg1); end
----

[#enforcedstyle_-snake_case-namingvariablenumber]
==== EnforcedStyle: snake_case

[source,ruby]
----
# bad
:some_sym1
variable1 = 1

def some_method1; end

def some_method_1(arg1); end

# good
:some_sym_1
variable_1 = 1

def some_method_1; end

def some_method_1(arg_1); end
----

[#enforcedstyle_-non_integer-namingvariablenumber]
==== EnforcedStyle: non_integer

[source,ruby]
----
# bad
:some_sym1
:some_sym_1

variable1 = 1
variable_1 = 1

def some_method1; end

def some_method_1; end

def some_methodone(arg1); end
def some_methodone(arg_1); end

# good
:some_symone
:some_sym_one

variableone = 1
variable_one = 1

def some_methodone; end

def some_method_one; end

def some_methodone(argone); end
def some_methodone(arg_one); end

# In the following examples, we assume `EnforcedStyle: normalcase` (default).
----

[#checkmethodnames_-true-_default_-namingvariablenumber]
==== CheckMethodNames: true (default)

[source,ruby]
----
# bad
def some_method_1; end
----

[#checkmethodnames_-false-namingvariablenumber]
==== CheckMethodNames: false

[source,ruby]
----
# good
def some_method_1; end
----

[#checksymbols_-true-_default_-namingvariablenumber]
==== CheckSymbols: true (default)

[source,ruby]
----
# bad
:some_sym_1
----

[#checksymbols_-false-namingvariablenumber]
==== CheckSymbols: false

[source,ruby]
----
# good
:some_sym_1
----

[#allowedidentifiers_-_capture3_-namingvariablenumber]
==== AllowedIdentifiers: [capture3]

[source,ruby]
----
# good
expect(Open3).to receive(:capture3)
----

[#allowedpatterns_-___v_d__z__-namingvariablenumber]
==== AllowedPatterns: ['_v\d+\z']

[source,ruby]
----
# good
:some_sym_v1
----

[#configurable-attributes-namingvariablenumber]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `normalcase`
| `snake_case`, `normalcase`, `non_integer`

| CheckMethodNames
| `true`
| Boolean

| CheckSymbols
| `true`
| Boolean

| AllowedIdentifiers
| `TLS1_1`, `TLS1_2`, `capture3`, `iso8601`, `rfc1123_date`, `rfc822`, `rfc2822`, `rfc3339`, `x86_64`
| Array

| AllowedPatterns
| `[]`
| Array
|===

[#references-namingvariablenumber]
=== References

* https://rubystyle.guide#snake-case-symbols-methods-vars-with-numbers
