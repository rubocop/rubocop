////
  Do NOT edit this file by hand directly, as it is automatically generated.

  Please make any necessary changes to the cop documentation within the source files themselves.
////

= Style

[#styleaccessmodifierdeclarations]
== Style/AccessModifierDeclarations

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.57
| 1.70
|===

Access modifiers should be declared to apply to a group of methods
or inline before each method, depending on configuration.
EnforcedStyle config covers only method definitions.
Applications of visibility methods to symbols can be controlled
using AllowModifiersOnSymbols config.
Also, the visibility of `attr*` methods can be controlled using
AllowModifiersOnAttrs config.

In Ruby 3.0, `attr*` methods now return an array of defined method names
as symbols. So we can write the modifier and `attr*` in inline style.
AllowModifiersOnAttrs config allows `attr*` methods to be written in
inline style without modifying applications that have been maintained
for a long time in group style. Furthermore, developers who are not very
familiar with Ruby may know that the modifier applies to `def`, but they
may not know that it also applies to `attr*` methods. It would be easier
to understand if we could write `attr*` methods in inline style.

[#safety-styleaccessmodifierdeclarations]
=== Safety

Autocorrection is not safe, because the visibility of dynamically
defined methods can vary depending on the state determined by
the group access modifier.

[#examples-styleaccessmodifierdeclarations]
=== Examples

[#enforcedstyle_-group-_default_-styleaccessmodifierdeclarations]
==== EnforcedStyle: group (default)

[source,ruby]
----
# bad
class Foo

  private def bar; end
  private def baz; end

end

# good
class Foo

  private

  def bar; end
  def baz; end

end
----

[#enforcedstyle_-inline-styleaccessmodifierdeclarations]
==== EnforcedStyle: inline

[source,ruby]
----
# bad
class Foo

  private

  def bar; end
  def baz; end

end

# good
class Foo

  private def bar; end
  private def baz; end

end
----

[#allowmodifiersonsymbols_-true-_default_-styleaccessmodifierdeclarations]
==== AllowModifiersOnSymbols: true (default)

[source,ruby]
----
# good
class Foo

  private :bar, :baz
  private *%i[qux quux]
  private *METHOD_NAMES
  private *private_methods

end
----

[#allowmodifiersonsymbols_-false-styleaccessmodifierdeclarations]
==== AllowModifiersOnSymbols: false

[source,ruby]
----
# bad
class Foo

  private :bar, :baz
  private *%i[qux quux]
  private *METHOD_NAMES
  private *private_methods

end
----

[#allowmodifiersonattrs_-true-_default_-styleaccessmodifierdeclarations]
==== AllowModifiersOnAttrs: true (default)

[source,ruby]
----
# good
class Foo

  public attr_reader :bar
  protected attr_writer :baz
  private attr_accessor :qux
  private attr :quux

  def public_method; end

  private

  def private_method; end

end
----

[#allowmodifiersonattrs_-false-styleaccessmodifierdeclarations]
==== AllowModifiersOnAttrs: false

[source,ruby]
----
# bad
class Foo

  public attr_reader :bar
  protected attr_writer :baz
  private attr_accessor :qux
  private attr :quux

end
----

[#allowmodifiersonaliasmethod_-true-_default_-styleaccessmodifierdeclarations]
==== AllowModifiersOnAliasMethod: true (default)

[source,ruby]
----
# good
class Foo

  public alias_method :bar, :foo
  protected alias_method :baz, :foo
  private alias_method :qux, :foo

end
----

[#allowmodifiersonaliasmethod_-false-styleaccessmodifierdeclarations]
==== AllowModifiersOnAliasMethod: false

[source,ruby]
----
# bad
class Foo

  public alias_method :bar, :foo
  protected alias_method :baz, :foo
  private alias_method :qux, :foo

end
----

[#configurable-attributes-styleaccessmodifierdeclarations]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `group`
| `inline`, `group`

| AllowModifiersOnSymbols
| `true`
| Boolean

| AllowModifiersOnAttrs
| `true`
| Boolean

| AllowModifiersOnAliasMethod
| `true`
| Boolean
|===

[#styleaccessorgrouping]
== Style/AccessorGrouping

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.87
| -
|===

Checks for grouping of accessors in `class` and `module` bodies.
By default it enforces accessors to be placed in grouped declarations,
but it can be configured to enforce separating them in multiple declarations.

NOTE: If there is a method call before the accessor method it is always allowed
as it might be intended like Sorbet.

NOTE: If there is a RBS::Inline annotation comment just after the accessor method
it is always allowed.

[#examples-styleaccessorgrouping]
=== Examples

[#enforcedstyle_-grouped-_default_-styleaccessorgrouping]
==== EnforcedStyle: grouped (default)

[source,ruby]
----
# bad
class Foo
  attr_reader :bar
  attr_reader :bax
  attr_reader :baz
end

# good
class Foo
  attr_reader :bar, :bax, :baz
end

# good
class Foo
  # may be intended comment for bar.
  attr_reader :bar

  sig { returns(String) }
  attr_reader :bax

  may_be_intended_annotation :baz
  attr_reader :baz
end
----

[#enforcedstyle_-separated-styleaccessorgrouping]
==== EnforcedStyle: separated

[source,ruby]
----
# bad
class Foo
  attr_reader :bar, :baz
end

# good
class Foo
  attr_reader :bar
  attr_reader :baz
end
----

[#configurable-attributes-styleaccessorgrouping]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `grouped`
| `separated`, `grouped`
|===

[#stylealias]
== Style/Alias

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.36
|===

Enforces the use of either `#alias` or `#alias_method`
depending on configuration.
It also flags uses of `alias :symbol` rather than `alias bareword`.

However, it will always enforce `method_alias` when used `alias`
in an instance method definition and in a singleton method definition.
If used in a block, always enforce `alias_method`
unless it is an `instance_eval` block.

[#examples-stylealias]
=== Examples

[#enforcedstyle_-prefer_alias-_default_-stylealias]
==== EnforcedStyle: prefer_alias (default)

[source,ruby]
----
# bad
alias_method :bar, :foo
alias :bar :foo

# good
alias bar foo
----

[#enforcedstyle_-prefer_alias_method-stylealias]
==== EnforcedStyle: prefer_alias_method

[source,ruby]
----
# bad
alias :bar :foo
alias bar foo

# good
alias_method :bar, :foo
----

[#configurable-attributes-stylealias]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `prefer_alias`
| `prefer_alias`, `prefer_alias_method`
|===

[#references-stylealias]
=== References

* https://rubystyle.guide#alias-method-lexically

[#styleambiguousendlessmethoddefinition]
== Style/AmbiguousEndlessMethodDefinition

NOTE: Requires Ruby version 3.0

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.68
| -
|===

Looks for endless methods inside operations of lower precedence (`and`, `or`, and
modifier forms of `if`, `unless`, `while`, `until`) that are ambiguous due to
lack of parentheses. This may lead to unexpected behavior as the code may appear
to use these keywords as part of the method but in fact they modify
the method definition itself.

In these cases, using a normal method definition is more clear.

[#examples-styleambiguousendlessmethoddefinition]
=== Examples

[source,ruby]
----
# bad
def foo = true if bar

# good - using a non-endless method is more explicit
def foo
  true
end if bar

# ok - method body is explicit
def foo = (true if bar)

# ok - method definition is explicit
(def foo = true) if bar
----

[#references-styleambiguousendlessmethoddefinition]
=== References

* https://rubystyle.guide#ambiguous-endless-method-defintions

[#styleandor]
== Style/AndOr

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.9
| 1.21
|===

Checks for uses of `and` and `or`, and suggests using `&&` and
`||` instead. It can be configured to check only in conditions or in
all contexts.

[#safety-styleandor]
=== Safety

Autocorrection is unsafe because there is a different operator precedence
between logical operators (`&&` and `||`) and semantic operators (`and` and `or`),
and that might change the behavior.

[#examples-styleandor]
=== Examples

[#enforcedstyle_-conditionals-_default_-styleandor]
==== EnforcedStyle: conditionals (default)

[source,ruby]
----
# bad
if foo and bar
end

# good
foo.save && return

# good
foo.save and return

# good
if foo && bar
end
----

[#enforcedstyle_-always-styleandor]
==== EnforcedStyle: always

[source,ruby]
----
# bad
foo.save and return

# bad
if foo and bar
end

# good
foo.save && return

# good
if foo && bar
end
----

[#configurable-attributes-styleandor]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `conditionals`
| `always`, `conditionals`
|===

[#references-styleandor]
=== References

* https://rubystyle.guide#no-and-or-or

[#styleargumentsforwarding]
== Style/ArgumentsForwarding

NOTE: Requires Ruby version 2.7

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.1
| 1.58
|===

In Ruby 2.7, arguments forwarding has been added.

This cop identifies places where `do_something(*args, &block)`
can be replaced by `do_something(...)`.

In Ruby 3.1, anonymous block forwarding has been added.

This cop identifies places where `do_something(&block)` can be replaced
by `do_something(&)`; if desired, this functionality can be disabled
by setting `UseAnonymousForwarding: false`.

In Ruby 3.2, anonymous args/kwargs forwarding has been added.

This cop also identifies places where `+use_args(*args)+`/`+use_kwargs(**kwargs)+` can be
replaced by `+use_args(*)+`/`+use_kwargs(**)+`; if desired, this functionality can be
disabled by setting `UseAnonymousForwarding: false`.

And this cop has `RedundantRestArgumentNames`, `RedundantKeywordRestArgumentNames`,
and `RedundantBlockArgumentNames` options. This configuration is a list of redundant names
that are sufficient for anonymizing meaningless naming.

Meaningless names that are commonly used can be anonymized by default:
e.g., `+*args+`, `+**options+`, `&block`, and so on.

Names not on this list are likely to be meaningful and are allowed by default.

This cop handles not only method forwarding but also forwarding to `super`.

[NOTE]
====
Because of a bug in Ruby 3.3.0, when a block is referenced inside of another block,
no offense will be registered until Ruby 3.4:

[source,ruby]
----
def foo(&block)
  # Using an anonymous block would be a syntax error on Ruby 3.3.0
  block_method { bar(&block) }
end
----
====

[#examples-styleargumentsforwarding]
=== Examples

[source,ruby]
----
# bad
def foo(*args, &block)
  bar(*args, &block)
end

# bad
def foo(*args, **kwargs, &block)
  bar(*args, **kwargs, &block)
end

# good
def foo(...)
  bar(...)
end
----

[#useanonymousforwarding_-true-_default_-only-relevant-for-ruby-__-3_2_-styleargumentsforwarding]
==== UseAnonymousForwarding: true (default, only relevant for Ruby >= 3.2)

[source,ruby]
----
# bad
def foo(*args, **kwargs, &block)
  args_only(*args)
  kwargs_only(**kwargs)
  block_only(&block)
end

# good
def foo(*, **, &)
  args_only(*)
  kwargs_only(**)
  block_only(&)
end
----

[#useanonymousforwarding_-false-_only-relevant-for-ruby-__-3_2_-styleargumentsforwarding]
==== UseAnonymousForwarding: false (only relevant for Ruby >= 3.2)

[source,ruby]
----
# good
def foo(*args, **kwargs, &block)
  args_only(*args)
  kwargs_only(**kwargs)
  block_only(&block)
end
----

[#allowonlyrestargument_-true-_default_-only-relevant-for-ruby-_-3_2_-styleargumentsforwarding]
==== AllowOnlyRestArgument: true (default, only relevant for Ruby < 3.2)

[source,ruby]
----
# good
def foo(*args)
  bar(*args)
end

def foo(**kwargs)
  bar(**kwargs)
end
----

[#allowonlyrestargument_-false-_only-relevant-for-ruby-_-3_2_-styleargumentsforwarding]
==== AllowOnlyRestArgument: false (only relevant for Ruby < 3.2)

[source,ruby]
----
# bad
# The following code can replace the arguments with `...`,
# but it will change the behavior. Because `...` forwards block also.
def foo(*args)
  bar(*args)
end

def foo(**kwargs)
  bar(**kwargs)
end
----

[#redundantrestargumentnames_-__args__-_arguments__-_default_-styleargumentsforwarding]
==== RedundantRestArgumentNames: ['args', 'arguments'] (default)

[source,ruby]
----
# bad
def foo(*args)
  bar(*args)
end

# good
def foo(*)
  bar(*)
end
----

[#redundantkeywordrestargumentnames_-__kwargs__-_options__-_opts__-_default_-styleargumentsforwarding]
==== RedundantKeywordRestArgumentNames: ['kwargs', 'options', 'opts'] (default)

[source,ruby]
----
# bad
def foo(**kwargs)
  bar(**kwargs)
end

# good
def foo(**)
  bar(**)
end
----

[#redundantblockargumentnames_-__blk__-_block__-_proc__-_default_-styleargumentsforwarding]
==== RedundantBlockArgumentNames: ['blk', 'block', 'proc'] (default)

[source,ruby]
----
# bad - But it is good with `EnforcedStyle: explicit` set for `Naming/BlockForwarding`.
def foo(&block)
  bar(&block)
end

# good
def foo(&)
  bar(&)
end
----

[#configurable-attributes-styleargumentsforwarding]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowOnlyRestArgument
| `true`
| Boolean

| UseAnonymousForwarding
| `true`
| Boolean

| RedundantRestArgumentNames
| `args`, `arguments`
| Array

| RedundantKeywordRestArgumentNames
| `kwargs`, `options`, `opts`
| Array

| RedundantBlockArgumentNames
| `blk`, `block`, `proc`
| Array
|===

[#references-styleargumentsforwarding]
=== References

* https://rubystyle.guide#arguments-forwarding

[#stylearraycoercion]
== Style/ArrayCoercion

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| No
| Always (Unsafe)
| 0.88
| -
|===

Enforces the use of `Array()` instead of explicit `Array` check or `[*var]`.

The cop is disabled by default due to safety concerns.

[#safety-stylearraycoercion]
=== Safety

This cop is unsafe because a false positive may occur if
the argument of `Array()` is (or could be) nil or depending
on how the argument is handled by `Array()` (which can be
different than just wrapping the argument in an array).

For example:

[source,ruby]
----
[nil]             #=> [nil]
Array(nil)        #=> []

[{a: 'b'}]        #= [{a: 'b'}]
Array({a: 'b'})   #=> [[:a, 'b']]

[Time.now]        #=> [#<Time ...>]
Array(Time.now)   #=> [14, 16, 14, 16, 9, 2021, 4, 259, true, "EDT"]
----

[#examples-stylearraycoercion]
=== Examples

[source,ruby]
----
# bad
paths = [paths] unless paths.is_a?(Array)
paths.each { |path| do_something(path) }

# bad (always creates a new Array instance)
[*paths].each { |path| do_something(path) }

# good (and a bit more readable)
Array(paths).each { |path| do_something(path) }
----

[#references-stylearraycoercion]
=== References

* https://rubystyle.guide#array-coercion

[#stylearrayfirstlast]
== Style/ArrayFirstLast

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| No
| Always (Unsafe)
| 1.58
| -
|===

Identifies usages of `arr[0]` and `arr[-1]` and suggests to change
them to use `arr.first` and `arr.last` instead.

The cop is disabled by default due to safety concerns.

[#safety-stylearrayfirstlast]
=== Safety

This cop is unsafe because `[0]` or `[-1]` can be called on a Hash,
which returns a value for `0` or `-1` key, but changing these to use
`.first` or `.last` will return first/last tuple instead. Also, String
does not implement `first`/`last` methods.

[#examples-stylearrayfirstlast]
=== Examples

[source,ruby]
----
# bad
arr[0]
arr[-1]

# good
arr.first
arr.last
arr[0] = 2
arr[0][-2]
----

[#references-stylearrayfirstlast]
=== References

* #first-and-last

[#stylearrayintersect]
== Style/ArrayIntersect

NOTE: Requires Ruby version 3.1

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.40
| -
|===

In Ruby 3.1, `Array#intersect?` has been added.

This cop identifies places where `(array1 & array2).any?`
or `(array1.intersection(array2)).any?` can be replaced by
`array1.intersect?(array2)`.

The `array1.intersect?(array2)` method is faster than
`(array1 & array2).any?` and is more readable.

In cases like the following, compatibility is not ensured,
so it will not be detected when using block argument.

[source,ruby]
----
([1] & [1,2]).any? { |x| false }    # => false
[1].intersect?([1,2]) { |x| false } # => true
----

NOTE: Although `Array#intersection` can take zero or multiple arguments,
only cases where exactly one argument is provided can be replaced with
`Array#intersect?` and are handled by this cop.

[#safety-stylearrayintersect]
=== Safety

This cop cannot guarantee that `array1` and `array2` are
actually arrays while method `intersect?` is for arrays only.

[#examples-stylearrayintersect]
=== Examples

[source,ruby]
----
# bad
(array1 & array2).any?
(array1 & array2).empty?
(array1 & array2).none?

# bad
array1.intersection(array2).any?
array1.intersection(array2).empty?
array1.intersection(array2).none?

# good
array1.intersect?(array2)
!array1.intersect?(array2)
----

[#allcops_activesupportextensionsenabled_-false-_default_-stylearrayintersect]
==== AllCops:ActiveSupportExtensionsEnabled: false (default)

[source,ruby]
----
# good
(array1 & array2).present?
(array1 & array2).blank?
----

[#allcops_activesupportextensionsenabled_-true-stylearrayintersect]
==== AllCops:ActiveSupportExtensionsEnabled: true

[source,ruby]
----
# bad
(array1 & array2).present?
(array1 & array2).blank?

# good
array1.intersect?(array2)
!array1.intersect?(array2)
----

[#stylearrayjoin]
== Style/ArrayJoin

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.20
| 0.31
|===

Checks for uses of "*" as a substitute for _join_.

Not all cases can reliably checked, due to Ruby's dynamic
types, so we consider only cases when the first argument is an
array literal or the second is a string literal.

[#examples-stylearrayjoin]
=== Examples

[source,ruby]
----
# bad
%w(foo bar baz) * ","

# good
%w(foo bar baz).join(",")
----

[#references-stylearrayjoin]
=== References

* https://rubystyle.guide#array-join

[#styleasciicomments]
== Style/AsciiComments

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.9
| 1.21
|===

Checks for non-ascii (non-English) characters
in comments. You could set an array of allowed non-ascii chars in
`AllowedChars` attribute (copyright notice "©" by default).

[#examples-styleasciicomments]
=== Examples

[source,ruby]
----
# bad
# Translates from English to 日本語。

# good
# Translates from English to Japanese
----

[#configurable-attributes-styleasciicomments]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedChars
| `©`
| Array
|===

[#references-styleasciicomments]
=== References

* https://rubystyle.guide#english-comments

[#styleattr]
== Style/Attr

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.12
|===

Checks for uses of Module#attr.

[#examples-styleattr]
=== Examples

[source,ruby]
----
# bad - creates a single attribute accessor (deprecated in Ruby 1.9)
attr :something, true
attr :one, :two, :three # behaves as attr_reader

# good
attr_accessor :something
attr_reader :one, :two, :three
----

[#references-styleattr]
=== References

* https://rubystyle.guide#attr

[#styleautoresourcecleanup]
== Style/AutoResourceCleanup

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.30
| -
|===

Checks for cases when you could use a block
accepting version of a method that does automatic
resource cleanup.

[#examples-styleautoresourcecleanup]
=== Examples

[source,ruby]
----
# bad
f = File.open('file')

# good
File.open('file') do |f|
  # ...
end

# bad
f = Tempfile.open('temp')

# good
Tempfile.open('temp') do |f|
  # ...
end
----

[#stylebarepercentliterals]
== Style/BarePercentLiterals

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.25
| -
|===

Checks if usage of %() or %Q() matches configuration.

[#examples-stylebarepercentliterals]
=== Examples

[#enforcedstyle_-bare_percent-_default_-stylebarepercentliterals]
==== EnforcedStyle: bare_percent (default)

[source,ruby]
----
# bad
%Q(He said: "#{greeting}")
%q{She said: 'Hi'}

# good
%(He said: "#{greeting}")
%{She said: 'Hi'}
----

[#enforcedstyle_-percent_q-stylebarepercentliterals]
==== EnforcedStyle: percent_q

[source,ruby]
----
# bad
%|He said: "#{greeting}"|
%/She said: 'Hi'/

# good
%Q|He said: "#{greeting}"|
%q/She said: 'Hi'/
----

[#configurable-attributes-stylebarepercentliterals]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `bare_percent`
| `percent_q`, `bare_percent`
|===

[#references-stylebarepercentliterals]
=== References

* https://rubystyle.guide#percent-q-shorthand

[#stylebeginblock]
== Style/BeginBlock

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.9
| -
|===

Checks for BEGIN blocks.

[#examples-stylebeginblock]
=== Examples

[source,ruby]
----
# bad
BEGIN { test }
----

[#references-stylebeginblock]
=== References

* https://rubystyle.guide#no-BEGIN-blocks

[#stylebisectedattraccessor]
== Style/BisectedAttrAccessor

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.87
| -
|===

Checks for places where `attr_reader` and `attr_writer`
for the same method can be combined into single `attr_accessor`.

[#examples-stylebisectedattraccessor]
=== Examples

[source,ruby]
----
# bad
class Foo
  attr_reader :bar
  attr_writer :bar
end

# good
class Foo
  attr_accessor :bar
end
----

[#stylebitwisepredicate]
== Style/BitwisePredicate

NOTE: Requires Ruby version 2.5

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.68
| -
|===

Prefer bitwise predicate methods over direct comparison operations.

[#safety-stylebitwisepredicate]
=== Safety

This cop is unsafe, as it can produce false positives if the receiver
is not an `Integer` object.

[#examples-stylebitwisepredicate]
=== Examples

[source,ruby]
----
# bad - checks any set bits
(variable & flags).positive?

# good
variable.anybits?(flags)

# bad - checks all set bits
(variable & flags) == flags

# good
variable.allbits?(flags)

# bad - checks no set bits
(variable & flags).zero?

# good
variable.nobits?(flags)
----

[#references-stylebitwisepredicate]
=== References

* https://rubystyle.guide#bitwise-predicate-methods

[#styleblockcomments]
== Style/BlockComments

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.23
|===

Looks for uses of block comments (=begin...=end).

[#examples-styleblockcomments]
=== Examples

[source,ruby]
----
# bad
=begin
Multiple lines
of comments...
=end

# good
# Multiple lines
# of comments...
----

[#references-styleblockcomments]
=== References

* https://rubystyle.guide#no-block-comments

[#styleblockdelimiters]
== Style/BlockDelimiters

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.30
| 0.35
|===

Check for uses of braces or do/end around single line or
multi-line blocks.

Methods that can be either procedural or functional and cannot be
categorised from their usage alone is ignored.
`lambda`, `proc`, and `it` are their defaults.
Additional methods can be added to the `AllowedMethods`.

[#examples-styleblockdelimiters]
=== Examples

[#enforcedstyle_-line_count_based-_default_-styleblockdelimiters]
==== EnforcedStyle: line_count_based (default)

[source,ruby]
----
# bad - single line block
items.each do |item| item / 5 end

# good - single line block
items.each { |item| item / 5 }

# bad - multi-line block
things.map { |thing|
  something = thing.some_method
  process(something)
}

# good - multi-line block
things.map do |thing|
  something = thing.some_method
  process(something)
end
----

[#enforcedstyle_-semantic-styleblockdelimiters]
==== EnforcedStyle: semantic

[source,ruby]
----
# Prefer `do...end` over `{...}` for procedural blocks.

# return value is used/assigned
# bad
foo = map do |x|
  x
end
puts (map do |x|
  x
end)

# return value is not used out of scope
# good
map do |x|
  x
end

# Prefer `{...}` over `do...end` for functional blocks.

# return value is not used out of scope
# bad
each { |x|
  x
}

# return value is used/assigned
# good
foo = map { |x|
  x
}
map { |x|
  x
}.inspect

# The AllowBracesOnProceduralOneLiners option is allowed unless the
# EnforcedStyle is set to `semantic`. If so:

# If the AllowBracesOnProceduralOneLiners option is unspecified, or
# set to `false` or any other falsey value, then semantic purity is
# maintained, so one-line procedural blocks must use do-end, not
# braces.

# bad
collection.each { |element| puts element }

# good
collection.each do |element| puts element end

# If the AllowBracesOnProceduralOneLiners option is set to `true`, or
# any other truthy value, then one-line procedural blocks may use
# either style. (There is no setting for requiring braces on them.)

# good
collection.each { |element| puts element }

# also good
collection.each do |element| puts element end
----

[#enforcedstyle_-braces_for_chaining-styleblockdelimiters]
==== EnforcedStyle: braces_for_chaining

[source,ruby]
----
# bad
words.each do |word|
  word.flip.flop
end.join("-")

# good
words.each { |word|
  word.flip.flop
}.join("-")
----

[#enforcedstyle_-always_braces-styleblockdelimiters]
==== EnforcedStyle: always_braces

[source,ruby]
----
# bad
words.each do |word|
  word.flip.flop
end

# good
words.each { |word|
  word.flip.flop
}
----

[#bracesrequiredmethods_-__sig__-styleblockdelimiters]
==== BracesRequiredMethods: ['sig']

[source,ruby]
----
# Methods listed in the BracesRequiredMethods list, such as 'sig'
# in this example, will require `{...}` braces. This option takes
# precedence over all other configurations except AllowedMethods.

# bad
sig do
  params(
    foo: string,
  ).void
end
def bar(foo)
  puts foo
end

# good
sig {
  params(
    foo: string,
  ).void
}
def bar(foo)
  puts foo
end
----

[#allowedmethods_-__lambda__-_proc__-_it_-_-_default_-styleblockdelimiters]
==== AllowedMethods: ['lambda', 'proc', 'it' ] (default)

[source,ruby]
----
# good
foo = lambda do |x|
  puts "Hello, #{x}"
end

foo = lambda do |x|
  x * 100
end
----

[#allowedpatterns_-__-_default_-styleblockdelimiters]
==== AllowedPatterns: [] (default)

[source,ruby]
----
# bad
things.map { |thing|
  something = thing.some_method
  process(something)
}
----

[#allowedpatterns_-__map__-styleblockdelimiters]
==== AllowedPatterns: ['map']

[source,ruby]
----
# good
things.map { |thing|
  something = thing.some_method
  process(something)
}
----

[#configurable-attributes-styleblockdelimiters]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `line_count_based`
| `line_count_based`, `semantic`, `braces_for_chaining`, `always_braces`

| ProceduralMethods
| `benchmark`, `bm`, `bmbm`, `create`, `each_with_object`, `measure`, `new`, `realtime`, `tap`, `with_object`
| Array

| FunctionalMethods
| `let`, `let!`, `subject`, `watch`
| Array

| AllowedMethods
| `lambda`, `proc`, `it`
| Array

| AllowedPatterns
| `[]`
| Array

| AllowBracesOnProceduralOneLiners
| `false`
| Boolean

| BracesRequiredMethods
| `[]`
| Array
|===

[#references-styleblockdelimiters]
=== References

* https://rubystyle.guide#single-line-blocks

[#stylecaseequality]
== Style/CaseEquality

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.89
|===

If `AllowOnSelfClass` option is enabled, the cop will ignore violations when the receiver of
the case equality operator is `self.class`. Note intermediate variables are not accepted.

[#examples-stylecaseequality]
=== Examples

[source,ruby]
----
# bad
(1..100) === 7
/something/ === some_string

# good
something.is_a?(Array)
(1..100).include?(7)
/something/.match?(some_string)
----

[#allowonconstant_-false-_default_-stylecaseequality]
==== AllowOnConstant: false (default)

[source,ruby]
----
# bad
Array === something
----

[#allowonconstant_-true-stylecaseequality]
==== AllowOnConstant: true

[source,ruby]
----
# good
Array === something
----

[#allowonselfclass_-false-_default_-stylecaseequality]
==== AllowOnSelfClass: false (default)

[source,ruby]
----
# bad
self.class === something
----

[#allowonselfclass_-true-stylecaseequality]
==== AllowOnSelfClass: true

[source,ruby]
----
# good
self.class === something
----

[#configurable-attributes-stylecaseequality]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowOnConstant
| `false`
| Boolean

| AllowOnSelfClass
| `false`
| Boolean
|===

[#references-stylecaseequality]
=== References

* https://rubystyle.guide#no-case-equality

[#stylecaselikeif]
== Style/CaseLikeIf

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.88
| 1.48
|===

Identifies places where `if-elsif` constructions
can be replaced with `case-when`.

[#safety-stylecaselikeif]
=== Safety

This cop is unsafe. `case` statements use `===` for equality,
so if the original conditional used a different equality operator, the
behavior may be different.

[#examples-stylecaselikeif]
=== Examples

[#minbranchescount_-3-_default_-stylecaselikeif]
==== MinBranchesCount: 3 (default)

[source,ruby]
----
# bad
if status == :active
  perform_action
elsif status == :inactive || status == :hibernating
  check_timeout
elsif status == :invalid
  report_invalid
else
  final_action
end

# good
case status
when :active
  perform_action
when :inactive, :hibernating
  check_timeout
when :invalid
  report_invalid
else
  final_action
end
----

[#minbranchescount_-4-stylecaselikeif]
==== MinBranchesCount: 4

[source,ruby]
----
# good
if status == :active
  perform_action
elsif status == :inactive || status == :hibernating
  check_timeout
elsif status == :invalid
  report_invalid
else
  final_action
end
----

[#configurable-attributes-stylecaselikeif]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| MinBranchesCount
| `3`
| Integer
|===

[#references-stylecaselikeif]
=== References

* https://rubystyle.guide#case-vs-if-else

[#stylecharacterliteral]
== Style/CharacterLiteral

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| -
|===

Checks for uses of the character literal ?x.
Starting with Ruby 1.9 character literals are
essentially one-character strings, so this syntax
is mostly redundant at this point.

? character literal can be used to express meta and control character.
That's a good use case of ? literal so it doesn't count it as an offense.

[#examples-stylecharacterliteral]
=== Examples

[source,ruby]
----
# bad
?x

# good
'x'

# good - control & meta escapes
?\C-\M-d
"\C-\M-d" # same as above
----

[#references-stylecharacterliteral]
=== References

* https://rubystyle.guide#no-character-literals

[#styleclassandmodulechildren]
== Style/ClassAndModuleChildren

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.19
| 1.74
|===

Checks that namespaced classes and modules are defined with a consistent style.

With `nested` style, classes and modules should be defined separately (one constant
on each line, without `::`). With `compact` style, classes and modules should be
defined with fully qualified names (using `::` for namespaces).

NOTE: The style chosen will affect `Module.nesting` for the class or module. Using
`nested` style will result in each level being added, whereas `compact` style will
only include the fully qualified class or module name.

By default, `EnforcedStyle` applies to both classes and modules. If desired, separate
styles can be defined for classes and modules by using `EnforcedStyleForClasses` and
`EnforcedStyleForModules` respectively. If not set, or set to nil, the `EnforcedStyle`
value will be used.

The compact style is only forced for classes/modules with one child.

[#safety-styleclassandmodulechildren]
=== Safety

Autocorrection is unsafe.

Moving from `compact` to `nested` children requires knowledge of whether the
outer parent is a module or a class. Moving from `nested` to `compact` requires
verification that the outer parent is defined elsewhere. RuboCop does not
have the knowledge to perform either operation safely and thus requires
manual oversight.

[#examples-styleclassandmodulechildren]
=== Examples

[#enforcedstyle_-nested-_default_-styleclassandmodulechildren]
==== EnforcedStyle: nested (default)

[source,ruby]
----
# good
# have each child on its own line
class Foo
  class Bar
  end
end
----

[#enforcedstyle_-compact-styleclassandmodulechildren]
==== EnforcedStyle: compact

[source,ruby]
----
# good
# combine definitions as much as possible
class Foo::Bar
end
----

[#configurable-attributes-styleclassandmodulechildren]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `nested`
| `nested`, `compact`

| EnforcedStyleForClasses
| `<none>`
| `<none>`, `nested`, `compact`

| EnforcedStyleForModules
| `<none>`
| `<none>`, `nested`, `compact`
|===

[#references-styleclassandmodulechildren]
=== References

* https://rubystyle.guide#namespace-definition

[#styleclasscheck]
== Style/ClassCheck

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.24
| -
|===

Enforces consistent use of `Object#is_a?` or `Object#kind_of?`.

[#examples-styleclasscheck]
=== Examples

[#enforcedstyle_-is_a_-_default_-styleclasscheck]
==== EnforcedStyle: is_a? (default)

[source,ruby]
----
# bad
var.kind_of?(Date)
var.kind_of?(Integer)

# good
var.is_a?(Date)
var.is_a?(Integer)
----

[#enforcedstyle_-kind_of_-styleclasscheck]
==== EnforcedStyle: kind_of?

[source,ruby]
----
# bad
var.is_a?(Time)
var.is_a?(String)

# good
var.kind_of?(Time)
var.kind_of?(String)
----

[#configurable-attributes-styleclasscheck]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `is_a?`
| `is_a?`, `kind_of?`
|===

[#references-styleclasscheck]
=== References

* https://rubystyle.guide#is-a-vs-kind-of

[#styleclassequalitycomparison]
== Style/ClassEqualityComparison

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.93
| 1.57
|===

Enforces the use of `Object#instance_of?` instead of class comparison
for equality.
`==`, `equal?`, and `eql?` custom method definitions are allowed by default.
These are customizable with `AllowedMethods` option.

[#safety-styleclassequalitycomparison]
=== Safety

This cop's autocorrection is unsafe because there is no guarantee that
the constant `Foo` exists when autocorrecting `var.class.name == 'Foo'` to
`var.instance_of?(Foo)`.

[#examples-styleclassequalitycomparison]
=== Examples

[source,ruby]
----
# bad
var.class == Date
var.class.equal?(Date)
var.class.eql?(Date)
var.class.name == 'Date'

# good
var.instance_of?(Date)
----

[#allowedmethods_-______-_equal___-_eql___-_default_-styleclassequalitycomparison]
==== AllowedMethods: ['==', 'equal?', 'eql?'] (default)

[source,ruby]
----
# good
def ==(other)
  self.class == other.class && name == other.name
end

def equal?(other)
  self.class.equal?(other.class) && name.equal?(other.name)
end

def eql?(other)
  self.class.eql?(other.class) && name.eql?(other.name)
end
----

[#allowedpatterns_-__-_default_-styleclassequalitycomparison]
==== AllowedPatterns: [] (default)

[source,ruby]
----
# bad
def eq(other)
  self.class.eq(other.class) && name.eq(other.name)
end
----

[#allowedpatterns_-__eq__-styleclassequalitycomparison]
==== AllowedPatterns: ['eq']

[source,ruby]
----
# good
def eq(other)
  self.class.eq(other.class) && name.eq(other.name)
end
----

[#configurable-attributes-styleclassequalitycomparison]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedMethods
| `==`, `equal?`, `eql?`
| Array

| AllowedPatterns
| `[]`
| Array
|===

[#references-styleclassequalitycomparison]
=== References

* https://rubystyle.guide#instance-of-vs-class-comparison

[#styleclassmethods]
== Style/ClassMethods

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.20
|===

Checks for uses of the class/module name instead of
self, when defining class/module methods.

[#examples-styleclassmethods]
=== Examples

[source,ruby]
----
# bad
class SomeClass
  def SomeClass.class_method
    # ...
  end
end

# good
class SomeClass
  def self.class_method
    # ...
  end
end
----

[#references-styleclassmethods]
=== References

* https://rubystyle.guide#def-self-class-methods

[#styleclassmethodsdefinitions]
== Style/ClassMethodsDefinitions

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| Always
| 0.89
| -
|===

Enforces using `def self.method_name` or `class << self` to define class methods.

[#examples-styleclassmethodsdefinitions]
=== Examples

[#enforcedstyle_-def_self-_default_-styleclassmethodsdefinitions]
==== EnforcedStyle: def_self (default)

[source,ruby]
----
# bad
class SomeClass
  class << self
    attr_accessor :class_accessor

    def class_method
      # ...
    end
  end
end

# good
class SomeClass
  def self.class_method
    # ...
  end

  class << self
    attr_accessor :class_accessor
  end
end

# good - contains private method
class SomeClass
  class << self
    attr_accessor :class_accessor

    private

    def private_class_method
      # ...
    end
  end
end
----

[#enforcedstyle_-self_class-styleclassmethodsdefinitions]
==== EnforcedStyle: self_class

[source,ruby]
----
# bad
class SomeClass
  def self.class_method
    # ...
  end
end

# good
class SomeClass
  class << self
    def class_method
      # ...
    end
  end
end
----

[#configurable-attributes-styleclassmethodsdefinitions]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `def_self`
| `def_self`, `self_class`
|===

[#references-styleclassmethodsdefinitions]
=== References

* https://rubystyle.guide#def-self-class-methods

[#styleclassvars]
== Style/ClassVars

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.13
| -
|===

Checks for uses of class variables. Offenses
are signaled only on assignment to class variables to
reduce the number of offenses that would be reported.

You have to be careful when setting a value for a class
variable; if a class has been inherited, changing the
value of a class variable also affects the inheriting
classes. This means that it's almost always better to
use a class instance variable instead.

[#examples-styleclassvars]
=== Examples

[source,ruby]
----
# bad
class A
  @@test = 10
end

class A
  def self.test(name, value)
    class_variable_set("@@#{name}", value)
  end
end

class A; end
A.class_variable_set(:@@test, 10)

# good
class A
  @test = 10
end

class A
  def test
    @@test # you can access class variable without offense
  end
end

class A
  def self.test(name)
    class_variable_get("@@#{name}") # you can access without offense
  end
end
----

[#references-styleclassvars]
=== References

* https://rubystyle.guide#no-class-vars

[#stylecollectioncompact]
== Style/CollectionCompact

NOTE: Requires Ruby version 2.4

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.2
| 1.3
|===

Checks for places where custom logic on rejection nils from arrays
and hashes can be replaced with `{Array,Hash}#{compact,compact!}`.

[#safety-stylecollectioncompact]
=== Safety

It is unsafe by default because false positives may occur in the
`nil` check of block arguments to the receiver object. Additionally,
we can't know the type of the receiver object for sure, which may
result in false positives as well.

For example, `[[1, 2], [3, nil]].reject { |first, second| second.nil? }`
and `[[1, 2], [3, nil]].compact` are not compatible. This will work fine
when the receiver is a hash object.

[#examples-stylecollectioncompact]
=== Examples

[source,ruby]
----
# bad
array.reject(&:nil?)
array.reject { |e| e.nil? }
array.select { |e| !e.nil? }
array.filter { |e| !e.nil? }
array.grep_v(nil)
array.grep_v(NilClass)

# good
array.compact

# bad
hash.reject!(&:nil?)
hash.reject! { |k, v| v.nil? }
hash.select! { |k, v| !v.nil? }
hash.filter! { |k, v| !v.nil? }

# good
hash.compact!
----

[#allowedreceivers_-__params__-stylecollectioncompact]
==== AllowedReceivers: ['params']

[source,ruby]
----
# good
params.reject(&:nil?)
----

[#configurable-attributes-stylecollectioncompact]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedReceivers
| `[]`
| Array
|===

[#stylecollectionmethods]
== Style/CollectionMethods

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| No
| Always (Unsafe)
| 0.9
| 1.7
|===

Enforces the use of consistent method names
from the Enumerable module.

You can customize the mapping from undesired method to desired method.

e.g. to use `detect` over `find`:

  Style/CollectionMethods:
    PreferredMethods:
      find: detect

[#safety-stylecollectionmethods]
=== Safety

This cop is unsafe because it finds methods by name, without actually
being able to determine if the receiver is an Enumerable or not, so
this cop may register false positives.

[#examples-stylecollectionmethods]
=== Examples

[source,ruby]
----
# These examples are based on the default mapping for `PreferredMethods`.

# bad
items.collect
items.collect!
items.collect_concat
items.inject
items.detect
items.find_all
items.member?

# good
items.map
items.map!
items.flat_map
items.reduce
items.find
items.select
items.include?
----

[#configurable-attributes-stylecollectionmethods]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| PreferredMethods
| `{"collect" => "map", "collect!" => "map!", "collect_concat" => "flat_map", "inject" => "reduce", "detect" => "find", "find_all" => "select", "member?" => "include?"}`
| 

| MethodsAcceptingSymbol
| `inject`, `reduce`
| Array
|===

[#references-stylecollectionmethods]
=== References

* https://rubystyle.guide#map-find-select-reduce-include-size

[#stylecolonmethodcall]
== Style/ColonMethodCall

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| -
|===

Checks for methods invoked via the `::` operator instead
of the `.` operator (like `FileUtils::rmdir` instead of `FileUtils.rmdir`).

[#examples-stylecolonmethodcall]
=== Examples

[source,ruby]
----
# bad
Timeout::timeout(500) { do_something }
FileUtils::rmdir(dir)
Marshal::dump(obj)

# good
Timeout.timeout(500) { do_something }
FileUtils.rmdir(dir)
Marshal.dump(obj)
----

[#references-stylecolonmethodcall]
=== References

* https://rubystyle.guide#double-colons

[#stylecolonmethoddefinition]
== Style/ColonMethodDefinition

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.52
| -
|===

Checks for class methods that are defined using the `::`
operator instead of the `.` operator.

[#examples-stylecolonmethoddefinition]
=== Examples

[source,ruby]
----
# bad
class Foo
  def self::bar
  end
end

# good
class Foo
  def self.bar
  end
end
----

[#references-stylecolonmethoddefinition]
=== References

* https://rubystyle.guide#colon-method-definition

[#stylecombinabledefined]
== Style/CombinableDefined

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.68
| -
|===

Checks for multiple `defined?` calls joined by `&&` that can be combined
into a single `defined?`.

When checking that a nested constant or chained method is defined, it is
not necessary to check each ancestor or component of the chain.

[#examples-stylecombinabledefined]
=== Examples

[source,ruby]
----
# bad
defined?(Foo) && defined?(Foo::Bar) && defined?(Foo::Bar::Baz)

# good
defined?(Foo::Bar::Baz)

# bad
defined?(foo) && defined?(foo.bar) && defined?(foo.bar.baz)

# good
defined?(foo.bar.baz)
----

[#stylecombinableloops]
== Style/CombinableLoops

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.90
| -
|===

Checks for places where multiple consecutive loops over the same data
can be combined into a single loop. It is very likely that combining them
will make the code more efficient and more concise.

NOTE: Autocorrection is not applied when the block variable names differ in separate loops,
as it is impossible to determine which variable name should be prioritized.

[#safety-stylecombinableloops]
=== Safety

The cop is unsafe, because the first loop might modify state that the
second loop depends on; these two aren't combinable.

[#examples-stylecombinableloops]
=== Examples

[source,ruby]
----
# bad
def method
  items.each do |item|
    do_something(item)
  end

  items.each do |item|
    do_something_else(item)
  end
end

# good
def method
  items.each do |item|
    do_something(item)
    do_something_else(item)
  end
end

# bad
def method
  for item in items do
    do_something(item)
  end

  for item in items do
    do_something_else(item)
  end
end

# good
def method
  for item in items do
    do_something(item)
    do_something_else(item)
  end
end

# good
def method
  each_slice(2) { |slice| do_something(slice) }
  each_slice(3) { |slice| do_something(slice) }
end
----

[#stylecommandliteral]
== Style/CommandLiteral

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.30
| -
|===

Enforces using `` or %x around command literals.

[#examples-stylecommandliteral]
=== Examples

[#enforcedstyle_-backticks-_default_-stylecommandliteral]
==== EnforcedStyle: backticks (default)

[source,ruby]
----
# bad
folders = %x(find . -type d).split

# bad
%x(
  ln -s foo.example.yml foo.example
  ln -s bar.example.yml bar.example
)

# good
folders = `find . -type d`.split

# good
`
  ln -s foo.example.yml foo.example
  ln -s bar.example.yml bar.example
`
----

[#enforcedstyle_-mixed-stylecommandliteral]
==== EnforcedStyle: mixed

[source,ruby]
----
# bad
folders = %x(find . -type d).split

# bad
`
  ln -s foo.example.yml foo.example
  ln -s bar.example.yml bar.example
`

# good
folders = `find . -type d`.split

# good
%x(
  ln -s foo.example.yml foo.example
  ln -s bar.example.yml bar.example
)
----

[#enforcedstyle_-percent_x-stylecommandliteral]
==== EnforcedStyle: percent_x

[source,ruby]
----
# bad
folders = `find . -type d`.split

# bad
`
  ln -s foo.example.yml foo.example
  ln -s bar.example.yml bar.example
`

# good
folders = %x(find . -type d).split

# good
%x(
  ln -s foo.example.yml foo.example
  ln -s bar.example.yml bar.example
)
----

[#allowinnerbackticks_-false-_default_-stylecommandliteral]
==== AllowInnerBackticks: false (default)

[source,ruby]
----
# If `false`, the cop will always recommend using `%x` if one or more
# backticks are found in the command string.

# bad
`echo \`ls\``

# good
%x(echo `ls`)
----

[#allowinnerbackticks_-true-stylecommandliteral]
==== AllowInnerBackticks: true

[source,ruby]
----
# good
`echo \`ls\``
----

[#configurable-attributes-stylecommandliteral]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `backticks`
| `backticks`, `percent_x`, `mixed`

| AllowInnerBackticks
| `false`
| Boolean
|===

[#references-stylecommandliteral]
=== References

* https://rubystyle.guide#percent-x

[#stylecommentannotation]
== Style/CommentAnnotation

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.10
| 1.20
|===

Checks that comment annotation keywords are written according
to guidelines.

Annotation keywords can be specified by overriding the cop's `Keywords`
configuration. Keywords are allowed to be single words or phrases.

NOTE: With a multiline comment block (where each line is only a
comment), only the first line will be able to register an offense, even
if an annotation keyword starts another line. This is done to prevent
incorrect registering of keywords (eg. `review`) inside a paragraph as an
annotation.

[#examples-stylecommentannotation]
=== Examples

[#requirecolon_-true-_default_-stylecommentannotation]
==== RequireColon: true (default)

[source,ruby]
----
# bad
# TODO make better

# good
# TODO: make better

# bad
# TODO:make better

# good
# TODO: make better

# bad
# fixme: does not work

# good
# FIXME: does not work

# bad
# Optimize does not work

# good
# OPTIMIZE: does not work
----

[#requirecolon_-false-stylecommentannotation]
==== RequireColon: false

[source,ruby]
----
# bad
# TODO: make better

# good
# TODO make better

# bad
# fixme does not work

# good
# FIXME does not work

# bad
# Optimize does not work

# good
# OPTIMIZE does not work
----

[#configurable-attributes-stylecommentannotation]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| Keywords
| `TODO`, `FIXME`, `OPTIMIZE`, `HACK`, `REVIEW`, `NOTE`
| Array

| RequireColon
| `true`
| Boolean
|===

[#references-stylecommentannotation]
=== References

* https://rubystyle.guide#annotate-keywords

[#stylecommentedkeyword]
== Style/CommentedKeyword

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.51
| 1.19
|===

Checks for comments put on the same line as some keywords.
These keywords are: `class`, `module`, `def`, `begin`, `end`.

Note that some comments
(`:nodoc:`, `:yields:`, `rubocop:disable` and `rubocop:todo`),
RBS::Inline annotation, and Steep annotation (`steep:ignore`) are allowed.

Autocorrection removes comments from `end` keyword and keeps comments
for `class`, `module`, `def` and `begin` above the keyword.

[#safety-stylecommentedkeyword]
=== Safety

Autocorrection is unsafe because it may remove a comment that is
meaningful.

[#examples-stylecommentedkeyword]
=== Examples

[source,ruby]
----
# bad
if condition
  statement
end # end if

# bad
class X # comment
  statement
end

# bad
def x; end # comment

# good
if condition
  statement
end

# good
class X # :nodoc:
  y
end
----

[#stylecomparablebetween]
== Style/ComparableBetween

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.74
| 1.75
|===

Checks for logical comparison which can be replaced with `Comparable#between?`.

NOTE: `Comparable#between?` is on average slightly slower than logical comparison,
although the difference generally isn't observable. If you require maximum
performance, consider using logical comparison.

[#safety-stylecomparablebetween]
=== Safety

This cop is unsafe because the receiver may not respond to `between?`.

[#examples-stylecomparablebetween]
=== Examples

[source,ruby]
----
# bad
x >= min && x <= max

# bad
x <= max && x >= min

# good
x.between?(min, max)
----

[#references-stylecomparablebetween]
=== References

* https://rubystyle.guide#ranges-or-between

[#stylecomparableclamp]
== Style/ComparableClamp

NOTE: Requires Ruby version 2.4

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.44
| -
|===

Enforces the use of `Comparable#clamp` instead of comparison by minimum and maximum.

This cop supports autocorrection for `if/elsif/else` bad style only.
Because `ArgumentError` occurs if the minimum and maximum of `clamp` arguments are reversed.
When these are variables, it is not possible to determine which is the minimum and maximum:

[source,ruby]
----
[1, [2, 3].max].min # => 1
1.clamp(3, 1)       # => min argument must be smaller than max argument (ArgumentError)
----

[#examples-stylecomparableclamp]
=== Examples

[source,ruby]
----
# bad
[[x, low].max, high].min

# bad
if x < low
  low
elsif high < x
  high
else
  x
end

# good
x.clamp(low, high)
----

[#styleconcatarrayliterals]
== Style/ConcatArrayLiterals

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.41
| -
|===

Enforces the use of `Array#push(item)` instead of `Array#concat([item])`
to avoid redundant array literals.

[#safety-styleconcatarrayliterals]
=== Safety

This cop is unsafe, as it can produce false positives if the receiver
is not an `Array` object.

[#examples-styleconcatarrayliterals]
=== Examples

[source,ruby]
----
# bad
list.concat([foo])
list.concat([bar, baz])
list.concat([qux, quux], [corge])

# good
list.push(foo)
list.push(bar, baz)
list.push(qux, quux, corge)
----

[#styleconditionalassignment]
== Style/ConditionalAssignment

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.36
| 0.47
|===

Check for `if` and `case` statements where each branch is used for
both the assignment and comparison of the same variable
when using the return of the condition can be used instead.

[#examples-styleconditionalassignment]
=== Examples

[#enforcedstyle_-assign_to_condition-_default_-styleconditionalassignment]
==== EnforcedStyle: assign_to_condition (default)

[source,ruby]
----
# bad
if foo
  bar = 1
else
  bar = 2
end

case foo
when 'a'
  bar += 1
else
  bar += 2
end

if foo
  some_method
  bar = 1
else
  some_other_method
  bar = 2
end

# good
bar = if foo
        1
      else
        2
      end

bar += case foo
       when 'a'
         1
       else
         2
       end

bar << if foo
         some_method
         1
       else
         some_other_method
         2
       end
----

[#enforcedstyle_-assign_inside_condition-styleconditionalassignment]
==== EnforcedStyle: assign_inside_condition

[source,ruby]
----
# bad
bar = if foo
        1
      else
        2
      end

bar += case foo
       when 'a'
         1
       else
         2
       end

bar << if foo
         some_method
         1
       else
         some_other_method
         2
       end

# good
if foo
  bar = 1
else
  bar = 2
end

case foo
when 'a'
  bar += 1
else
  bar += 2
end

if foo
  some_method
  bar = 1
else
  some_other_method
  bar = 2
end
----

[#configurable-attributes-styleconditionalassignment]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `assign_to_condition`
| `assign_to_condition`, `assign_inside_condition`

| SingleLineConditionsOnly
| `true`
| Boolean

| IncludeTernaryExpressions
| `true`
| Boolean
|===

[#styleconstantvisibility]
== Style/ConstantVisibility

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.66
| 1.10
|===

Checks that constants defined in classes and modules have
an explicit visibility declaration. By default, Ruby makes all class-
and module constants public, which litters the public API of the
class or module. Explicitly declaring a visibility makes intent more
clear, and prevents outside actors from touching private state.

[#examples-styleconstantvisibility]
=== Examples

[source,ruby]
----
# bad
class Foo
  BAR = 42
  BAZ = 43
end

# good
class Foo
  BAR = 42
  private_constant :BAR

  BAZ = 43
  public_constant :BAZ
end
----

[#ignoremodules_-false-_default_-styleconstantvisibility]
==== IgnoreModules: false (default)

[source,ruby]
----
# bad
class Foo
  MyClass = Struct.new()
end

# good
class Foo
  MyClass = Struct.new()
  public_constant :MyClass
end
----

[#ignoremodules_-true-styleconstantvisibility]
==== IgnoreModules: true

[source,ruby]
----
# good
class Foo
  MyClass = Struct.new()
end
----

[#configurable-attributes-styleconstantvisibility]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| IgnoreModules
| `false`
| Boolean
|===

[#stylecopyright]
== Style/Copyright

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| Always
| 0.30
| -
|===

Check that a copyright notice was given in each source file.

The default regexp for an acceptable copyright notice can be found in
config/default.yml. The default can be changed as follows:

[source,yaml]
----
Style/Copyright:
  Notice: '^Copyright (\(c\) )?2\d{3} Acme Inc'
----

This regex string is treated as an unanchored regex. For each file
that RuboCop scans, a comment that matches this regex must be found or
an offense is reported.

[#configurable-attributes-stylecopyright]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| Notice
| `^Copyright (\(c\) )?2[0-9]{3} .+`
| String

| AutocorrectNotice
| ``
| String
|===

[#styledatainheritance]
== Style/DataInheritance

NOTE: Requires Ruby version 3.2

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always (Unsafe)
| 1.49
| 1.51
|===

Checks for inheritance from `Data.define` to avoid creating the anonymous parent class.
Inheriting from `Data.define` adds a superfluous level in inheritance tree.

[#safety-styledatainheritance]
=== Safety

Autocorrection is unsafe because it will change the inheritance
tree (e.g. return value of `Module#ancestors`) of the constant.

[#examples-styledatainheritance]
=== Examples

[source,ruby]
----
# bad
class Person < Data.define(:first_name, :last_name)
  def age
    42
  end
end

Person.ancestors
# => [Person, #<Class:0x000000010b4e14a0>, Data, (...)]

# good
Person = Data.define(:first_name, :last_name) do
  def age
    42
  end
end

Person.ancestors
# => [Person, Data, (...)]
----

[#references-styledatainheritance]
=== References

* https://rubystyle.guide#no-extend-data-define

[#styledatetime]
== Style/DateTime

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| Always (Unsafe)
| 0.51
| 0.92
|===

Checks for consistent usage of the `DateTime` class over the
`Time` class. This cop is disabled by default since these classes,
although highly overlapping, have particularities that make them not
replaceable in certain situations when dealing with multiple timezones
and/or DST.

[#safety-styledatetime]
=== Safety

Autocorrection is not safe, because `DateTime` and `Time` do not have
exactly the same behavior, although in most cases the autocorrection
will be fine.

[#examples-styledatetime]
=== Examples

[source,ruby]
----
# bad - uses `DateTime` for current time
DateTime.now

# good - uses `Time` for current time
Time.now

# bad - uses `DateTime` for modern date
DateTime.iso8601('2016-06-29')

# good - uses `Time` for modern date
Time.iso8601('2016-06-29')

# good - uses `DateTime` with start argument for historical date
DateTime.iso8601('1751-04-23', Date::ENGLAND)
----

[#allowcoercion_-false-_default_-styledatetime]
==== AllowCoercion: false (default)

[source,ruby]
----
# bad - coerces to `DateTime`
something.to_datetime

# good - coerces to `Time`
something.to_time
----

[#allowcoercion_-true-styledatetime]
==== AllowCoercion: true

[source,ruby]
----
# good
something.to_datetime

# good
something.to_time
----

[#configurable-attributes-styledatetime]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowCoercion
| `false`
| Boolean
|===

[#references-styledatetime]
=== References

* https://rubystyle.guide#date-time

[#styledefwithparentheses]
== Style/DefWithParentheses

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.12
|===

Checks for parentheses in the definition of a method,
that does not take any arguments. Both instance and
class/singleton methods are checked.

[#examples-styledefwithparentheses]
=== Examples

[source,ruby]
----
# bad
def foo()
  do_something
end

# good
def foo
  do_something
end

# bad
def foo() = do_something

# good
def foo = do_something

# good - without parentheses it's a syntax error
def foo() do_something end
def foo()=do_something

# bad
def Baz.foo()
  do_something
end

# good
def Baz.foo
  do_something
end
----

[#references-styledefwithparentheses]
=== References

* https://rubystyle.guide#method-parens

[#styledigchain]
== Style/DigChain

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.69
| -
|===

Check for chained `dig` calls that can be collapsed into a single `dig`.

[#safety-styledigchain]
=== Safety

This cop is unsafe because it cannot be guaranteed that the receiver
is an `Enumerable` or does not have a nonstandard implementation
of `dig`.

[#examples-styledigchain]
=== Examples

[source,ruby]
----
# bad
x.dig(:foo).dig(:bar).dig(:baz)
x.dig(:foo, :bar).dig(:baz)
x.dig(:foo, :bar)&.dig(:baz)

# good
x.dig(:foo, :bar, :baz)

# good - `dig`s cannot be combined
x.dig(:foo).bar.dig(:baz)
----

[#styledir]
== Style/Dir

NOTE: Requires Ruby version 2.0

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.50
| -
|===

Checks for places where the `#\_\_dir\_\_` method can replace more
complex constructs to retrieve a canonicalized absolute path to the
current file.

[#examples-styledir]
=== Examples

[source,ruby]
----
# bad
path = File.expand_path(File.dirname(__FILE__))

# bad
path = File.dirname(File.realpath(__FILE__))

# good
path = __dir__
----

[#styledirempty]
== Style/DirEmpty

NOTE: Requires Ruby version 2.4

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.48
| -
|===

Prefer to use `Dir.empty?('path/to/dir')` when checking if a directory is empty.

[#examples-styledirempty]
=== Examples

[source,ruby]
----
# bad
Dir.entries('path/to/dir').size == 2
Dir.children('path/to/dir').empty?
Dir.children('path/to/dir').size == 0
Dir.each_child('path/to/dir').none?

# good
Dir.empty?('path/to/dir')
----

[#styledisablecopswithinsourcecodedirective]
== Style/DisableCopsWithinSourceCodeDirective

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| Always
| 0.82
| 1.9
|===

Detects comments to enable/disable RuboCop.
This is useful if want to make sure that every RuboCop error gets fixed
and not quickly disabled with a comment.

Specific cops can be allowed with the `AllowedCops` configuration. Note that
if this configuration is set, `rubocop:disable all` is still disallowed.

[#examples-styledisablecopswithinsourcecodedirective]
=== Examples

[source,ruby]
----
# bad
# rubocop:disable Metrics/AbcSize
def foo
end
# rubocop:enable Metrics/AbcSize

# good
def foo
end
----

[#allowedcops_-_metricsabcsize_-styledisablecopswithinsourcecodedirective]
==== AllowedCops: [Metrics/AbcSize]

[source,ruby]
----
# good
# rubocop:disable Metrics/AbcSize
def foo
end
# rubocop:enable Metrics/AbcSize
----

[#configurable-attributes-styledisablecopswithinsourcecodedirective]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedCops
| `[]`
| Array
|===

[#styledocumentdynamicevaldefinition]
== Style/DocumentDynamicEvalDefinition

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| No
| 1.1
| 1.3
|===

When using `class_eval` (or other `eval`) with string interpolation,
add a comment block showing its appearance if interpolated (a practice used in Rails code).

[#examples-styledocumentdynamicevaldefinition]
=== Examples

[source,ruby]
----
# from activesupport/lib/active_support/core_ext/string/output_safety.rb

# bad
UNSAFE_STRING_METHODS.each do |unsafe_method|
  if 'String'.respond_to?(unsafe_method)
    class_eval <<-EOT, __FILE__, __LINE__ + 1
      def #{unsafe_method}(*params, &block)
        to_str.#{unsafe_method}(*params, &block)
      end

      def #{unsafe_method}!(*params)
        @dirty = true
        super
      end
    EOT
  end
end

# good, inline comments in heredoc
UNSAFE_STRING_METHODS.each do |unsafe_method|
  if 'String'.respond_to?(unsafe_method)
    class_eval <<-EOT, __FILE__, __LINE__ + 1
      def #{unsafe_method}(*params, &block)       # def capitalize(*params, &block)
        to_str.#{unsafe_method}(*params, &block)  #   to_str.capitalize(*params, &block)
      end                                         # end

      def #{unsafe_method}!(*params)              # def capitalize!(*params)
        @dirty = true                             #   @dirty = true
        super                                     #   super
      end                                         # end
    EOT
  end
end

# good, block comments in heredoc
class_eval <<-EOT, __FILE__, __LINE__ + 1
  # def capitalize!(*params)
  #   @dirty = true
  #   super
  # end

  def #{unsafe_method}!(*params)
    @dirty = true
    super
  end
EOT

# good, block comments before heredoc
class_eval(
  # def capitalize!(*params)
  #   @dirty = true
  #   super
  # end

  <<-EOT, __FILE__, __LINE__ + 1
    def #{unsafe_method}!(*params)
      @dirty = true
      super
    end
  EOT
)

# bad - interpolated string without comment
class_eval("def #{unsafe_method}!(*params); end")

# good - with inline comment or replace it with block comment using heredoc
class_eval("def #{unsafe_method}!(*params); end # def capitalize!(*params); end")
----

[#references-styledocumentdynamicevaldefinition]
=== References

* https://rubystyle.guide#eval-comment-docs

[#styledocumentation]
== Style/Documentation

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.9
| -
|===

Checks for missing top-level documentation of classes and
modules. Classes with no body are exempt from the check and so are
namespace modules - modules that have nothing in their bodies except
classes, other modules, constant definitions or constant visibility
declarations.

The documentation requirement is annulled if the class or module has
a `#:nodoc:` comment next to it. Likewise, `#:nodoc: all` does the
same for all its children.

[#examples-styledocumentation]
=== Examples

[source,ruby]
----
# bad
class Person
  # ...
end

module Math
end

# good
# Description/Explanation of Person class
class Person
  # ...
end

# allowed
# Class without body
class Person
end

# Namespace - A namespace can be a class or a module
# Containing a class
module Namespace
  # Description/Explanation of Person class
  class Person
    # ...
  end
end

# Containing constant visibility declaration
module Namespace
  class Private
  end

  private_constant :Private
end

# Containing constant definition
module Namespace
  Public = Class.new
end

# Macro calls
module Namespace
  extend Foo
end
----

[#allowedconstants_-__classmethods__-styledocumentation]
==== AllowedConstants: ['ClassMethods']

[source,ruby]
----
# good
module A
  module ClassMethods
    # ...
  end
end
----

[#configurable-attributes-styledocumentation]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedConstants
| `[]`
| Array

| Exclude
| `+spec/**/*+`, `+test/**/*+`
| Array
|===

[#styledocumentationmethod]
== Style/DocumentationMethod

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.43
| -
|===

Checks for missing documentation comment for public methods.
It can optionally be configured to also require documentation for
non-public methods.

NOTE: This cop allows `initialize` method because `initialize` is
a special method called from `new`. In some programming languages
they are called constructor to distinguish it from method.

[#examples-styledocumentationmethod]
=== Examples

[source,ruby]
----
# bad

class Foo
  def bar
    puts baz
  end
end

module Foo
  def bar
    puts baz
  end
end

def foo.bar
  puts baz
end

# good

class Foo
  # Documentation
  def bar
    puts baz
  end
end

module Foo
  # Documentation
  def bar
    puts baz
  end
end

# Documentation
def foo.bar
  puts baz
end
----

[#requirefornonpublicmethods_-false-_default_-styledocumentationmethod]
==== RequireForNonPublicMethods: false (default)

[source,ruby]
----
# good
class Foo
  protected
  def do_something
  end
end

class Foo
  private
  def do_something
  end
end
----

[#requirefornonpublicmethods_-true-styledocumentationmethod]
==== RequireForNonPublicMethods: true

[source,ruby]
----
# bad
class Foo
  protected
  def do_something
  end
end

class Foo
  private
  def do_something
  end
end

# good
class Foo
  protected
  # Documentation
  def do_something
  end
end

class Foo
  private
  # Documentation
  def do_something
  end
end
----

[#allowedmethods_-__method_missing__-_respond_to_missing___-styledocumentationmethod]
==== AllowedMethods: ['method_missing', 'respond_to_missing?']

[source,ruby]
----
# good
class Foo
  def method_missing(name, *args)
  end

  def respond_to_missing?(symbol, include_private)
  end
end
----

[#configurable-attributes-styledocumentationmethod]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedMethods
| `[]`
| Array

| Exclude
| `+spec/**/*+`, `+test/**/*+`
| Array

| RequireForNonPublicMethods
| `false`
| Boolean
|===

[#styledoublecopdisabledirective]
== Style/DoubleCopDisableDirective

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.73
| -
|===

Detects double disable comments on one line. This is mostly to catch
automatically generated comments that need to be regenerated.

[#examples-styledoublecopdisabledirective]
=== Examples

[source,ruby]
----
# bad
def f # rubocop:disable Style/For # rubocop:disable Metrics/AbcSize
end

# good
# rubocop:disable Metrics/AbcSize
def f # rubocop:disable Style/For
end
# rubocop:enable Metrics/AbcSize

# if both fit on one line
def f # rubocop:disable Style/For, Metrics/AbcSize
end
----

[#styledoublenegation]
== Style/DoubleNegation

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.19
| 1.2
|===

Checks for uses of double negation (`!!`) to convert something to a boolean value.

When using `EnforcedStyle: allowed_in_returns`, allow double negation in contexts
that use boolean as a return value. When using `EnforcedStyle: forbidden`, double negation
should be forbidden always.

NOTE: when `something` is a boolean value
`!!something` and `!something.nil?` are not the same thing.
As you're unlikely to write code that can accept values of any type
this is rarely a problem in practice.

[#safety-styledoublenegation]
=== Safety

Autocorrection is unsafe when the value is `false`, because the result
of the expression will change.

[source,ruby]
----
!!false     #=> false
!false.nil? #=> true
----

[#examples-styledoublenegation]
=== Examples

[source,ruby]
----
# bad
!!something

# good
!something.nil?
----

[#enforcedstyle_-allowed_in_returns-_default_-styledoublenegation]
==== EnforcedStyle: allowed_in_returns (default)

[source,ruby]
----
# good
def foo?
  !!return_value
end

define_method :foo? do
  !!return_value
end

define_singleton_method :foo? do
  !!return_value
end
----

[#enforcedstyle_-forbidden-styledoublenegation]
==== EnforcedStyle: forbidden

[source,ruby]
----
# bad
def foo?
  !!return_value
end

define_method :foo? do
  !!return_value
end

define_singleton_method :foo? do
  !!return_value
end
----

[#configurable-attributes-styledoublenegation]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `allowed_in_returns`
| `allowed_in_returns`, `forbidden`
|===

[#references-styledoublenegation]
=== References

* https://rubystyle.guide#no-bang-bang

[#styleeachforsimpleloop]
== Style/EachForSimpleLoop

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.41
| -
|===

Checks for loops which iterate a constant number of times,
using a `Range` literal and `#each`. This can be done more readably using
`Integer#times`.

This check only applies if the block takes no parameters.

[#examples-styleeachforsimpleloop]
=== Examples

[source,ruby]
----
# bad
(1..5).each { }

# good
5.times { }

# bad
(0...10).each {}

# good
10.times {}
----

[#styleeachwithobject]
== Style/EachWithObject

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.22
| 0.42
|===

Looks for inject / reduce calls where the passed in object is
returned at the end and so could be replaced by each_with_object without
the need to return the object at the end.

However, we can't replace with each_with_object if the accumulator
parameter is assigned to within the block.

[#examples-styleeachwithobject]
=== Examples

[source,ruby]
----
# bad
[1, 2].inject({}) { |a, e| a[e] = e; a }

# good
[1, 2].each_with_object({}) { |e, a| a[e] = e }
----

[#styleemptyblockparameter]
== Style/EmptyBlockParameter

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.52
| -
|===

Checks for pipes for empty block parameters. Pipes for empty
block parameters do not cause syntax errors, but they are redundant.

[#examples-styleemptyblockparameter]
=== Examples

[source,ruby]
----
# bad
a do ||
  do_something
end

# bad
a { || do_something }

# good
a do
end

# good
a { do_something }
----

[#styleemptycasecondition]
== Style/EmptyCaseCondition

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.40
| -
|===

Checks for case statements with an empty condition.

[#examples-styleemptycasecondition]
=== Examples

[source,ruby]
----
# bad:
case
when x == 0
  puts 'x is 0'
when y == 0
  puts 'y is 0'
else
  puts 'neither is 0'
end

# good:
if x == 0
  puts 'x is 0'
elsif y == 0
  puts 'y is 0'
else
  puts 'neither is 0'
end

# good: (the case condition node is not empty)
case n
when 0
  puts 'zero'
when 1
  puts 'one'
else
  puts 'more'
end
----

[#styleemptyelse]
== Style/EmptyElse

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Command-line only
| 0.28
| 1.61
|===

Checks for empty else-clauses, possibly including comments and/or an
explicit `nil` depending on the EnforcedStyle.

[#examples-styleemptyelse]
=== Examples

[#enforcedstyle_-both-_default_-styleemptyelse]
==== EnforcedStyle: both (default)

[source,ruby]
----
# warn on empty else and else with nil in it

# bad
if condition
  statement
else
  nil
end

# bad
if condition
  statement
else
end

# good
if condition
  statement
else
  statement
end

# good
if condition
  statement
end
----

[#enforcedstyle_-empty-styleemptyelse]
==== EnforcedStyle: empty

[source,ruby]
----
# warn only on empty else

# bad
if condition
  statement
else
end

# good
if condition
  statement
else
  nil
end

# good
if condition
  statement
else
  statement
end

# good
if condition
  statement
end
----

[#enforcedstyle_-nil-styleemptyelse]
==== EnforcedStyle: nil

[source,ruby]
----
# warn on else with nil in it

# bad
if condition
  statement
else
  nil
end

# good
if condition
  statement
else
end

# good
if condition
  statement
else
  statement
end

# good
if condition
  statement
end
----

[#allowcomments_-false-_default_-styleemptyelse]
==== AllowComments: false (default)

[source,ruby]
----
# bad
if condition
  statement
else
  # something comment
  nil
end

# bad
if condition
  statement
else
  # something comment
end
----

[#allowcomments_-true-styleemptyelse]
==== AllowComments: true

[source,ruby]
----
# good
if condition
  statement
else
  # something comment
  nil
end

# good
if condition
  statement
else
  # something comment
end
----

[#configurable-attributes-styleemptyelse]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `both`
| `empty`, `nil`, `both`

| AllowComments
| `false`
| Boolean
|===

[#styleemptyheredoc]
== Style/EmptyHeredoc

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Command-line only
| 1.32
| 1.61
|===

Checks for using empty heredoc to reduce redundancy.

[#examples-styleemptyheredoc]
=== Examples

[source,ruby]
----
# bad
<<~EOS
EOS

<<-EOS
EOS

<<EOS
EOS

# good
''

# bad
do_something(<<~EOS)
EOS

do_something(<<-EOS)
EOS

do_something(<<EOS)
EOS

# good
do_something('')
----

[#styleemptylambdaparameter]
== Style/EmptyLambdaParameter

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.52
| -
|===

Checks for parentheses for empty lambda parameters. Parentheses
for empty lambda parameters do not cause syntax errors, but they are
redundant.

[#examples-styleemptylambdaparameter]
=== Examples

[source,ruby]
----
# bad
-> () { do_something }

# good
-> { do_something }

# good
-> (arg) { do_something(arg) }
----

[#styleemptyliteral]
== Style/EmptyLiteral

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.12
|===

Checks for the use of a method, the result of which
would be a literal, like an empty array, hash, or string.

NOTE: When frozen string literals are enabled, `String.new`
isn't corrected to an empty string since the former is
mutable and the latter would be frozen.

[#examples-styleemptyliteral]
=== Examples

[source,ruby]
----
# bad
a = Array.new
a = Array[]
h = Hash.new
h = Hash[]
s = String.new

# good
a = []
h = {}
s = ''
----

[#references-styleemptyliteral]
=== References

* https://rubystyle.guide#literal-array-hash

[#styleemptymethod]
== Style/EmptyMethod

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Command-line only
| 0.46
| 1.61
|===

Checks for the formatting of empty method definitions.
By default it enforces empty method definitions to go on a single
line (compact style), but it can be configured to enforce the `end`
to go on its own line (expanded style).

NOTE: A method definition is not considered empty if it contains
comments.

NOTE: Autocorrection will not be applied for the `compact` style
if the resulting code is longer than the `Max` configuration for
`Layout/LineLength`, but an offense will still be registered.

[#examples-styleemptymethod]
=== Examples

[#enforcedstyle_-compact-_default_-styleemptymethod]
==== EnforcedStyle: compact (default)

[source,ruby]
----
# bad
def foo(bar)
end

def self.foo(bar)
end

# good
def foo(bar); end

def foo(bar)
  # baz
end

def self.foo(bar); end
----

[#enforcedstyle_-expanded-styleemptymethod]
==== EnforcedStyle: expanded

[source,ruby]
----
# bad
def foo(bar); end

def self.foo(bar); end

# good
def foo(bar)
end

def self.foo(bar)
end
----

[#configurable-attributes-styleemptymethod]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `compact`
| `compact`, `expanded`
|===

[#references-styleemptymethod]
=== References

* https://rubystyle.guide#no-single-line-methods

[#styleemptystringinsideinterpolation]
== Style/EmptyStringInsideInterpolation

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.76
| -
|===

Checks for empty strings being assigned inside string interpolation.

Empty strings are a meaningless outcome inside of string interpolation, so we remove them.
Alternatively, when configured to do so, we prioritise using empty strings.

While this cop would also apply to variables that are only going to be used as strings,
RuboCop can't detect that, so we only check inside of string interpolation.

[#examples-styleemptystringinsideinterpolation]
=== Examples

[#enforcedstyle_-trailing_conditional-_default_-styleemptystringinsideinterpolation]
==== EnforcedStyle: trailing_conditional (default)

[source,ruby]
----
# bad
"#{condition ? 'foo' : ''}"

# good
"#{'foo' if condition}"

# bad
"#{condition ? '' : 'foo'}"

# good
"#{'foo' unless condition}"
----

[#enforcedstyle_-ternary-styleemptystringinsideinterpolation]
==== EnforcedStyle: ternary

[source,ruby]
----
# bad
"#{'foo' if condition}"

# good
"#{condition ? 'foo' : ''}"

# bad
"#{'foo' unless condition}"

# good
"#{condition ? '' : 'foo'}"
----

[#configurable-attributes-styleemptystringinsideinterpolation]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `trailing_conditional`
| `trailing_conditional`, `ternary`
|===

[#references-styleemptystringinsideinterpolation]
=== References

* https://rubystyle.guide#empty-strings-in-interpolation

[#styleencoding]
== Style/Encoding

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.50
|===

Checks ensures source files have no utf-8 encoding comments.

[#examples-styleencoding]
=== Examples

[source,ruby]
----
# bad
# encoding: UTF-8
# coding: UTF-8
# -*- coding: UTF-8 -*-
----

[#references-styleencoding]
=== References

* https://rubystyle.guide#utf-8

[#styleendblock]
== Style/EndBlock

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.81
|===

Checks for END blocks.

[#examples-styleendblock]
=== Examples

[source,ruby]
----
# bad
END { puts 'Goodbye!' }

# good
at_exit { puts 'Goodbye!' }
----

[#references-styleendblock]
=== References

* https://rubystyle.guide#no-END-blocks

[#styleendlessmethod]
== Style/EndlessMethod

NOTE: Requires Ruby version 3.0

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.8
| -
|===

Checks for endless methods.

It can enforce endless method definitions whenever possible or with single line methods.
It can also disallow multiline endless method definitions or all endless definitions.

`require_single_line` style enforces endless method definitions for single line methods.
`require_always` style enforces endless method definitions for single statement methods.

Other method definition types are not considered by this cop.

The supported styles are:

* allow_single_line (default) - only single line endless method definitions are allowed.
* allow_always - all endless method definitions are allowed.
* disallow - all endless method definitions are disallowed.
* require_single_line - endless method definitions are required for single line methods.
* require_always - all endless method definitions are required.

NOTE: Incorrect endless method definitions will always be
corrected to a multi-line definition.

[#examples-styleendlessmethod]
=== Examples

[#enforcedstyle_-allow_single_line-_default_-styleendlessmethod]
==== EnforcedStyle: allow_single_line (default)

[source,ruby]
----
# bad, multi-line endless method
def my_method = x.foo
                 .bar
                 .baz

# good
def my_method
  x
end

# good
def my_method = x

# good
def my_method
  x.foo
   .bar
   .baz
end
----

[#enforcedstyle_-allow_always-styleendlessmethod]
==== EnforcedStyle: allow_always

[source,ruby]
----
# good
def my_method
  x
end

# good
def my_method = x

# good
def my_method = x.foo
                 .bar
                 .baz

# good
def my_method
  x.foo
   .bar
   .baz
end
----

[#enforcedstyle_-disallow-styleendlessmethod]
==== EnforcedStyle: disallow

[source,ruby]
----
# bad
def my_method = x

# bad
def my_method = x.foo
                 .bar
                 .baz

# good
def my_method
  x
end

# good
def my_method
  x.foo
   .bar
   .baz
end
----

[#enforcedstyle_-require_single_line-styleendlessmethod]
==== EnforcedStyle: require_single_line

[source,ruby]
----
# bad
def my_method
  x
end

# bad
def my_method = x.foo
                 .bar
                 .baz

# good
def my_method = x

# good
def my_method
  x.foo
   .bar
   .baz
end
----

[#enforcedstyle_-require_always-styleendlessmethod]
==== EnforcedStyle: require_always

[source,ruby]
----
# bad
def my_method
  x
end

# bad
def my_method
  x.foo
   .bar
   .baz
end

# good
def my_method = x

# good
def my_method = x.foo
                 .bar
                 .baz
----

[#configurable-attributes-styleendlessmethod]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `allow_single_line`
| `allow_single_line`, `allow_always`, `disallow`, `require_single_line`, `require_always`
|===

[#references-styleendlessmethod]
=== References

* https://rubystyle.guide#endless-methods

[#styleenvhome]
== Style/EnvHome

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.29
| -
|===

Checks for consistent usage of `ENV['HOME']`. If `nil` is used as
the second argument of `ENV.fetch`, it is treated as a bad case like `ENV[]`.

[#safety-styleenvhome]
=== Safety

The cop is unsafe because the result when `nil` is assigned to `ENV['HOME']` changes:

[source,ruby]
----
ENV['HOME'] = nil
ENV['HOME'] # => nil
Dir.home    # => '/home/foo'
----

[#examples-styleenvhome]
=== Examples

[source,ruby]
----
# bad
ENV['HOME']
ENV.fetch('HOME', nil)

# good
Dir.home

# good
ENV.fetch('HOME', default)
----

[#styleevalwithlocation]
== Style/EvalWithLocation

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.52
| -
|===

Ensures that eval methods (`eval`, `instance_eval`, `class_eval`
and `module_eval`) are given filename and line number values (`+__FILE__+`
and `+__LINE__+`). This data is used to ensure that any errors raised
within the evaluated code will be given the correct identification
in a backtrace.

The cop also checks that the line number given relative to `+__LINE__+` is
correct.

This cop will autocorrect incorrect or missing filename and line number
values. However, if `eval` is called without a binding argument, the cop
will not attempt to automatically add a binding, or add filename and
line values.

NOTE: This cop works only when a string literal is given as a code string.
No offense is reported if a string variable is given as below:

[source,ruby]
----
code = <<-RUBY
  def do_something
  end
RUBY
eval code # not checked.
----

[#examples-styleevalwithlocation]
=== Examples

[source,ruby]
----
# bad
eval <<-RUBY
  def do_something
  end
RUBY

# bad
C.class_eval <<-RUBY
  def do_something
  end
RUBY

# good
eval <<-RUBY, binding, __FILE__, __LINE__ + 1
  def do_something
  end
RUBY

# good
C.class_eval <<-RUBY, __FILE__, __LINE__ + 1
  def do_something
  end
RUBY
----

[#styleevenodd]
== Style/EvenOdd

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.12
| 0.29
|===

Checks for places where `Integer#even?` or `Integer#odd?`
can be used.

[#examples-styleevenodd]
=== Examples

[source,ruby]
----
# bad
if x % 2 == 0
end

# good
if x.even?
end
----

[#references-styleevenodd]
=== References

* https://rubystyle.guide#predicate-methods

[#styleexactregexpmatch]
== Style/ExactRegexpMatch

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.51
| -
|===

Checks for exact regexp match inside `Regexp` literals.

[#examples-styleexactregexpmatch]
=== Examples

[source,ruby]
----
# bad
string =~ /\Astring\z/
string === /\Astring\z/
string.match(/\Astring\z/)
string.match?(/\Astring\z/)

# good
string == 'string'

# bad
string !~ /\Astring\z/

# good
string != 'string'
----

[#styleexpandpatharguments]
== Style/ExpandPathArguments

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.53
| -
|===

Checks for use of the `File.expand_path` arguments.
Likewise, it also checks for the `Pathname.new` argument.

Contrastive bad case and good case are alternately shown in
the following examples.

[#examples-styleexpandpatharguments]
=== Examples

[source,ruby]
----
# bad
File.expand_path('..', __FILE__)

# good
File.expand_path(__dir__)

# bad
File.expand_path('../..', __FILE__)

# good
File.expand_path('..', __dir__)

# bad
File.expand_path('.', __FILE__)

# good
File.expand_path(__FILE__)

# bad
Pathname(__FILE__).parent.expand_path

# good
Pathname(__dir__).expand_path

# bad
Pathname.new(__FILE__).parent.expand_path

# good
Pathname.new(__dir__).expand_path
----

[#styleexplicitblockargument]
== Style/ExplicitBlockArgument

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.89
| 1.8
|===

Enforces the use of explicit block argument to avoid writing
block literal that just passes its arguments to another block.

NOTE: This cop only registers an offense if the block args match the
yield args exactly.

[#examples-styleexplicitblockargument]
=== Examples

[source,ruby]
----
# bad
def with_tmp_dir
  Dir.mktmpdir do |tmp_dir|
    Dir.chdir(tmp_dir) { |dir| yield dir } # block just passes arguments
  end
end

# bad
def nine_times
  9.times { yield }
end

# good
def with_tmp_dir(&block)
  Dir.mktmpdir do |tmp_dir|
    Dir.chdir(tmp_dir, &block)
  end
end

with_tmp_dir do |dir|
  puts "dir is accessible as a parameter and pwd is set: #{dir}"
end

# good
def nine_times(&block)
  9.times(&block)
end
----

[#references-styleexplicitblockargument]
=== References

* https://rubystyle.guide#block-argument

[#styleexponentialnotation]
== Style/ExponentialNotation

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.82
| -
|===

Enforces consistency when using exponential notation
for numbers in the code (eg 1.2e4). Different styles are supported:

* `scientific` which enforces a mantissa between 1 (inclusive) and 10 (exclusive).
* `engineering` which enforces the exponent to be a multiple of 3 and the mantissa
  to be between 0.1 (inclusive) and 1000 (exclusive).
* `integral` which enforces the mantissa to always be a whole number without
  trailing zeroes.

[#examples-styleexponentialnotation]
=== Examples

[#enforcedstyle_-scientific-_default_-styleexponentialnotation]
==== EnforcedStyle: scientific (default)

[source,ruby]
----
# Enforces a mantissa between 1 (inclusive) and 10 (exclusive).

# bad
10e6
0.3e4
11.7e5
3.14e0

# good
1e7
3e3
1.17e6
3.14
----

[#enforcedstyle_-engineering-styleexponentialnotation]
==== EnforcedStyle: engineering

[source,ruby]
----
# Enforces using multiple of 3 exponents,
# mantissa should be between 0.1 (inclusive) and 1000 (exclusive)

# bad
3.2e7
0.1e5
12e5
1232e6

# good
32e6
10e3
1.2e6
1.232e9
----

[#enforcedstyle_-integral-styleexponentialnotation]
==== EnforcedStyle: integral

[source,ruby]
----
# Enforces the mantissa to have no decimal part and no
# trailing zeroes.

# bad
3.2e7
0.1e5
120e4

# good
32e6
1e4
12e5
----

[#configurable-attributes-styleexponentialnotation]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `scientific`
| `scientific`, `engineering`, `integral`
|===

[#references-styleexponentialnotation]
=== References

* https://rubystyle.guide#exponential-notation

[#stylefetchenvvar]
== Style/FetchEnvVar

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.28
| -
|===

Suggests `ENV.fetch` for the replacement of `ENV[]`.
`ENV[]` silently fails and returns `nil` when the environment variable is unset,
which may cause unexpected behaviors when the developer forgets to set it.
On the other hand, `ENV.fetch` raises `KeyError` or returns the explicitly
specified default value.

[#examples-stylefetchenvvar]
=== Examples

[#defaulttonil_true_stylefetchenvvar]
==== DefaultToNil: true (default)

[source,ruby]
----
# bad
ENV['X']
x = ENV['X']

# good
ENV.fetch('X', nil)
x = ENV.fetch('X', nil)

# also good
!ENV['X']
ENV['X'].some_method # (e.g. `.nil?`)
----

[#defaulttonil_false_stylefetchenvvar]
==== DefaultToNil: false

[source,ruby]
----
# bad
ENV['X']
x = ENV['X']

# good
ENV.fetch('X')
x = ENV.fetch('X')

# also good
!ENV['X']
ENV['X'].some_method # (e.g. `.nil?`)
----

[#configurable-attributes-stylefetchenvvar]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedVars
| `[]`
| Array

| DefaultToNil 
| `true`
| Boolean
|===

[#references-stylefetchenvvar]
=== References

* https://rubystyle.guide/#hash-fetch-defaults

[#stylefileempty]
== Style/FileEmpty

NOTE: Requires Ruby version 2.4

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.48
| -
|===

Prefer to use `File.empty?('path/to/file')` when checking if a file is empty.

[#safety-stylefileempty]
=== Safety

This cop is unsafe, because `File.size`, `File.read`, and `File.binread`
raise `ENOENT` exception when there is no file corresponding to the path,
while `File.empty?` does not raise an exception.

[#examples-stylefileempty]
=== Examples

[source,ruby]
----
# bad
File.zero?('path/to/file')
File.size('path/to/file') == 0
File.size('path/to/file') >= 0
File.size('path/to/file').zero?
File.read('path/to/file').empty?
File.binread('path/to/file') == ''
FileTest.zero?('path/to/file')

# good
File.empty?('path/to/file')
FileTest.empty?('path/to/file')
----

[#stylefilenull]
== Style/FileNull

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always (Unsafe)
| 1.69
| -
|===

Use `File::NULL` instead of hardcoding the null device (`/dev/null` on Unix-like
OSes, `NUL` or `NUL:` on Windows), so that code is platform independent.
Only looks for full string matches, substrings within a longer string are not
considered.

However, only files that use the string `'/dev/null'` are targeted for detection.
This is because the string `'NUL'` is not limited to the null device.
This behavior results in false negatives when the `'/dev/null'` string is not used,
but it is a trade-off to avoid false positives. `NULL:`
Unlike `'NUL'`, `'NUL:'` is regarded as something like `C:` and is always detected.

NOTE: Uses inside arrays and hashes are ignored.

[#safety-stylefilenull]
=== Safety

It is possible for a string value to be changed if code is being run
on multiple platforms and was previously hardcoded to a specific null device.

For example, the following string will change on Windows when changed to
`File::NULL`:

[source,ruby]
----
path = "/dev/null"
----

[#examples-stylefilenull]
=== Examples

[source,ruby]
----
# bad
'/dev/null'
'NUL'
'NUL:'

# good
File::NULL

# ok - inside an array
null_devices = %w[/dev/null nul]

# ok - inside a hash
{ unix: "/dev/null", windows: "nul" }
----

[#stylefileread]
== Style/FileRead

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.24
| -
|===

Favor `File.(bin)read` convenience methods.

[#examples-stylefileread]
=== Examples

[source,ruby]
----
# bad - text mode
File.open(filename).read
File.open(filename, &:read)
File.open(filename) { |f| f.read }
File.open(filename) do |f|
  f.read
end
File.open(filename, 'r').read
File.open(filename, 'r', &:read)
File.open(filename, 'r') do |f|
  f.read
end

# good
File.read(filename)

# bad - binary mode
File.open(filename, 'rb').read
File.open(filename, 'rb', &:read)
File.open(filename, 'rb') do |f|
  f.read
end

# good
File.binread(filename)
----

[#references-stylefileread]
=== References

* https://rubystyle.guide#file-read

[#stylefiletouch]
== Style/FileTouch

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always (Unsafe)
| 1.69
| -
|===

Checks for usage of `File.open` in append mode with empty block.

Such a usage only creates a new file, but it doesn't update
timestamps for an existing file, which might have been the intention.

For example, for an existing file `foo.txt`:

  ruby -e "puts File.mtime('foo.txt')"
  # 2024-11-26 12:17:23 +0100

  ruby -e "File.open('foo.txt', 'a') {}"

  ruby -e "puts File.mtime('foo.txt')"
  # 2024-11-26 12:17:23 +0100 -> unchanged

If the intention was to update timestamps, `FileUtils.touch('foo.txt')`
should be used instead.

[#safety-stylefiletouch]
=== Safety

Autocorrection is unsafe for this cop because unlike `File.open`,
`FileUtils.touch` updates an existing file's timestamps.

[#examples-stylefiletouch]
=== Examples

[source,ruby]
----
# bad
File.open(filename, 'a') {}
File.open(filename, 'a+') {}

# good
FileUtils.touch(filename)
----

[#stylefilewrite]
== Style/FileWrite

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.24
| -
|===

Favor `File.(bin)write` convenience methods.

NOTE: There are different method signatures between `File.write` (class method)
and `File#write` (instance method). The following case will be allowed because
static analysis does not know the contents of the splat argument:

[source,ruby]
----
File.open(filename, 'w') do |f|
  f.write(*objects)
end
----

[#examples-stylefilewrite]
=== Examples

[source,ruby]
----
# bad - text mode
File.open(filename, 'w').write(content)
File.open(filename, 'w') do |f|
  f.write(content)
end

# good
File.write(filename, content)

# bad - binary mode
File.open(filename, 'wb').write(content)
File.open(filename, 'wb') do |f|
  f.write(content)
end

# good
File.binwrite(filename, content)
----

[#references-stylefilewrite]
=== References

* https://rubystyle.guide#file-write

[#stylefloatdivision]
== Style/FloatDivision

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.72
| 1.9
|===

Checks for division with integers coerced to floats.
It is recommended to either always use `fdiv` or coerce one side only.
This cop also provides other options for code consistency.

[#safety-stylefloatdivision]
=== Safety

This cop is unsafe, because if the operand variable is a string object
then `.to_f` will be removed and an error will occur.

[source,ruby]
----
a = '1.2'
b = '3.4'
a.to_f / b.to_f # Both `to_f` calls are required here
----

[#examples-stylefloatdivision]
=== Examples

[#enforcedstyle_-single_coerce-_default_-stylefloatdivision]
==== EnforcedStyle: single_coerce (default)

[source,ruby]
----
# bad
a.to_f / b.to_f

# good
a.to_f / b
a / b.to_f
----

[#enforcedstyle_-left_coerce-stylefloatdivision]
==== EnforcedStyle: left_coerce

[source,ruby]
----
# bad
a / b.to_f
a.to_f / b.to_f

# good
a.to_f / b
----

[#enforcedstyle_-right_coerce-stylefloatdivision]
==== EnforcedStyle: right_coerce

[source,ruby]
----
# bad
a.to_f / b
a.to_f / b.to_f

# good
a / b.to_f
----

[#enforcedstyle_-fdiv-stylefloatdivision]
==== EnforcedStyle: fdiv

[source,ruby]
----
# bad
a / b.to_f
a.to_f / b
a.to_f / b.to_f

# good
a.fdiv(b)
----

[#configurable-attributes-stylefloatdivision]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `single_coerce`
| `left_coerce`, `right_coerce`, `single_coerce`, `fdiv`
|===

[#references-stylefloatdivision]
=== References

* https://rubystyle.guide#float-division
* https://blog.rubystyle.guide/ruby/2019/06/21/float-division.html

[#stylefor]
== Style/For

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.13
| 1.26
|===

Looks for uses of the `for` keyword or `each` method. The
preferred alternative is set in the EnforcedStyle configuration
parameter. An `each` call with a block on a single line is always
allowed.

[#safety-stylefor]
=== Safety

This cop's autocorrection is unsafe because the scope of
variables is different between `each` and `for`.

[#examples-stylefor]
=== Examples

[#enforcedstyle_-each-_default_-stylefor]
==== EnforcedStyle: each (default)

[source,ruby]
----
# bad
def foo
  for n in [1, 2, 3] do
    puts n
  end
end

# good
def foo
  [1, 2, 3].each do |n|
    puts n
  end
end
----

[#enforcedstyle_-for-stylefor]
==== EnforcedStyle: for

[source,ruby]
----
# bad
def foo
  [1, 2, 3].each do |n|
    puts n
  end
end

# good
def foo
  for n in [1, 2, 3] do
    puts n
  end
end
----

[#configurable-attributes-stylefor]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `each`
| `each`, `for`
|===

[#references-stylefor]
=== References

* https://rubystyle.guide#no-for-loops

[#styleformatstring]
== Style/FormatString

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.19
| 0.49
|===

Enforces the use of a single string formatting utility.
Valid options include `Kernel#format`, `Kernel#sprintf`, and `String#%`.

The detection of `String#%` cannot be implemented in a reliable
manner for all cases, so only two scenarios are considered -
if the first argument is a string literal and if the second
argument is an array literal.

Autocorrection will be applied when using argument is a literal or known built-in conversion
methods such as `to_d`, `to_f`, `to_h`, `to_i`, `to_r`, `to_s`, and `to_sym` on variables,
provided that their return value is not an array. For example, when using `to_s`,
`'%s' % [1, 2, 3].to_s` can be autocorrected without any incompatibility:

[source,ruby]
----
'%s' % [1, 2, 3]        #=> '1'
format('%s', [1, 2, 3]) #=> '[1, 2, 3]'
'%s' % [1, 2, 3].to_s   #=> '[1, 2, 3]'
----

[#examples-styleformatstring]
=== Examples

[#enforcedstyle_-format-_default_-styleformatstring]
==== EnforcedStyle: format (default)

[source,ruby]
----
# bad
puts sprintf('%10s', 'foo')
puts '%10s' % 'foo'

# good
puts format('%10s', 'foo')
----

[#enforcedstyle_-sprintf-styleformatstring]
==== EnforcedStyle: sprintf

[source,ruby]
----
# bad
puts format('%10s', 'foo')
puts '%10s' % 'foo'

# good
puts sprintf('%10s', 'foo')
----

[#enforcedstyle_-percent-styleformatstring]
==== EnforcedStyle: percent

[source,ruby]
----
# bad
puts format('%10s', 'foo')
puts sprintf('%10s', 'foo')

# good
puts '%10s' % 'foo'
----

[#configurable-attributes-styleformatstring]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `format`
| `format`, `sprintf`, `percent`
|===

[#references-styleformatstring]
=== References

* https://rubystyle.guide#sprintf

[#styleformatstringtoken]
== Style/FormatStringToken

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.49
| 1.74
|===

Use a consistent style for tokens within a format string.

By default, all strings are evaluated. In some cases, this may be undesirable,
as they could be used as arguments to a method that does not consider
them to be tokens, but rather other identifiers or just part of the string.

`AllowedMethods` or `AllowedPatterns` can be configured with in order to mark specific
methods as always allowed, thereby avoiding an offense from the cop. By default, there
are no allowed methods.

Additionally, the cop can be made conservative by configuring it with
`Mode: conservative` (default `aggressive`). In this mode, tokens (regardless
of `EnforcedStyle`) are only considered if used in the format string argument to the
methods `printf`, `sprintf`, `format` and `%`.

NOTE: Tokens in the `unannotated` style (eg. `%s`) are always treated as if
configured with `Conservative: true`. This is done in order to prevent false positives,
because this format is very similar to encoded URLs or Date/Time formatting strings.

It is allowed to contain unannotated token
if the number of them is less than or equals to
`MaxUnannotatedPlaceholdersAllowed`.

[#examples-styleformatstringtoken]
=== Examples

[#enforcedstyle_-annotated-_default_-styleformatstringtoken]
==== EnforcedStyle: annotated (default)

[source,ruby]
----
# bad
format('%{greeting}', greeting: 'Hello')
format('%s', 'Hello')

# good
format('%<greeting>s', greeting: 'Hello')
----

[#enforcedstyle_-template-styleformatstringtoken]
==== EnforcedStyle: template

[source,ruby]
----
# bad
format('%<greeting>s', greeting: 'Hello')
format('%s', 'Hello')

# good
format('%{greeting}', greeting: 'Hello')
----

[#enforcedstyle_-unannotated-styleformatstringtoken]
==== EnforcedStyle: unannotated

[source,ruby]
----
# bad
format('%<greeting>s', greeting: 'Hello')
format('%{greeting}', greeting: 'Hello')

# good
format('%s', 'Hello')
----

[#maxunannotatedplaceholdersallowed_-0-styleformatstringtoken]
==== MaxUnannotatedPlaceholdersAllowed: 0

[source,ruby]
----
# bad
format('%06d', 10)
format('%s %s.', 'Hello', 'world')

# good
format('%<number>06d', number: 10)
----

[#maxunannotatedplaceholdersallowed_-1-_default_-styleformatstringtoken]
==== MaxUnannotatedPlaceholdersAllowed: 1 (default)

[source,ruby]
----
# bad
format('%s %s.', 'Hello', 'world')

# good
format('%06d', 10)
----

[#allowedmethods_-__-_default_-styleformatstringtoken]
==== AllowedMethods: [] (default)

[source,ruby]
----
# bad
redirect('foo/%{bar_id}')
----

[#allowedmethods_-_redirect_-styleformatstringtoken]
==== AllowedMethods: [redirect]

[source,ruby]
----
# good
redirect('foo/%{bar_id}')
----

[#allowedpatterns_-__-_default_-styleformatstringtoken]
==== AllowedPatterns: [] (default)

[source,ruby]
----
# bad
redirect('foo/%{bar_id}')
----

[#allowedpatterns_-__redirect__-styleformatstringtoken]
==== AllowedPatterns: ['redirect']

[source,ruby]
----
# good
redirect('foo/%{bar_id}')
----

[#mode_-conservative_-enforcedstyle_-annotated-styleformatstringtoken]
==== Mode: conservative, EnforcedStyle: annotated

[source,ruby]
----
# In `conservative` mode, offenses are only registered for strings
# given to a known formatting method.

# good
"%{greeting}"
foo("%{greeting}")

# bad
format("%{greeting}", greeting: 'Hello')
printf("%{greeting}", greeting: 'Hello')
sprintf("%{greeting}", greeting: 'Hello')
"%{greeting}" % { greeting: 'Hello' }
----

[#configurable-attributes-styleformatstringtoken]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `annotated`
| `annotated`, `template`, `unannotated`

| MaxUnannotatedPlaceholdersAllowed
| `1`
| Integer

| Mode
| `aggressive`
| String

| AllowedMethods
| `[]`
| Array

| AllowedPatterns
| `[]`
| Array
|===

[#stylefrozenstringliteralcomment]
== Style/FrozenStringLiteralComment

NOTE: Requires Ruby version 2.3

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.36
| 0.79
|===

Helps you transition from mutable string literals
to frozen string literals.
It will add the `# frozen_string_literal: true` magic comment to the top
of files to enable frozen string literals. Frozen string literals may be
default in future Ruby. The comment will be added below a shebang and
encoding comment. The frozen string literal comment is only valid in Ruby 2.3+.

Note that the cop will accept files where the comment exists but is set
to `false` instead of `true`.

To require a blank line after this comment, please see
`Layout/EmptyLineAfterMagicComment` cop.

[#safety-stylefrozenstringliteralcomment]
=== Safety

This cop's autocorrection is unsafe since any strings mutations will
change from being accepted to raising `FrozenError`, as all strings
will become frozen by default, and will need to be manually refactored.

[#examples-stylefrozenstringliteralcomment]
=== Examples

[#enforcedstyle_-always-_default_-stylefrozenstringliteralcomment]
==== EnforcedStyle: always (default)

[source,ruby]
----
# The `always` style will always add the frozen string literal comment
# to a file, regardless of the Ruby version or if `freeze` or `<<` are
# called on a string literal.
# bad
module Bar
  # ...
end

# good
# frozen_string_literal: true

module Bar
  # ...
end

# good
# frozen_string_literal: false

module Bar
  # ...
end
----

[#enforcedstyle_-never-stylefrozenstringliteralcomment]
==== EnforcedStyle: never

[source,ruby]
----
# The `never` will enforce that the frozen string literal comment does
# not exist in a file.
# bad
# frozen_string_literal: true

module Baz
  # ...
end

# good
module Baz
  # ...
end
----

[#enforcedstyle_-always_true-stylefrozenstringliteralcomment]
==== EnforcedStyle: always_true

[source,ruby]
----
# The `always_true` style enforces that the frozen string literal
# comment is set to `true`. This is a stricter option than `always`
# and forces projects to use frozen string literals.
# bad
# frozen_string_literal: false

module Baz
  # ...
end

# bad
module Baz
  # ...
end

# good
# frozen_string_literal: true

module Bar
  # ...
end
----

[#configurable-attributes-stylefrozenstringliteralcomment]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `always`
| `always`, `always_true`, `never`

| Exclude
| `+**/*.arb+`
| Array
|===

[#styleglobalstdstream]
== Style/GlobalStdStream

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.89
| -
|===

Enforces the use of `$stdout/$stderr/$stdin` instead of `STDOUT/STDERR/STDIN`.
`STDOUT/STDERR/STDIN` are constants, and while you can actually
reassign (possibly to redirect some stream) constants in Ruby, you'll get
an interpreter warning if you do so.

Additionally, `$stdout/$stderr/$stdin` can safely be accessed in a Ractor because they
are ractor-local, while `STDOUT/STDERR/STDIN` will raise `Ractor::IsolationError`.

[#safety-styleglobalstdstream]
=== Safety

Autocorrection is unsafe because `STDOUT` and `$stdout` may point to different
objects, for example.

[#examples-styleglobalstdstream]
=== Examples

[source,ruby]
----
# bad
STDOUT.puts('hello')

hash = { out: STDOUT, key: value }

def m(out = STDOUT)
  out.puts('hello')
end

# good
$stdout.puts('hello')

hash = { out: $stdout, key: value }

def m(out = $stdout)
  out.puts('hello')
end
----

[#references-styleglobalstdstream]
=== References

* https://rubystyle.guide#global-stdout

[#styleglobalvars]
== Style/GlobalVars

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.13
| -
|===

Looks for uses of global variables.
It does not report offenses for built-in global variables.
Built-in global variables are allowed by default. Additionally
users can allow additional variables via the AllowedVariables option.

Note that backreferences like $1, $2, etc are not global variables.

[#examples-styleglobalvars]
=== Examples

[source,ruby]
----
# bad
$foo = 2
bar = $foo + 5

# good
FOO = 2
foo = 2
$stdin.read
----

[#configurable-attributes-styleglobalvars]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedVariables
| `[]`
| Array
|===

[#references-styleglobalvars]
=== References

* https://rubystyle.guide#instance-vars
* https://www.zenspider.com/ruby/quickref.html

[#styleguardclause]
== Style/GuardClause

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.20
| 1.31
|===

Use a guard clause instead of wrapping the code inside a conditional
expression

A condition with an `elsif` or `else` branch is allowed unless
one of `return`, `break`, `next`, `raise`, or `fail` is used
in the body of the conditional expression.

NOTE: Autocorrect works in most cases except with if-else statements
  that contain logical operators such as `foo || raise('exception')`

[#examples-styleguardclause]
=== Examples

[source,ruby]
----
# bad
def test
  if something
    work
  end
end

# good
def test
  return unless something

  work
end

# also good
def test
  work if something
end

# bad
if something
  raise 'exception'
else
  ok
end

# good
raise 'exception' if something
ok

# bad
if something
  foo || raise('exception')
else
  ok
end

# good
foo || raise('exception') if something
ok

# bad
define_method(:test) do
  if something
    work
  end
end

# good
define_method(:test) do
  return unless something

  work
end

# also good
define_method(:test) do
  work if something
end
----

[#allowconsecutiveconditionals_-false-_default_-styleguardclause]
==== AllowConsecutiveConditionals: false (default)

[source,ruby]
----
# bad
def test
  if foo?
    work
  end

  if bar?  # <- reports an offense
    work
  end
end
----

[#allowconsecutiveconditionals_-true-styleguardclause]
==== AllowConsecutiveConditionals: true

[source,ruby]
----
# good
def test
  if foo?
    work
  end

  if bar?
    work
  end
end

# bad
def test
  if foo?
    work
  end

  do_something

  if bar?  # <- reports an offense
    work
  end
end
----

[#configurable-attributes-styleguardclause]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| MinBodyLength
| `1`
| Integer

| AllowConsecutiveConditionals
| `false`
| Boolean
|===

[#references-styleguardclause]
=== References

* https://rubystyle.guide#no-nested-conditionals

[#stylehashaslastarrayitem]
== Style/HashAsLastArrayItem

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.88
| -
|===

Checks for presence or absence of braces around hash literal as a last
array item depending on configuration.

NOTE: This cop will ignore arrays where all items are hashes, regardless of
EnforcedStyle.

[#examples-stylehashaslastarrayitem]
=== Examples

[#enforcedstyle_-braces-_default_-stylehashaslastarrayitem]
==== EnforcedStyle: braces (default)

[source,ruby]
----
# bad
[1, 2, one: 1, two: 2]

# good
[1, 2, { one: 1, two: 2 }]

# good
[{ one: 1 }, { two: 2 }]
----

[#enforcedstyle_-no_braces-stylehashaslastarrayitem]
==== EnforcedStyle: no_braces

[source,ruby]
----
# bad
[1, 2, { one: 1, two: 2 }]

# good
[1, 2, one: 1, two: 2]

# good
[{ one: 1 }, { two: 2 }]
----

[#configurable-attributes-stylehashaslastarrayitem]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `braces`
| `braces`, `no_braces`
|===

[#references-stylehashaslastarrayitem]
=== References

* https://rubystyle.guide#hash-literal-as-last-array-item

[#stylehashconversion]
== Style/HashConversion

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always (Unsafe)
| 1.10
| 1.55
|===

Checks the usage of pre-2.1 `Hash[args]` method of converting enumerables and
sequences of values to hashes.

Correction code from splat argument (`Hash[*ary]`) is not simply determined. For example,
`Hash[*ary]` can be replaced with `ary.each_slice(2).to_h` but it will be complicated.
So, `AllowSplatArgument` option is true by default to allow splat argument for simple code.

[#safety-stylehashconversion]
=== Safety

This cop's autocorrection is unsafe because `ArgumentError` occurs
if the number of elements is odd:

[source,ruby]
----
Hash[[[1, 2], [3]]] #=> {1=>2, 3=>nil}
[[1, 2], [5]].to_h  #=> wrong array length at 1 (expected 2, was 1) (ArgumentError)
----

[#examples-stylehashconversion]
=== Examples

[source,ruby]
----
# bad
Hash[ary]

# good
ary.to_h

# bad
Hash[key1, value1, key2, value2]

# good
{key1 => value1, key2 => value2}
----

[#allowsplatargument_-true-_default_-stylehashconversion]
==== AllowSplatArgument: true (default)

[source,ruby]
----
# good
Hash[*ary]
----

[#allowsplatargument_-false-stylehashconversion]
==== AllowSplatArgument: false

[source,ruby]
----
# bad
Hash[*ary]
----

[#configurable-attributes-stylehashconversion]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowSplatArgument
| `true`
| Boolean
|===

[#references-stylehashconversion]
=== References

* https://rubystyle.guide#avoid-hash-constructor

[#stylehasheachmethods]
== Style/HashEachMethods

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.80
| 1.16
|===

Checks for uses of `each_key` and `each_value` `Hash` methods.

NOTE: If you have an array of two-element arrays, you can put
  parentheses around the block arguments to indicate that you're not
  working with a hash, and suppress RuboCop offenses.

[#safety-stylehasheachmethods]
=== Safety

This cop is unsafe because it cannot be guaranteed that the receiver
is a `Hash`. The `AllowedReceivers` configuration can mitigate,
but not fully resolve, this safety issue.

[#examples-stylehasheachmethods]
=== Examples

[source,ruby]
----
# bad
hash.keys.each { |k| p k }
hash.each { |k, unused_value| p k }

# good
hash.each_key { |k| p k }

# bad
hash.values.each { |v| p v }
hash.each { |unused_key, v| p v }

# good
hash.each_value { |v| p v }
----

[#allowedreceivers_-__execute__-stylehasheachmethods]
==== AllowedReceivers: ['execute']

[source,ruby]
----
# good
execute(sql).keys.each { |v| p v }
execute(sql).values.each { |v| p v }
----

[#configurable-attributes-stylehasheachmethods]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedReceivers
| `Thread.current`
| Array
|===

[#references-stylehasheachmethods]
=== References

* https://rubystyle.guide#hash-each

[#stylehashexcept]
== Style/HashExcept

NOTE: Requires Ruby version 3.0

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.7
| 1.39
|===

Checks for usages of `Hash#reject`, `Hash#select`, and `Hash#filter` methods
that can be replaced with `Hash#except` method.

This cop should only be enabled on Ruby version 3.0 or higher.
(`Hash#except` was added in Ruby 3.0.)

For safe detection, it is limited to commonly used string and symbol comparisons
when using `==` or `!=`.

This cop doesn't check for `Hash#delete_if` and `Hash#keep_if` because they
modify the receiver.

[#safety-stylehashexcept]
=== Safety

This cop is unsafe because it cannot be guaranteed that the receiver
is a `Hash` or responds to the replacement method.

[#examples-stylehashexcept]
=== Examples

[source,ruby]
----
# bad
{foo: 1, bar: 2, baz: 3}.reject {|k, v| k == :bar }
{foo: 1, bar: 2, baz: 3}.select {|k, v| k != :bar }
{foo: 1, bar: 2, baz: 3}.filter {|k, v| k != :bar }
{foo: 1, bar: 2, baz: 3}.reject {|k, v| k.eql?(:bar) }

# bad
{foo: 1, bar: 2, baz: 3}.reject {|k, v| %i[bar].include?(k) }
{foo: 1, bar: 2, baz: 3}.select {|k, v| !%i[bar].include?(k) }
{foo: 1, bar: 2, baz: 3}.filter {|k, v| !%i[bar].include?(k) }

# good
{foo: 1, bar: 2, baz: 3}.except(:bar)
----

[#allcops_activesupportextensionsenabled_-false-_default_-stylehashexcept]
==== AllCops:ActiveSupportExtensionsEnabled: false (default)

[source,ruby]
----
# good
{foo: 1, bar: 2, baz: 3}.reject {|k, v| !%i[bar].exclude?(k) }
{foo: 1, bar: 2, baz: 3}.select {|k, v| %i[bar].exclude?(k) }

# good
{foo: 1, bar: 2, baz: 3}.reject {|k, v| k.in?(%i[bar]) }
{foo: 1, bar: 2, baz: 3}.select {|k, v| !k.in?(%i[bar]) }
----

[#allcops_activesupportextensionsenabled_-true-stylehashexcept]
==== AllCops:ActiveSupportExtensionsEnabled: true

[source,ruby]
----
# bad
{foo: 1, bar: 2, baz: 3}.reject {|k, v| !%i[bar].exclude?(k) }
{foo: 1, bar: 2, baz: 3}.select {|k, v| %i[bar].exclude?(k) }

# bad
{foo: 1, bar: 2, baz: 3}.reject {|k, v| k.in?(%i[bar]) }
{foo: 1, bar: 2, baz: 3}.select {|k, v| !k.in?(%i[bar]) }

# good
{foo: 1, bar: 2, baz: 3}.except(:bar)
----

[#stylehashfetchchain]
== Style/HashFetchChain

NOTE: Requires Ruby version 2.3

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.75
| -
|===

Use `Hash#dig` instead of chaining potentially null `fetch` calls.

When `fetch(identifier, nil)` calls are chained on a hash, the expectation
is that each step in the chain returns either `nil` or another hash,
and in both cases, these can be simplified with a single call to `dig` with
multiple arguments.

If the 2nd parameter is `{}` or `Hash.new`, an offense will also be registered,
as long as the final call in the chain is a nil value. If a non-nil value is given,
the chain will not be registered as an offense, as the default value cannot be safely
given with `dig`.

NOTE: See `Style/DigChain` for replacing chains of `dig` calls with
a single method call.

[#safety-stylehashfetchchain]
=== Safety

This cop is unsafe because it cannot be guaranteed that the receiver
is a `Hash` or that `fetch` or `dig` have the expected standard implementation.

[#examples-stylehashfetchchain]
=== Examples

[source,ruby]
----
# bad
hash.fetch('foo', nil)&.fetch('bar', nil)

# bad
# earlier members of the chain can return `{}` as long as the final `fetch`
# has `nil` as a default value
hash.fetch('foo', {}).fetch('bar', nil)

# good
hash.dig('foo', 'bar')

# ok - not handled by the cop since the final `fetch` value is non-nil
hash.fetch('foo', {}).fetch('bar', {})
----

[#stylehashlikecase]
== Style/HashLikeCase

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.88
| -
|===

Checks for places where `case-when` represents a simple 1:1
mapping and can be replaced with a hash lookup.

[#examples-stylehashlikecase]
=== Examples

[#minbranchescount_-3-_default_-stylehashlikecase]
==== MinBranchesCount: 3 (default)

[source,ruby]
----
# bad
case country
when 'europe'
  'http://eu.example.com'
when 'america'
  'http://us.example.com'
when 'australia'
  'http://au.example.com'
end

# good
SITES = {
  'europe'    => 'http://eu.example.com',
  'america'   => 'http://us.example.com',
  'australia' => 'http://au.example.com'
}
SITES[country]
----

[#minbranchescount_-4-stylehashlikecase]
==== MinBranchesCount: 4

[source,ruby]
----
# good
case country
when 'europe'
  'http://eu.example.com'
when 'america'
  'http://us.example.com'
when 'australia'
  'http://au.example.com'
end
----

[#configurable-attributes-stylehashlikecase]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| MinBranchesCount
| `3`
| Integer
|===

[#stylehashslice]
== Style/HashSlice

NOTE: Requires Ruby version 2.5

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.71
| -
|===

Checks for usages of `Hash#reject`, `Hash#select`, and `Hash#filter` methods
that can be replaced with `Hash#slice` method.

This cop should only be enabled on Ruby version 2.5 or higher.
(`Hash#slice` was added in Ruby 2.5.)

For safe detection, it is limited to commonly used string and symbol comparisons
when using `==` or `!=`.

This cop doesn't check for `Hash#delete_if` and `Hash#keep_if` because they
modify the receiver.

[#safety-stylehashslice]
=== Safety

This cop is unsafe because it cannot be guaranteed that the receiver
is a `Hash` or responds to the replacement method.

[#examples-stylehashslice]
=== Examples

[source,ruby]
----
# bad
{foo: 1, bar: 2, baz: 3}.select {|k, v| k == :bar }
{foo: 1, bar: 2, baz: 3}.reject {|k, v| k != :bar }
{foo: 1, bar: 2, baz: 3}.filter {|k, v| k == :bar }
{foo: 1, bar: 2, baz: 3}.select {|k, v| k.eql?(:bar) }

# bad
{foo: 1, bar: 2, baz: 3}.select {|k, v| %i[bar].include?(k) }
{foo: 1, bar: 2, baz: 3}.reject {|k, v| !%i[bar].include?(k) }
{foo: 1, bar: 2, baz: 3}.filter {|k, v| %i[bar].include?(k) }

# good
{foo: 1, bar: 2, baz: 3}.slice(:bar)
----

[#allcops_activesupportextensionsenabled_-false-_default_-stylehashslice]
==== AllCops:ActiveSupportExtensionsEnabled: false (default)

[source,ruby]
----
# good
{foo: 1, bar: 2, baz: 3}.select {|k, v| !%i[bar].exclude?(k) }
{foo: 1, bar: 2, baz: 3}.reject {|k, v| %i[bar].exclude?(k) }

# good
{foo: 1, bar: 2, baz: 3}.select {|k, v| k.in?(%i[bar]) }
{foo: 1, bar: 2, baz: 3}.reject {|k, v| !k.in?(%i[bar]) }
----

[#allcops_activesupportextensionsenabled_-true-stylehashslice]
==== AllCops:ActiveSupportExtensionsEnabled: true

[source,ruby]
----
# bad
{foo: 1, bar: 2, baz: 3}.select {|k, v| !%i[bar].exclude?(k) }
{foo: 1, bar: 2, baz: 3}.reject {|k, v| %i[bar].exclude?(k) }

# bad
{foo: 1, bar: 2, baz: 3}.select {|k, v| k.in?(%i[bar]) }
{foo: 1, bar: 2, baz: 3}.reject {|k, v| !k.in?(%i[bar]) }

# good
{foo: 1, bar: 2, baz: 3}.slice(:bar)
----

[#stylehashsyntax]
== Style/HashSyntax

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 1.67
|===

Checks hash literal syntax.

It can enforce either the use of the class hash rocket syntax or
the use of the newer Ruby 1.9 syntax (when applicable).

A separate offense is registered for each problematic pair.

The supported styles are:

* ruby19 - forces use of the 1.9 syntax (e.g. `{a: 1}`) when hashes have
all symbols for keys
* hash_rockets - forces use of hash rockets for all hashes
* no_mixed_keys - simply checks for hashes with mixed syntaxes
* ruby19_no_mixed_keys - forces use of ruby 1.9 syntax and forbids mixed
syntax hashes

This cop has `EnforcedShorthandSyntax` option.
It can enforce either the use of the explicit hash value syntax or
the use of Ruby 3.1's hash value shorthand syntax.

The supported styles are:

* always - forces use of the 3.1 syntax (e.g. {foo:})
* never - forces use of explicit hash literal value
* either - accepts both shorthand and explicit use of hash literal value
* consistent - forces use of the 3.1 syntax only if all values can be omitted in the hash
* either_consistent - accepts both shorthand and explicit use of hash literal value,
                      but they must be consistent

[#examples-stylehashsyntax]
=== Examples

[#enforcedstyle_-ruby19-_default_-stylehashsyntax]
==== EnforcedStyle: ruby19 (default)

[source,ruby]
----
# bad
{:a => 2}
{b: 1, :c => 2}

# good
{a: 2, b: 1}
{:c => 2, 'd' => 2} # acceptable since 'd' isn't a symbol
{d: 1, 'e' => 2} # technically not forbidden
----

[#enforcedstyle_-hash_rockets-stylehashsyntax]
==== EnforcedStyle: hash_rockets

[source,ruby]
----
# bad
{a: 1, b: 2}
{c: 1, 'd' => 5}

# good
{:a => 1, :b => 2}
----

[#enforcedstyle_-no_mixed_keys-stylehashsyntax]
==== EnforcedStyle: no_mixed_keys

[source,ruby]
----
# bad
{:a => 1, b: 2}
{c: 1, 'd' => 2}

# good
{:a => 1, :b => 2}
{c: 1, d: 2}
----

[#enforcedstyle_-ruby19_no_mixed_keys-stylehashsyntax]
==== EnforcedStyle: ruby19_no_mixed_keys

[source,ruby]
----
# bad
{:a => 1, :b => 2}
{c: 2, 'd' => 3} # should just use hash rockets

# good
{a: 1, b: 2}
{:c => 3, 'd' => 4}
----

[#enforcedshorthandsyntax_-always-stylehashsyntax]
==== EnforcedShorthandSyntax: always

[source,ruby]
----
# bad
{foo: foo, bar: bar}

# good
{foo:, bar:}

# good - allowed to mix syntaxes
{foo:, bar: baz}
----

[#enforcedshorthandsyntax_-never-stylehashsyntax]
==== EnforcedShorthandSyntax: never

[source,ruby]
----
# bad
{foo:, bar:}

# good
{foo: foo, bar: bar}
----

[#enforcedshorthandsyntax_-either-_default_-stylehashsyntax]
==== EnforcedShorthandSyntax: either (default)

[source,ruby]
----
# good
{foo: foo, bar: bar}

# good
{foo: foo, bar:}

# good
{foo:, bar:}
----

[#enforcedshorthandsyntax_-consistent-stylehashsyntax]
==== EnforcedShorthandSyntax: consistent

[source,ruby]
----
# bad - `foo` and `bar` values can be omitted
{foo: foo, bar: bar}

# bad - `bar` value can be omitted
{foo:, bar: bar}

# bad - mixed syntaxes
{foo:, bar: baz}

# good
{foo:, bar:}

# good - can't omit `baz`
{foo: foo, bar: baz}
----

[#enforcedshorthandsyntax_-either_consistent-stylehashsyntax]
==== EnforcedShorthandSyntax: either_consistent

[source,ruby]
----
# good - `foo` and `bar` values can be omitted, but they are consistent, so it's accepted
{foo: foo, bar: bar}

# bad - `bar` value can be omitted
{foo:, bar: bar}

# bad - mixed syntaxes
{foo:, bar: baz}

# good
{foo:, bar:}

# good - can't omit `baz`
{foo: foo, bar: baz}
----

[#configurable-attributes-stylehashsyntax]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `ruby19`
| `ruby19`, `hash_rockets`, `no_mixed_keys`, `ruby19_no_mixed_keys`

| EnforcedShorthandSyntax
| `either`
| `always`, `never`, `either`, `consistent`, `either_consistent`

| UseHashRocketsWithSymbolValues
| `false`
| Boolean

| PreferHashRocketsForNonAlnumEndingSymbols
| `false`
| Boolean
|===

[#references-stylehashsyntax]
=== References

* https://rubystyle.guide#hash-literals

[#stylehashtransformkeys]
== Style/HashTransformKeys

NOTE: Requires Ruby version 2.5

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.80
| 0.90
|===

Looks for uses of `+_.each_with_object({}) {...}+`,
`+_.map {...}.to_h+`, and `+Hash[_.map {...}]+` that are actually just
transforming the keys of a hash, and tries to use a simpler & faster
call to `transform_keys` instead.
It should only be enabled on Ruby version 2.5 or newer.
(`transform_keys` was added in Ruby 2.5.)

[#safety-stylehashtransformkeys]
=== Safety

This cop is unsafe, as it can produce false positives if we are
transforming an enumerable of key-value-like pairs that isn't actually
a hash, e.g.: `[[k1, v1], [k2, v2], ...]`

[#examples-stylehashtransformkeys]
=== Examples

[source,ruby]
----
# bad
{a: 1, b: 2}.each_with_object({}) { |(k, v), h| h[foo(k)] = v }
Hash[{a: 1, b: 2}.collect { |k, v| [foo(k), v] }]
{a: 1, b: 2}.map { |k, v| [k.to_s, v] }.to_h
{a: 1, b: 2}.to_h { |k, v| [k.to_s, v] }

# good
{a: 1, b: 2}.transform_keys { |k| foo(k) }
{a: 1, b: 2}.transform_keys { |k| k.to_s }
----

[#stylehashtransformvalues]
== Style/HashTransformValues

NOTE: Requires Ruby version 2.4

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.80
| 0.90
|===

Looks for uses of `+_.each_with_object({}) {...}+`,
`+_.map {...}.to_h+`, and `+Hash[_.map {...}]+` that are actually just
transforming the values of a hash, and tries to use a simpler & faster
call to `transform_values` instead.

[#safety-stylehashtransformvalues]
=== Safety

This cop is unsafe, as it can produce false positives if we are
transforming an enumerable of key-value-like pairs that isn't actually
a hash, e.g.: `[[k1, v1], [k2, v2], ...]`

[#examples-stylehashtransformvalues]
=== Examples

[source,ruby]
----
# bad
{a: 1, b: 2}.each_with_object({}) { |(k, v), h| h[k] = foo(v) }
Hash[{a: 1, b: 2}.collect { |k, v| [k, foo(v)] }]
{a: 1, b: 2}.map { |k, v| [k, v * v] }.to_h
{a: 1, b: 2}.to_h { |k, v| [k, v * v] }

# good
{a: 1, b: 2}.transform_values { |v| foo(v) }
{a: 1, b: 2}.transform_values { |v| v * v }
----

[#styleidenticalconditionalbranches]
== Style/IdenticalConditionalBranches

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.36
| 1.19
|===

Checks for identical expressions at the beginning or end of
each branch of a conditional expression. Such expressions should normally
be placed outside the conditional expression - before or after it.

NOTE: The cop is poorly named and some people might think that it actually
checks for duplicated conditional branches. The name will probably be changed
in a future major RuboCop release.

[#safety-styleidenticalconditionalbranches]
=== Safety

Autocorrection is unsafe because changing the order of method invocations
may change the behavior of the code. For example:

[source,ruby]
----
if method_that_modifies_global_state # 1
  method_that_relies_on_global_state # 2
  foo                                # 3
else
  method_that_relies_on_global_state # 2
  bar                                # 3
end
----

In this example, `method_that_relies_on_global_state` will be moved before
`method_that_modifies_global_state`, which changes the behavior of the program.

[#examples-styleidenticalconditionalbranches]
=== Examples

[source,ruby]
----
# bad
if condition
  do_x
  do_z
else
  do_y
  do_z
end

# good
if condition
  do_x
else
  do_y
end
do_z

# bad
if condition
  do_z
  do_x
else
  do_z
  do_y
end

# good
do_z
if condition
  do_x
else
  do_y
end

# bad
case foo
when 1
  do_x
when 2
  do_x
else
  do_x
end

# good
case foo
when 1
  do_x
  do_y
when 2
  # nothing
else
  do_x
  do_z
end

# bad
case foo
in 1
  do_x
in 2
  do_x
else
  do_x
end

# good
case foo
in 1
  do_x
  do_y
in 2
  # nothing
else
  do_x
  do_z
end
----

[#styleifinsideelse]
== Style/IfInsideElse

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.36
| 1.3
|===

If the `else` branch of a conditional consists solely of an `if` node,
it can be combined with the `else` to become an `elsif`.
This helps to keep the nesting level from getting too deep.

[#examples-styleifinsideelse]
=== Examples

[source,ruby]
----
# bad
if condition_a
  action_a
else
  if condition_b
    action_b
  else
    action_c
  end
end

# good
if condition_a
  action_a
elsif condition_b
  action_b
else
  action_c
end
----

[#allowifmodifier_-false-_default_-styleifinsideelse]
==== AllowIfModifier: false (default)

[source,ruby]
----
# bad
if condition_a
  action_a
else
  action_b if condition_b
end

# good
if condition_a
  action_a
elsif condition_b
  action_b
end
----

[#allowifmodifier_-true-styleifinsideelse]
==== AllowIfModifier: true

[source,ruby]
----
# good
if condition_a
  action_a
else
  action_b if condition_b
end

# good
if condition_a
  action_a
elsif condition_b
  action_b
end
----

[#configurable-attributes-styleifinsideelse]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowIfModifier
| `false`
| Boolean
|===

[#styleifunlessmodifier]
== Style/IfUnlessModifier

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.30
|===

Checks for `if` and `unless` statements that would fit on one line if
written as modifier `if`/`unless`. The cop also checks for modifier
`if`/`unless` lines that exceed the maximum line length.

The maximum line length is configured in the `Layout/LineLength`
cop. The tab size is configured in the `IndentationWidth` of the
`Layout/IndentationStyle` cop.

One-line pattern matching is always allowed. To ensure that there are few cases
where the match variable is not used, and to prevent oversights. The variable `x`
becomes undefined and raises `NameError` when the following example is changed to
the modifier form:

[source,ruby]
----
if [42] in [x]
  x # `x` is undefined when using modifier form.
end
----

The code `def method_name = body if condition` is considered a bad case by
`Style/AmbiguousEndlessMethodDefinition` cop. So, to respect the user's intention to use
an endless method definition in the `if` body, the following code is allowed:

[source,ruby]
----
if condition
  def method_name = body
end
----

NOTE: It is allowed when `defined?` argument has an undefined value,
because using the modifier form causes the following incompatibility:

[source,ruby]
----
unless defined?(undefined_foo)
  undefined_foo = 'default_value'
end
undefined_foo # => 'default_value'

undefined_bar = 'default_value' unless defined?(undefined_bar)
undefined_bar # => nil
----

[#examples-styleifunlessmodifier]
=== Examples

[source,ruby]
----
# bad
if condition
  do_stuff(bar)
end

unless qux.empty?
  Foo.do_something
end

do_something_with_a_long_name(arg) if long_condition_that_prevents_code_fit_on_single_line

# good
do_stuff(bar) if condition
Foo.do_something unless qux.empty?

if long_condition_that_prevents_code_fit_on_single_line
  do_something_with_a_long_name(arg)
end

if short_condition # a long comment that makes it too long if it were just a single line
  do_something
end
----

[#references-styleifunlessmodifier]
=== References

* https://rubystyle.guide#if-as-a-modifier

[#styleifunlessmodifierofifunless]
== Style/IfUnlessModifierOfIfUnless

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.39
| 0.87
|===

Checks for if and unless statements used as modifiers of other if or
unless statements.

[#examples-styleifunlessmodifierofifunless]
=== Examples

[source,ruby]
----
# bad
tired? ? 'stop' : 'go faster' if running?

# bad
if tired?
  "please stop"
else
  "keep going"
end if running?

# good
if running?
  tired? ? 'stop' : 'go faster'
end
----

[#styleifwithbooleanliteralbranches]
== Style/IfWithBooleanLiteralBranches

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always (Unsafe)
| 1.9
| -
|===

Checks for redundant `if` with boolean literal branches.
It checks only conditions to return boolean value (`true` or `false`) for safe detection.
The conditions to be checked are comparison methods, predicate methods, and
double negation (!!).
`nonzero?` method is allowed by default.
These are customizable with `AllowedMethods` option.

This cop targets only ``if``s with a single `elsif` or `else` branch. The following
code will be allowed, because it has two `elsif` branches:

[source,ruby]
----
if foo
  true
elsif bar > baz
  true
elsif qux > quux # Single `elsif` is warned, but two or more `elsif`s are not.
  true
else
  false
end
----

[#safety-styleifwithbooleanliteralbranches]
=== Safety

Autocorrection is unsafe because there is no guarantee that all predicate methods
will return a boolean value. Those methods can be allowed with `AllowedMethods` config.

[#examples-styleifwithbooleanliteralbranches]
=== Examples

[source,ruby]
----
# bad
if foo == bar
  true
else
  false
end

# bad
foo == bar ? true : false

# good
foo == bar

# bad
if foo.do_something?
  true
else
  false
end

# good (but potentially an unsafe correction)
foo.do_something?
----

[#allowedmethods_-__nonzero___-_default_-styleifwithbooleanliteralbranches]
==== AllowedMethods: ['nonzero?'] (default)

[source,ruby]
----
# good
num.nonzero? ? true : false
----

[#configurable-attributes-styleifwithbooleanliteralbranches]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedMethods
| `nonzero?`
| Array
|===

[#styleifwithsemicolon]
== Style/IfWithSemicolon

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.83
|===

Checks for uses of semicolon in if statements.

[#examples-styleifwithsemicolon]
=== Examples

[source,ruby]
----
# bad
result = if some_condition; something else another_thing end

# good
result = some_condition ? something : another_thing
----

[#references-styleifwithsemicolon]
=== References

* https://rubystyle.guide#no-semicolon-ifs

[#styleimplicitruntimeerror]
== Style/ImplicitRuntimeError

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.41
| -
|===

Checks for `raise` or `fail` statements which do not specify an
explicit exception class. (This raises a `RuntimeError`. Some projects
might prefer to use exception classes which more precisely identify the
nature of the error.)

[#examples-styleimplicitruntimeerror]
=== Examples

[source,ruby]
----
# bad
raise 'Error message here'

# good
raise ArgumentError, 'Error message here'
----

[#styleinpatternthen]
== Style/InPatternThen

NOTE: Requires Ruby version 2.7

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.16
| -
|===

Checks for `in;` uses in `case` expressions.

[#examples-styleinpatternthen]
=== Examples

[source,ruby]
----
# bad
case expression
in pattern_a; foo
in pattern_b; bar
end

# good
case expression
in pattern_a then foo
in pattern_b then bar
end
----

[#references-styleinpatternthen]
=== References

* https://rubystyle.guide#no-in-pattern-semicolons

[#styleinfiniteloop]
== Style/InfiniteLoop

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.26
| 0.61
|===

Use `Kernel#loop` for infinite loops.

[#safety-styleinfiniteloop]
=== Safety

This cop is unsafe as the rule should not necessarily apply if the loop
body might raise a `StopIteration` exception; contrary to other infinite
loops, `Kernel#loop` silently rescues that and returns `nil`.

[#examples-styleinfiniteloop]
=== Examples

[source,ruby]
----
# bad
while true
  work
end

# good
loop do
  work
end
----

[#references-styleinfiniteloop]
=== References

* https://rubystyle.guide#infinite-loop

[#styleinlinecomment]
== Style/InlineComment

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.23
| -
|===

Checks for trailing inline comments.

[#examples-styleinlinecomment]
=== Examples

[source,ruby]
----
# good
foo.each do |f|
  # Standalone comment
  f.bar
end

# bad
foo.each do |f|
  f.bar # Trailing inline comment
end
----

[#styleinversemethods]
== Style/InverseMethods

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.48
| -
|===

Check for usages of not (`not` or `!`) called on a method
when an inverse of that method can be used instead.

Methods that can be inverted by a not (`not` or `!`) should be defined
in `InverseMethods`.

Methods that are inverted by inverting the return
of the block that is passed to the method should be defined in
`InverseBlocks`.

[#safety-styleinversemethods]
=== Safety

This cop is unsafe because it cannot be guaranteed that the method
and its inverse method are both defined on receiver, and also are
actually inverse of each other.

[#examples-styleinversemethods]
=== Examples

[source,ruby]
----
# bad
!foo.none?
!foo.any? { |f| f.even? }
!foo.blank?
!(foo == bar)
foo.select { |f| !f.even? }
foo.reject { |f| f != 7 }

# good
foo.none?
foo.blank?
foo.any? { |f| f.even? }
foo != bar
foo == bar
!!('foo' =~ /^\w+$/)
!(foo.class < Numeric) # Checking class hierarchy is allowed
# Blocks with guard clauses are ignored:
foo.select do |f|
  next if f.zero?
  f != 1
end
----

[#configurable-attributes-styleinversemethods]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| InverseMethods
| `{any?: :none?, even?: :odd?, "==": :!=, "=~": :!~, "<": :>=, ">": :<=}`
| 

| InverseBlocks
| `{select: :reject, select!: :reject!}`
| 
|===

[#styleinvertibleunlesscondition]
== Style/InvertibleUnlessCondition

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| No
| Always (Unsafe)
| 1.44
| 1.50
|===

Checks for usages of `unless` which can be replaced by `if` with inverted condition.
Code without `unless` is easier to read, but that is subjective, so this cop
is disabled by default.

Methods that can be inverted should be defined in `InverseMethods`. Note that
the relationship of inverse methods needs to be defined in both directions.
For example,

[source,yaml]
----
InverseMethods:
  :!=: :==
  :even?: :odd?
  :odd?: :even?
----

will suggest both `even?` and `odd?` to be inverted, but only `!=` (and not `==`).

[#safety-styleinvertibleunlesscondition]
=== Safety

This cop is unsafe because it cannot be guaranteed that the method
and its inverse method are both defined on receiver, and also are
actually inverse of each other.

[#examples-styleinvertibleunlesscondition]
=== Examples

[source,ruby]
----
# bad (simple condition)
foo unless !bar
foo unless x != y
foo unless x >= 10
foo unless x.even?
foo unless odd?

# good
foo if bar
foo if x == y
foo if x < 10
foo if x.odd?
foo if even?

# bad (complex condition)
foo unless x != y || x.even?

# good
foo if x == y && x.odd?

# good (if)
foo if !condition
----

[#configurable-attributes-styleinvertibleunlesscondition]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| InverseMethods
| `{"!=": :==, ">": :<=, "<=": :>, "<": :>=, ">=": :<, "!~": :=~, zero?: :nonzero?, nonzero?: :zero?, any?: :none?, none?: :any?, even?: :odd?, odd?: :even?}`
| 
|===

[#styleipaddresses]
== Style/IpAddresses

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.58
| 0.91
|===

Checks for hardcoded IP addresses, which can make code
brittle. IP addresses are likely to need to be changed when code
is deployed to a different server or environment, which may break
a deployment if forgotten. Prefer setting IP addresses in ENV or
other configuration.

[#examples-styleipaddresses]
=== Examples

[source,ruby]
----
# bad
ip_address = '127.59.241.29'

# good
ip_address = ENV['DEPLOYMENT_IP_ADDRESS']
----

[#configurable-attributes-styleipaddresses]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedAddresses
| `::`
| Array

| Exclude
| `+**/*.gemfile+`, `+**/Gemfile+`, `+**/gems.rb+`, `+**/*.gemspec+`
| Array
|===

[#styleitassignment]
== Style/ItAssignment

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| No
| 1.70
| -
|===

Checks for assignments to a local `it` variable inside a block
where `it` can refer to the first anonymous parameter as of Ruby 3.4.

Although Ruby allows reassigning `it` in these cases, it could
cause confusion if `it` is used as a block parameter elsewhere.
For consistency, this also applies to numblocks and blocks with
parameters, even though `it` cannot be used in those cases.

[#examples-styleitassignment]
=== Examples

[source,ruby]
----
# bad
foo { it = 5 }
foo { |bar| it = bar }
foo { it = _2 }

# good - use a different variable name
foo { var = 5 }
foo { |bar| var = bar }
foo { bar = _2 }
----

[#styleitblockparameter]
== Style/ItBlockParameter

NOTE: Requires Ruby version 3.4

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.75
| 1.76
|===

Checks for blocks with one argument where `it` block parameter can be used.

It provides four `EnforcedStyle` options:

1. `allow_single_line` (default) ... Always uses the `it` block parameter in a single line.
2. `only_numbered_parameters` ... Detects only numbered block parameters.
3. `always` ... Always uses the `it` block parameter.
4. `disallow` ... Disallows the `it` block parameter.

A single numbered parameter is detected when `allow_single_line`,
`only_numbered_parameters`, or `always`.

[#examples-styleitblockparameter]
=== Examples

[#enforcedstyle_-allow_single_line-_default_-styleitblockparameter]
==== EnforcedStyle: allow_single_line (default)

[source,ruby]
----
# bad
block do
  do_something(it)
end
block { do_something(_1) }

# good
block { do_something(it) }
block { |named_param| do_something(named_param) }
----

[#enforcedstyle_-only_numbered_parameters-styleitblockparameter]
==== EnforcedStyle: only_numbered_parameters

[source,ruby]
----
# bad
block { do_something(_1) }

# good
block { do_something(it) }
block { |named_param| do_something(named_param) }
----

[#enforcedstyle_-always-styleitblockparameter]
==== EnforcedStyle: always

[source,ruby]
----
# bad
block { do_something(_1) }
block { |named_param| do_something(named_param) }

# good
block { do_something(it) }
----

[#enforcedstyle_-disallow-styleitblockparameter]
==== EnforcedStyle: disallow

[source,ruby]
----
# bad
block { do_something(it) }

# good
block { do_something(_1) }
block { |named_param| do_something(named_param) }
----

[#configurable-attributes-styleitblockparameter]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `allow_single_line`
| `allow_single_line`, `only_numbered_parameters`, `always`, `disallow`
|===

[#stylekeywordargumentsmerging]
== Style/KeywordArgumentsMerging

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.68
| -
|===

When passing an existing hash as keyword arguments, provide additional arguments
directly rather than using `merge`.

Providing arguments directly is more performant than using `merge`, and
also leads to shorter and simpler code.

[#examples-stylekeywordargumentsmerging]
=== Examples

[source,ruby]
----
# bad
some_method(**opts.merge(foo: true))
some_method(**opts.merge(other_opts))

# good
some_method(**opts, foo: true)
some_method(**opts, **other_opts)
----

[#references-stylekeywordargumentsmerging]
=== References

* https://rubystyle.guide#merging-keyword-arguments

[#stylekeywordparametersorder]
== Style/KeywordParametersOrder

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.90
| 1.7
|===

Enforces that optional keyword parameters are placed at the
end of the parameters list.

This improves readability, because when looking through the source,
it is expected to find required parameters at the beginning of parameters list
and optional parameters at the end.

[#examples-stylekeywordparametersorder]
=== Examples

[source,ruby]
----
# bad
def some_method(first: false, second:, third: 10)
  # body omitted
end

# good
def some_method(second:, first: false, third: 10)
  # body omitted
end

# bad
do_something do |first: false, second:, third: 10|
  # body omitted
end

# good
do_something do |second:, first: false, third: 10|
  # body omitted
end
----

[#references-stylekeywordparametersorder]
=== References

* https://rubystyle.guide#keyword-parameters-order

[#stylelambda]
== Style/Lambda

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.40
|===

(by default) checks for uses of the lambda literal syntax for
single line lambdas, and the method call syntax for multiline lambdas.
It is configurable to enforce one of the styles for both single line
and multiline lambdas as well.

[#examples-stylelambda]
=== Examples

[#enforcedstyle_-line_count_dependent-_default_-stylelambda]
==== EnforcedStyle: line_count_dependent (default)

[source,ruby]
----
# bad
f = lambda { |x| x }
f = ->(x) do
      x
    end

# good
f = ->(x) { x }
f = lambda do |x|
      x
    end
----

[#enforcedstyle_-lambda-stylelambda]
==== EnforcedStyle: lambda

[source,ruby]
----
# bad
f = ->(x) { x }
f = ->(x) do
      x
    end

# good
f = lambda { |x| x }
f = lambda do |x|
      x
    end
----

[#enforcedstyle_-literal-stylelambda]
==== EnforcedStyle: literal

[source,ruby]
----
# bad
f = lambda { |x| x }
f = lambda do |x|
      x
    end

# good
f = ->(x) { x }
f = ->(x) do
      x
    end
----

[#configurable-attributes-stylelambda]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `line_count_dependent`
| `line_count_dependent`, `lambda`, `literal`
|===

[#references-stylelambda]
=== References

* https://rubystyle.guide#lambda-multi-line

[#stylelambdacall]
== Style/LambdaCall

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.13
| 0.14
|===

Checks for use of the lambda.(args) syntax.

[#examples-stylelambdacall]
=== Examples

[#enforcedstyle_-call-_default_-stylelambdacall]
==== EnforcedStyle: call (default)

[source,ruby]
----
# bad
lambda.(x, y)

# good
lambda.call(x, y)
----

[#enforcedstyle_-braces-stylelambdacall]
==== EnforcedStyle: braces

[source,ruby]
----
# bad
lambda.call(x, y)

# good
lambda.(x, y)
----

[#configurable-attributes-stylelambdacall]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `call`
| `call`, `braces`
|===

[#references-stylelambdacall]
=== References

* https://rubystyle.guide#proc-call

[#stylelineendconcatenation]
== Style/LineEndConcatenation

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.18
| 0.64
|===

Checks for string literal concatenation at
the end of a line.

[#safety-stylelineendconcatenation]
=== Safety

This cop is unsafe because it cannot be guaranteed that the
receiver is a string, in which case replacing `<<` with `\`
would result in a syntax error.

For example, this would be a false positive:
[source,ruby]
----
array << 'foo' <<
         'bar' <<
         'baz'
----

[#examples-stylelineendconcatenation]
=== Examples

[source,ruby]
----
# bad
some_str = 'ala' +
           'bala'

some_str = 'ala' <<
           'bala'

# good
some_str = 'ala' \
           'bala'
----

[#stylemagiccommentformat]
== Style/MagicCommentFormat

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.35
| -
|===

Ensures magic comments are written consistently throughout your code base.
Looks for discrepancies in separators (`-` vs `_`) and capitalization for
both magic comment directives and values.

Required capitalization can be set with the `DirectiveCapitalization` and
`ValueCapitalization` configuration keys.

NOTE: If one of these configuration is set to nil, any capitalization is allowed.

[#examples-stylemagiccommentformat]
=== Examples

[#enforcedstyle_-snake_case-_default_-stylemagiccommentformat]
==== EnforcedStyle: snake_case (default)

[source,ruby]
----
# The `snake_case` style will enforce that the frozen string literal
# comment is written in snake case. (Words separated by underscores)
# bad
# frozen-string-literal: true

module Bar
  # ...
end

# good
# frozen_string_literal: false

module Bar
  # ...
end
----

[#enforcedstyle_-kebab_case-stylemagiccommentformat]
==== EnforcedStyle: kebab_case

[source,ruby]
----
# The `kebab_case` style will enforce that the frozen string literal
# comment is written in kebab case. (Words separated by hyphens)
# bad
# frozen_string_literal: true

module Baz
  # ...
end

# good
# frozen-string-literal: true

module Baz
  # ...
end
----

[#directivecapitalization_-lowercase-_default_-stylemagiccommentformat]
==== DirectiveCapitalization: lowercase (default)

[source,ruby]
----
# bad
# FROZEN-STRING-LITERAL: true

# good
# frozen-string-literal: true
----

[#directivecapitalization_-uppercase-stylemagiccommentformat]
==== DirectiveCapitalization: uppercase

[source,ruby]
----
# bad
# frozen-string-literal: true

# good
# FROZEN-STRING-LITERAL: true
----

[#directivecapitalization_-nil-stylemagiccommentformat]
==== DirectiveCapitalization: nil

[source,ruby]
----
# any capitalization is accepted

# good
# frozen-string-literal: true

# good
# FROZEN-STRING-LITERAL: true
----

[#valuecapitalization_-nil-_default_-stylemagiccommentformat]
==== ValueCapitalization: nil (default)

[source,ruby]
----
# any capitalization is accepted

# good
# frozen-string-literal: true

# good
# frozen-string-literal: TRUE
----

[#valuecapitalization_-lowercase-stylemagiccommentformat]
==== ValueCapitalization: lowercase

[source,ruby]
----
# when a value is not given, any capitalization is accepted

# bad
# frozen-string-literal: TRUE

# good
# frozen-string-literal: TRUE
----

[#valuecapitalization_-uppercase-stylemagiccommentformat]
==== ValueCapitalization: uppercase

[source,ruby]
----
# bad
# frozen-string-literal: true

# good
# frozen-string-literal: TRUE
----

[#configurable-attributes-stylemagiccommentformat]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `snake_case`
| `snake_case`, `kebab_case`

| DirectiveCapitalization
| `lowercase`
| String

| ValueCapitalization
| `<none>`
| 
|===

[#stylemapcompactwithconditionalblock]
== Style/MapCompactWithConditionalBlock

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.30
| -
|===

Prefer `select` or `reject` over `map { ... }.compact`.
This cop also handles `filter_map { ... }`, similar to `map { ... }.compact`.

[#examples-stylemapcompactwithconditionalblock]
=== Examples

[source,ruby]
----
# bad
array.map { |e| some_condition? ? e : next }.compact

# bad
array.filter_map { |e| some_condition? ? e : next }

# bad
array.map do |e|
  if some_condition?
    e
  else
    next
  end
end.compact

# bad
array.map do |e|
  next if some_condition?

  e
end.compact

# bad
array.map do |e|
  e if some_condition?
end.compact

# good
array.select { |e| some_condition? }

# good
array.reject { |e| some_condition? }
----

[#stylemapintoarray]
== Style/MapIntoArray

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.63
| 1.67
|===

Checks for usages of `each` with `<<`, `push`, or `append` which
can be replaced by `map`.

If `PreferredMethods` is configured for `map` in `Style/CollectionMethods`,
this cop uses the specified method for replacement.

NOTE: The return value of `Enumerable#each` is `self`, whereas the
return value of `Enumerable#map` is an `Array`. They are not autocorrected
when a return value could be used because these types differ.

NOTE: It only detects when the mapping destination is either:
* a local variable initialized as an empty array and referred to only by the
pushing operation;
* or, if it is the single block argument to a `[].tap` block.
This is because, if not, it's challenging to statically guarantee that the
mapping destination variable remains an empty array:

[source,ruby]
----
ret = []
src.each { |e| ret << e * 2 } # `<<` method may mutate `ret`

dest = []
src.each { |e| dest << transform(e, dest) } # `transform` method may mutate `dest`
----

[#safety-stylemapintoarray]
=== Safety

This cop is unsafe because not all objects that have an `each`
method also have a `map` method (e.g. `ENV`). Additionally, for calls
with a block, not all objects that have a `map` method return an array
(e.g. `Enumerator::Lazy`).

[#examples-stylemapintoarray]
=== Examples

[source,ruby]
----
# bad
dest = []
src.each { |e| dest << e * 2 }
dest

# good
dest = src.map { |e| e * 2 }

# bad
[].tap do |dest|
  src.each { |e| dest << e * 2 }
end

# good
dest = src.map { |e| e * 2 }

# good - contains another operation
dest = []
src.each { |e| dest << e * 2; puts e }
dest
----

[#references-stylemapintoarray]
=== References

* https://rubystyle.guide#functional-code

[#stylemaptohash]
== Style/MapToHash

NOTE: Requires Ruby version 2.6

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.24
| -
|===

Looks for uses of `map.to_h` or `collect.to_h` that could be
written with just `to_h` in Ruby >= 2.6.

NOTE: `Style/HashTransformKeys` and `Style/HashTransformValues` will
also change this pattern if only hash keys or hash values are being
transformed.

[#safety-stylemaptohash]
=== Safety

This cop is unsafe, as it can produce false positives if the receiver
is not an `Enumerable`.

[#examples-stylemaptohash]
=== Examples

[source,ruby]
----
# bad
something.map { |v| [v, v * 2] }.to_h

# good
something.to_h { |v| [v, v * 2] }

# bad
{foo: bar}.collect { |k, v| [k.to_s, v.do_something] }.to_h

# good
{foo: bar}.to_h { |k, v| [k.to_s, v.do_something] }
----

[#stylemaptoset]
== Style/MapToSet

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.42
| -
|===

Looks for uses of `map.to_set` or `collect.to_set` that could be
written with just `to_set`.

[#safety-stylemaptoset]
=== Safety

This cop is unsafe, as it can produce false positives if the receiver
is not an `Enumerable`.

[#examples-stylemaptoset]
=== Examples

[source,ruby]
----
# bad
something.map { |i| i * 2 }.to_set

# good
something.to_set { |i| i * 2 }

# bad
[1, 2, 3].collect { |i| i.to_s }.to_set

# good
[1, 2, 3].to_set { |i| i.to_s }
----

[#stylemethodcallwithargsparentheses]
== Style/MethodCallWithArgsParentheses

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| Always
| 0.47
| 1.7
|===

Enforces the presence (default) or absence of parentheses in
method calls containing arguments.

In the default style (require_parentheses), macro methods are allowed.
Additional methods can be added to the `AllowedMethods` or
`AllowedPatterns` list. These options are valid only in the default
style. Macros can be included by either setting `IgnoreMacros` to false
or adding specific macros to the `IncludedMacros` list.

Precedence of options is as follows:

1. `AllowedMethods`
2. `AllowedPatterns`
3. `IncludedMacros`

If a method is listed in both `IncludedMacros` and `AllowedMethods`,
then the latter takes precedence (that is, the method is allowed).

In the alternative style (omit_parentheses), there are three additional
options.

1. `AllowParenthesesInChaining` is `false` by default. Setting it to
   `true` allows the presence of parentheses in the last call during
   method chaining.

2. `AllowParenthesesInMultilineCall` is `false` by default. Setting it
    to `true` allows the presence of parentheses in multi-line method
    calls.

3. `AllowParenthesesInCamelCaseMethod` is `false` by default. This
    allows the presence of parentheses when calling a method whose name
    begins with a capital letter and which has no arguments. Setting it
    to `true` allows the presence of parentheses in such a method call
    even with arguments.

NOTE: The style of `omit_parentheses` allows parentheses in cases where
omitting them results in ambiguous or syntactically incorrect code.

Non-exhaustive list of examples:

- Parentheses are required allowed in method calls with arguments inside
  literals, logical operators, setting default values in position and
  keyword arguments, chaining and more.
- Parentheses are allowed in method calls with arguments inside
  operators to avoid ambiguity.
  triple-dot syntax introduced in Ruby 2.7 as omitting them starts an
  endless range.
- Parentheses are allowed when forwarding arguments with the
  triple-dot syntax introduced in Ruby 2.7 as omitting them starts an
  endless range.
- Parentheses are required in calls with arguments when inside an
  endless method definition introduced in Ruby 3.0.
- Ruby 3.1's hash omission syntax allows parentheses if the method call
  is in conditionals and requires parentheses if the call
  is not the value-returning expression. See
  https://bugs.ruby-lang.org/issues/18396.
- Parentheses are required in anonymous arguments, keyword arguments
  and block passing in Ruby 3.2.
- Parentheses are required when the first argument is a beginless range or
  the last argument is an endless range.

[#examples-stylemethodcallwithargsparentheses]
=== Examples

[#enforcedstyle_-require_parentheses-_default_-stylemethodcallwithargsparentheses]
==== EnforcedStyle: require_parentheses (default)

[source,ruby]
----
# bad
array.delete e

# good
array.delete(e)

# good
# Operators don't need parens
foo == bar

# good
# Setter methods don't need parens
foo.bar = baz

# okay with `puts` listed in `AllowedMethods`
puts 'test'

# okay with `^assert` listed in `AllowedPatterns`
assert_equal 'test', x
----

[#enforcedstyle_-omit_parentheses-stylemethodcallwithargsparentheses]
==== EnforcedStyle: omit_parentheses

[source,ruby]
----
# bad
array.delete(e)

# good
array.delete e

# bad
action.enforce(strict: true)

# good
action.enforce strict: true

# good
# Parentheses are allowed for code that can be ambiguous without
# them.
action.enforce(condition) || other_condition

# good
# Parentheses are allowed for calls that won't produce valid Ruby
# without them.
yield path, File.basename(path)

# good
# Omitting the parentheses in Ruby 3.1 hash omission syntax can lead
# to ambiguous code. We allow them in conditionals and non-last
# expressions. See https://bugs.ruby-lang.org/issues/18396
if meets(criteria:, action:)
  safe_action(action) || dangerous_action(action)
end
----

[#ignoremacros_-true-_default_-stylemethodcallwithargsparentheses]
==== IgnoreMacros: true (default)

[source,ruby]
----
# good
class Foo
  bar :baz
end
----

[#ignoremacros_-false-stylemethodcallwithargsparentheses]
==== IgnoreMacros: false

[source,ruby]
----
# bad
class Foo
  bar :baz
end
----

[#allowparenthesesinmultilinecall_-false-_default_-stylemethodcallwithargsparentheses]
==== AllowParenthesesInMultilineCall: false (default)

[source,ruby]
----
# bad
foo.enforce(
  strict: true
)

# good
foo.enforce \
  strict: true
----

[#allowparenthesesinmultilinecall_-true-stylemethodcallwithargsparentheses]
==== AllowParenthesesInMultilineCall: true

[source,ruby]
----
# good
foo.enforce(
  strict: true
)

# good
foo.enforce \
  strict: true
----

[#allowparenthesesinchaining_-false-_default_-stylemethodcallwithargsparentheses]
==== AllowParenthesesInChaining: false (default)

[source,ruby]
----
# bad
foo().bar(1)

# good
foo().bar 1
----

[#allowparenthesesinchaining_-true-stylemethodcallwithargsparentheses]
==== AllowParenthesesInChaining: true

[source,ruby]
----
# good
foo().bar(1)

# good
foo().bar 1
----

[#allowparenthesesincamelcasemethod_-false-_default_-stylemethodcallwithargsparentheses]
==== AllowParenthesesInCamelCaseMethod: false (default)

[source,ruby]
----
# bad
Array(1)

# good
Array 1
----

[#allowparenthesesincamelcasemethod_-true-stylemethodcallwithargsparentheses]
==== AllowParenthesesInCamelCaseMethod: true

[source,ruby]
----
# good
Array(1)

# good
Array 1
----

[#allowparenthesesinstringinterpolation_-false-_default_-stylemethodcallwithargsparentheses]
==== AllowParenthesesInStringInterpolation: false (default)

[source,ruby]
----
# bad
"#{t('this.is.bad')}"

# good
"#{t 'this.is.better'}"
----

[#allowparenthesesinstringinterpolation_-true-stylemethodcallwithargsparentheses]
==== AllowParenthesesInStringInterpolation: true

[source,ruby]
----
# good
"#{t('this.is.good')}"

# good
"#{t 'this.is.also.good'}"
----

[#configurable-attributes-stylemethodcallwithargsparentheses]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| IgnoreMacros
| `true`
| Boolean

| AllowedMethods
| `[]`
| Array

| AllowedPatterns
| `[]`
| Array

| IncludedMacros
| `[]`
| Array

| AllowParenthesesInMultilineCall
| `false`
| Boolean

| AllowParenthesesInChaining
| `false`
| Boolean

| AllowParenthesesInCamelCaseMethod
| `false`
| Boolean

| AllowParenthesesInStringInterpolation
| `false`
| Boolean

| EnforcedStyle
| `require_parentheses`
| `require_parentheses`, `omit_parentheses`
|===

[#references-stylemethodcallwithargsparentheses]
=== References

* https://rubystyle.guide#method-invocation-parens

[#stylemethodcallwithoutargsparentheses]
== Style/MethodCallWithoutArgsParentheses

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.47
| 0.55
|===

Checks for unwanted parentheses in parameterless method calls.

This cop's allowed methods can be customized with `AllowedMethods`.
By default, there are no allowed methods.

NOTE: This cop allows the use of `it()` without arguments in blocks,
as in `0.times { it() }`, following `Lint/ItWithoutArgumentsInBlock` cop.

[#examples-stylemethodcallwithoutargsparentheses]
=== Examples

[source,ruby]
----
# bad
object.some_method()

# good
object.some_method
----

[#allowedmethods_-__-_default_-stylemethodcallwithoutargsparentheses]
==== AllowedMethods: [] (default)

[source,ruby]
----
# bad
object.foo()
----

[#allowedmethods_-_foo_-stylemethodcallwithoutargsparentheses]
==== AllowedMethods: [foo]

[source,ruby]
----
# good
object.foo()
----

[#configurable-attributes-stylemethodcallwithoutargsparentheses]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedMethods
| `[]`
| Array

| AllowedPatterns
| `[]`
| Array
|===

[#references-stylemethodcallwithoutargsparentheses]
=== References

* https://rubystyle.guide#method-invocation-parens

[#stylemethodcalledondoendblock]
== Style/MethodCalledOnDoEndBlock

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.14
| -
|===

Checks for methods called on a do...end block. The point of
this check is that it's easy to miss the call tacked on to the block
when reading code.

[#examples-stylemethodcalledondoendblock]
=== Examples

[source,ruby]
----
# bad
a do
  b
end.c

# good
a { b }.c

# good
foo = a do
  b
end
foo.c
----

[#references-stylemethodcalledondoendblock]
=== References

* https://rubystyle.guide#single-line-blocks

[#stylemethoddefparentheses]
== Style/MethodDefParentheses

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.16
| 1.7
|===

Checks for parentheses around the arguments in method
definitions. Both instance and class/singleton methods are checked.

Regardless of style, parentheses are necessary for:

1. Endless methods
2. Argument lists containing a `forward-arg` (`...`)
3. Argument lists containing an anonymous rest arguments forwarding (`*`)
4. Argument lists containing an anonymous keyword rest arguments forwarding (`**`)
5. Argument lists containing an anonymous block forwarding (`&`)

Removing the parens would be a syntax error here.

[#examples-stylemethoddefparentheses]
=== Examples

[#enforcedstyle_-require_parentheses-_default_-stylemethoddefparentheses]
==== EnforcedStyle: require_parentheses (default)

[source,ruby]
----
# The `require_parentheses` style requires method definitions
# to always use parentheses

# bad
def bar num1, num2
  num1 + num2
end

def foo descriptive_var_name,
        another_descriptive_var_name,
        last_descriptive_var_name
  do_something
end

# good
def bar(num1, num2)
  num1 + num2
end

def foo(descriptive_var_name,
        another_descriptive_var_name,
        last_descriptive_var_name)
  do_something
end
----

[#enforcedstyle_-require_no_parentheses-stylemethoddefparentheses]
==== EnforcedStyle: require_no_parentheses

[source,ruby]
----
# The `require_no_parentheses` style requires method definitions
# to never use parentheses

# bad
def bar(num1, num2)
  num1 + num2
end

def foo(descriptive_var_name,
        another_descriptive_var_name,
        last_descriptive_var_name)
  do_something
end

# good
def bar num1, num2
  num1 + num2
end

def foo descriptive_var_name,
        another_descriptive_var_name,
        last_descriptive_var_name
  do_something
end
----

[#enforcedstyle_-require_no_parentheses_except_multiline-stylemethoddefparentheses]
==== EnforcedStyle: require_no_parentheses_except_multiline

[source,ruby]
----
# The `require_no_parentheses_except_multiline` style prefers no
# parentheses when method definition arguments fit on single line,
# but prefers parentheses when arguments span multiple lines.

# bad
def bar(num1, num2)
  num1 + num2
end

def foo descriptive_var_name,
        another_descriptive_var_name,
        last_descriptive_var_name
  do_something
end

# good
def bar num1, num2
  num1 + num2
end

def foo(descriptive_var_name,
        another_descriptive_var_name,
        last_descriptive_var_name)
  do_something
end
----

[#configurable-attributes-stylemethoddefparentheses]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `require_parentheses`
| `require_parentheses`, `require_no_parentheses`, `require_no_parentheses_except_multiline`
|===

[#references-stylemethoddefparentheses]
=== References

* https://rubystyle.guide#method-parens

[#styleminmax]
== Style/MinMax

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.50
| -
|===

Checks for potential uses of `Enumerable#minmax`.

[#examples-styleminmax]
=== Examples

[source,ruby]
----
# bad
bar = [foo.min, foo.max]
return foo.min, foo.max

# good
bar = foo.minmax
return foo.minmax
----

[#styleminmaxcomparison]
== Style/MinMaxComparison

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.42
| -
|===

Enforces the use of `max` or `min` instead of comparison for greater or less.

NOTE: It can be used if you want to present limit or threshold in Ruby 2.7+.
That it is slow though. So autocorrection will apply generic `max` or `min`:

[source,ruby]
----
a.clamp(b..) # Same as `[a, b].max`
a.clamp(..b) # Same as `[a, b].min`
----

[#safety-styleminmaxcomparison]
=== Safety

This cop is unsafe because even if a value has `<` or `>` method,
it is not necessarily `Comparable`.

[#examples-styleminmaxcomparison]
=== Examples

[source,ruby]
----
# bad
a > b ? a : b
a >= b ? a : b

# good
[a, b].max

# bad
a < b ? a : b
a <= b ? a : b

# good
[a, b].min
----

[#stylemissingelse]
== Style/MissingElse

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| Always
| 0.30
| 0.38
|===

Checks for `if` expressions that do not have an `else` branch.

NOTE: Pattern matching is allowed to have no `else` branch because unlike `if` and `case`,
it raises `NoMatchingPatternError` if the pattern doesn't match and without having `else`.

Supported styles are: if, case, both.

[#examples-stylemissingelse]
=== Examples

[#enforcedstyle_-both-_default_-stylemissingelse]
==== EnforcedStyle: both (default)

[source,ruby]
----
# warn when an `if` or `case` expression is missing an `else` branch.

# bad
if condition
  statement
end

# bad
case var
when condition
  statement
end

# good
if condition
  statement
else
  # the content of `else` branch will be determined by Style/EmptyElse
end

# good
case var
when condition
  statement
else
  # the content of `else` branch will be determined by Style/EmptyElse
end
----

[#enforcedstyle_-if-stylemissingelse]
==== EnforcedStyle: if

[source,ruby]
----
# warn when an `if` expression is missing an `else` branch.

# bad
if condition
  statement
end

# good
if condition
  statement
else
  # the content of `else` branch will be determined by Style/EmptyElse
end

# good
case var
when condition
  statement
end

# good
case var
when condition
  statement
else
  # the content of `else` branch will be determined by Style/EmptyElse
end
----

[#enforcedstyle_-case-stylemissingelse]
==== EnforcedStyle: case

[source,ruby]
----
# warn when a `case` expression is missing an `else` branch.

# bad
case var
when condition
  statement
end

# good
case var
when condition
  statement
else
  # the content of `else` branch will be determined by Style/EmptyElse
end

# good
if condition
  statement
end

# good
if condition
  statement
else
  # the content of `else` branch will be determined by Style/EmptyElse
end
----

[#configurable-attributes-stylemissingelse]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `both`
| `if`, `case`, `both`
|===

[#stylemissingrespondtomissing]
== Style/MissingRespondToMissing

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.56
| -
|===

Checks for the presence of `method_missing` without also
defining `respond_to_missing?`.

Not defining `respond_to_missing?` will cause metaprogramming
methods like `respond_to?` to behave unexpectedly:

[source,ruby]
----
class StringDelegator
  def initialize(string)
    @string = string
  end

  def method_missing(name, *args)
    @string.send(name, *args)
  end
end

delegator = StringDelegator.new("foo")
# Claims to not respond to `upcase`.
delegator.respond_to?(:upcase) # => false
# But you can call it.
delegator.upcase # => FOO
----

[#examples-stylemissingrespondtomissing]
=== Examples

[source,ruby]
----
# bad
def method_missing(name, *args)
  if @delegate.respond_to?(name)
    @delegate.send(name, *args)
  else
    super
  end
end

# good
def respond_to_missing?(name, include_private)
  @delegate.respond_to?(name) || super
end

def method_missing(name, *args)
  if @delegate.respond_to?(name)
    @delegate.send(name, *args)
  else
    super
  end
end
----

[#references-stylemissingrespondtomissing]
=== References

* https://rubystyle.guide#no-method-missing

[#stylemixingrouping]
== Style/MixinGrouping

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.48
| 0.49
|===

Checks for grouping of mixins in `class` and `module` bodies.
By default it enforces mixins to be placed in separate declarations,
but it can be configured to enforce grouping them in one declaration.

[#examples-stylemixingrouping]
=== Examples

[#enforcedstyle_-separated-_default_-stylemixingrouping]
==== EnforcedStyle: separated (default)

[source,ruby]
----
# bad
class Foo
  include Bar, Qox
end

# good
class Foo
  include Qox
  include Bar
end
----

[#enforcedstyle_-grouped-stylemixingrouping]
==== EnforcedStyle: grouped

[source,ruby]
----
# bad
class Foo
  extend Bar
  extend Qox
end

# good
class Foo
  extend Qox, Bar
end
----

[#configurable-attributes-stylemixingrouping]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `separated`
| `separated`, `grouped`
|===

[#references-stylemixingrouping]
=== References

* https://rubystyle.guide#mixin-grouping

[#stylemixinusage]
== Style/MixinUsage

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.51
| -
|===

Checks that `include`, `extend` and `prepend` statements appear
inside classes and modules, not at the top level, so as to not affect
the behavior of `Object`.

[#examples-stylemixinusage]
=== Examples

[source,ruby]
----
# bad
include M

class C
end

# bad
extend M

class C
end

# bad
prepend M

class C
end

# good
class C
  include M
end

# good
class C
  extend M
end

# good
class C
  prepend M
end
----

[#stylemodulefunction]
== Style/ModuleFunction

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.11
| 0.65
|===

Checks for use of `extend self` or `module_function` in a module.

Supported styles are: `module_function` (default), `extend_self` and `forbidden`.

A couple of things to keep in mind:

- `forbidden` style prohibits the usage of both styles
- in default mode (`module_function`), the cop won't be activated when the module
  contains any private methods

[#safety-stylemodulefunction]
=== Safety

Autocorrection is unsafe (and is disabled by default) because `extend self`
and `module_function` do not behave exactly the same.

[#examples-stylemodulefunction]
=== Examples

[#enforcedstyle_-module_function-_default_-stylemodulefunction]
==== EnforcedStyle: module_function (default)

[source,ruby]
----
# bad
module Test
  extend self
  # ...
end

# good
module Test
  module_function
  # ...
end

# good
module Test
  extend self
  # ...
  private
  # ...
end

# good
module Test
  class << self
    # ...
  end
end
----

[#enforcedstyle_-extend_self-stylemodulefunction]
==== EnforcedStyle: extend_self

[source,ruby]
----
# bad
module Test
  module_function
  # ...
end

# good
module Test
  extend self
  # ...
end

# good
module Test
  class << self
    # ...
  end
end
----

[#enforcedstyle_-forbidden-stylemodulefunction]
==== EnforcedStyle: forbidden

[source,ruby]
----
# bad
module Test
  module_function
  # ...
end

# bad
module Test
  extend self
  # ...
end

# bad
module Test
  extend self
  # ...
  private
  # ...
end

# good
module Test
  class << self
    # ...
  end
end
----

[#configurable-attributes-stylemodulefunction]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `module_function`
| `module_function`, `extend_self`, `forbidden`

| Autocorrect
| `false`
| Boolean
|===

[#references-stylemodulefunction]
=== References

* https://rubystyle.guide#module-function

[#stylemultilineblockchain]
== Style/MultilineBlockChain

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.13
| -
|===

Checks for chaining of a block after another block that spans
multiple lines.

[#examples-stylemultilineblockchain]
=== Examples

[source,ruby]
----
# bad
Thread.list.select do |t|
  t.alive?
end.map do |t|
  t.object_id
end

# good
alive_threads = Thread.list.select do |t|
  t.alive?
end
alive_threads.map do |t|
  t.object_id
end
----

[#references-stylemultilineblockchain]
=== References

* https://rubystyle.guide#single-line-blocks

[#stylemultilineifmodifier]
== Style/MultilineIfModifier

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.45
| -
|===

Checks for uses of if/unless modifiers with multiple-lines bodies.

[#examples-stylemultilineifmodifier]
=== Examples

[source,ruby]
----
# bad
{
  result: 'this should not happen'
} unless cond

# good
{ result: 'ok' } if cond
----

[#references-stylemultilineifmodifier]
=== References

* https://rubystyle.guide#no-multiline-if-modifiers

[#stylemultilineifthen]
== Style/MultilineIfThen

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.26
|===

Checks for uses of the `then` keyword in multi-line if statements.

[#examples-stylemultilineifthen]
=== Examples

[source,ruby]
----
# bad
# This is considered bad practice.
if cond then
end

# good
# If statements can contain `then` on the same line.
if cond then a
elsif cond then b
end
----

[#references-stylemultilineifthen]
=== References

* https://rubystyle.guide#no-then

[#stylemultilineinpatternthen]
== Style/MultilineInPatternThen

NOTE: Requires Ruby version 2.7

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.16
| -
|===

Checks uses of the `then` keyword in multi-line `in` statement.

[#examples-stylemultilineinpatternthen]
=== Examples

[source,ruby]
----
# bad
case expression
in pattern then
end

# good
case expression
in pattern
end

# good
case expression
in pattern then do_something
end

# good
case expression
in pattern then do_something(arg1,
                             arg2)
end
----

[#references-stylemultilineinpatternthen]
=== References

* https://rubystyle.guide#no-then

[#stylemultilinememoization]
== Style/MultilineMemoization

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.44
| 0.48
|===

Checks expressions wrapping styles for multiline memoization.

[#examples-stylemultilinememoization]
=== Examples

[#enforcedstyle_-keyword-_default_-stylemultilinememoization]
==== EnforcedStyle: keyword (default)

[source,ruby]
----
# bad
foo ||= (
  bar
  baz
)

# good
foo ||= begin
  bar
  baz
end
----

[#enforcedstyle_-braces-stylemultilinememoization]
==== EnforcedStyle: braces

[source,ruby]
----
# bad
foo ||= begin
  bar
  baz
end

# good
foo ||= (
  bar
  baz
)
----

[#configurable-attributes-stylemultilinememoization]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `keyword`
| `keyword`, `braces`
|===

[#stylemultilinemethodsignature]
== Style/MultilineMethodSignature

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| Always
| 0.59
| 1.7
|===

Checks for method signatures that span multiple lines.

[#examples-stylemultilinemethodsignature]
=== Examples

[source,ruby]
----
# good

def foo(bar, baz)
end

# bad

def foo(bar,
        baz)
end
----

[#stylemultilineternaryoperator]
== Style/MultilineTernaryOperator

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.86
|===

Checks for multi-line ternary op expressions.

NOTE: `return if ... else ... end` is syntax error. If `return` is used before
multiline ternary operator expression, it will be autocorrected to single-line
ternary operator. The same is true for `break`, `next`, and method call.

[#examples-stylemultilineternaryoperator]
=== Examples

[source,ruby]
----
# bad
a = cond ?
  b : c
a = cond ? b :
    c
a = cond ?
    b :
    c

return cond ?
       b :
       c

# good
a = cond ? b : c
a = if cond
  b
else
  c
end

return cond ? b : c
----

[#references-stylemultilineternaryoperator]
=== References

* https://rubystyle.guide#no-multiline-ternary

[#stylemultilinewhenthen]
== Style/MultilineWhenThen

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.73
| -
|===

Checks uses of the `then` keyword
in multi-line when statements.

[#examples-stylemultilinewhenthen]
=== Examples

[source,ruby]
----
# bad
case foo
when bar then
end

# good
case foo
when bar
end

# good
case foo
when bar then do_something
end

# good
case foo
when bar then do_something(arg1,
                           arg2)
end
----

[#references-stylemultilinewhenthen]
=== References

* https://rubystyle.guide#no-then

[#stylemultiplecomparison]
== Style/MultipleComparison

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.49
| 1.1
|===

Checks against comparing a variable with multiple items, where
`Array#include?`, `Set#include?` or a `case` could be used instead
to avoid code repetition.
It accepts comparisons of multiple method calls to avoid unnecessary method calls
by default. It can be configured by `AllowMethodComparison` option.

[#examples-stylemultiplecomparison]
=== Examples

[source,ruby]
----
# bad
a = 'a'
foo if a == 'a' || a == 'b' || a == 'c'

# good
a = 'a'
foo if ['a', 'b', 'c'].include?(a)

VALUES = Set['a', 'b', 'c'].freeze
# elsewhere...
foo if VALUES.include?(a)

case foo
when 'a', 'b', 'c' then foo
# ...
end

# accepted (but consider `case` as above)
foo if a == b.lightweight || a == b.heavyweight
----

[#allowmethodcomparison_-true-_default_-stylemultiplecomparison]
==== AllowMethodComparison: true (default)

[source,ruby]
----
# good
foo if a == b.lightweight || a == b.heavyweight
----

[#allowmethodcomparison_-false-stylemultiplecomparison]
==== AllowMethodComparison: false

[source,ruby]
----
# bad
foo if a == b.lightweight || a == b.heavyweight

# good
foo if [b.lightweight, b.heavyweight].include?(a)
----

[#comparisonsthreshold_-2-_default_-stylemultiplecomparison]
==== ComparisonsThreshold: 2 (default)

[source,ruby]
----
# bad
foo if a == 'a' || a == 'b'
----

[#comparisonsthreshold_-3-stylemultiplecomparison]
==== ComparisonsThreshold: 3

[source,ruby]
----
# good
foo if a == 'a' || a == 'b'
----

[#configurable-attributes-stylemultiplecomparison]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowMethodComparison
| `true`
| Boolean

| ComparisonsThreshold
| `2`
| Integer
|===

[#stylemutableconstant]
== Style/MutableConstant

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.34
| 1.8
|===

Checks whether some constant value isn't a
mutable literal (e.g. array or hash).

Strict mode can be used to freeze all constants, rather than
just literals.
Strict mode is considered an experimental feature. It has not been
updated with an exhaustive list of all methods that will produce
frozen objects so there is a decent chance of getting some false
positives. Luckily, there is no harm in freezing an already
frozen object.

From Ruby 3.0, this cop honours the magic comment
'shareable_constant_value'. When this magic comment is set to any
acceptable value other than none, it will suppress the offenses
raised by this cop. It enforces frozen state.

NOTE: `Regexp` and `Range` literals are frozen objects since Ruby 3.0.

NOTE: From Ruby 3.0, interpolated strings are not frozen when
`# frozen-string-literal: true` is used, so this cop enforces explicit
freezing for such strings.

NOTE: From Ruby 3.0, this cop allows explicit freezing of constants when
the `shareable_constant_value` directive is used.

[#safety-stylemutableconstant]
=== Safety

This cop's autocorrection is unsafe since any mutations on objects that
are made frozen will change from being accepted to raising `FrozenError`,
and will need to be manually refactored.

[#examples-stylemutableconstant]
=== Examples

[#enforcedstyle_-literals-_default_-stylemutableconstant]
==== EnforcedStyle: literals (default)

[source,ruby]
----
# bad
CONST = [1, 2, 3]

# good
CONST = [1, 2, 3].freeze

# good
CONST = <<~TESTING.freeze
  This is a heredoc
TESTING

# good
CONST = Something.new
----

[#enforcedstyle_-strict-stylemutableconstant]
==== EnforcedStyle: strict

[source,ruby]
----
# bad
CONST = Something.new

# bad
CONST = Struct.new do
  def foo
    puts 1
  end
end

# good
CONST = Something.new.freeze

# good
CONST = Struct.new do
  def foo
    puts 1
  end
end.freeze
----

[source,ruby]
----
# Magic comment - shareable_constant_value: literal

# bad
CONST = [1, 2, 3]

# good
# shareable_constant_value: literal
CONST = [1, 2, 3]
----

[#configurable-attributes-stylemutableconstant]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `literals`
| `literals`, `strict`
|===

[#stylenegatedif]
== Style/NegatedIf

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.20
| 0.48
|===

Checks for uses of if with a negated condition. Only ifs
without else are considered. There are three different styles:

* both
* prefix
* postfix

[#examples-stylenegatedif]
=== Examples

[#enforcedstyle_-both-_default_-stylenegatedif]
==== EnforcedStyle: both (default)

[source,ruby]
----
# enforces `unless` for `prefix` and `postfix` conditionals

# bad

if !foo
  bar
end

# good

unless foo
  bar
end

# bad

bar if !foo

# good

bar unless foo
----

[#enforcedstyle_-prefix-stylenegatedif]
==== EnforcedStyle: prefix

[source,ruby]
----
# enforces `unless` for just `prefix` conditionals

# bad

if !foo
  bar
end

# good

unless foo
  bar
end

# good

bar if !foo
----

[#enforcedstyle_-postfix-stylenegatedif]
==== EnforcedStyle: postfix

[source,ruby]
----
# enforces `unless` for just `postfix` conditionals

# bad

bar if !foo

# good

bar unless foo

# good

if !foo
  bar
end
----

[#configurable-attributes-stylenegatedif]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `both`
| `both`, `prefix`, `postfix`
|===

[#references-stylenegatedif]
=== References

* https://rubystyle.guide#unless-for-negatives

[#stylenegatedifelsecondition]
== Style/NegatedIfElseCondition

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.2
| -
|===

Checks for uses of `if-else` and ternary operators with a negated condition
which can be simplified by inverting condition and swapping branches.

[#examples-stylenegatedifelsecondition]
=== Examples

[source,ruby]
----
# bad
if !x
  do_something
else
  do_something_else
end

# good
if x
  do_something_else
else
  do_something
end

# bad
!x ? do_something : do_something_else

# good
x ? do_something_else : do_something
----

[#stylenegatedunless]
== Style/NegatedUnless

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.69
| -
|===

Checks for uses of unless with a negated condition. Only unless
without else are considered. There are three different styles:

* both
* prefix
* postfix

[#examples-stylenegatedunless]
=== Examples

[#enforcedstyle_-both-_default_-stylenegatedunless]
==== EnforcedStyle: both (default)

[source,ruby]
----
# enforces `if` for `prefix` and `postfix` conditionals

# bad
unless !foo
  bar
end

# good
if foo
  bar
end

# bad
bar unless !foo

# good
bar if foo
----

[#enforcedstyle_-prefix-stylenegatedunless]
==== EnforcedStyle: prefix

[source,ruby]
----
# enforces `if` for just `prefix` conditionals

# bad
unless !foo
  bar
end

# good
if foo
  bar
end

# good
bar unless !foo
----

[#enforcedstyle_-postfix-stylenegatedunless]
==== EnforcedStyle: postfix

[source,ruby]
----
# enforces `if` for just `postfix` conditionals

# bad
bar unless !foo

# good
bar if foo

# good
unless !foo
  bar
end
----

[#configurable-attributes-stylenegatedunless]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `both`
| `both`, `prefix`, `postfix`
|===

[#references-stylenegatedunless]
=== References

* https://rubystyle.guide#if-for-negatives

[#stylenegatedwhile]
== Style/NegatedWhile

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.20
| -
|===

Checks for uses of while with a negated condition.

[#examples-stylenegatedwhile]
=== Examples

[source,ruby]
----
# bad
while !foo
  bar
end

# good
until foo
  bar
end

# bad
bar until !foo

# good
bar while foo
bar while !foo && baz
----

[#references-stylenegatedwhile]
=== References

* https://rubystyle.guide#until-for-negatives

[#stylenestedfiledirname]
== Style/NestedFileDirname

NOTE: Requires Ruby version 3.1

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.26
| -
|===

Checks for nested `File.dirname`.
It replaces nested `File.dirname` with the level argument introduced in Ruby 3.1.

[#examples-stylenestedfiledirname]
=== Examples

[source,ruby]
----
# bad
File.dirname(File.dirname(path))

# good
File.dirname(path, 2)
----

[#stylenestedmodifier]
== Style/NestedModifier

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.35
| -
|===

Checks for nested use of if, unless, while and until in their
modifier form.

[#examples-stylenestedmodifier]
=== Examples

[source,ruby]
----
# bad
something if a if b

# good
something if b && a
----

[#references-stylenestedmodifier]
=== References

* https://rubystyle.guide#no-nested-modifiers

[#stylenestedparenthesizedcalls]
== Style/NestedParenthesizedCalls

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.36
| 0.77
|===

Checks for unparenthesized method calls in the argument list
of a parenthesized method call.
`be`, `be_a`, `be_an`, `be_between`, `be_falsey`, `be_kind_of`, `be_instance_of`,
`be_truthy`, `be_within`, `eq`, `eql`, `end_with`, `include`, `match`, `raise_error`,
`respond_to`, and `start_with` methods are allowed by default.
These are customizable with `AllowedMethods` option.

[#examples-stylenestedparenthesizedcalls]
=== Examples

[source,ruby]
----
# good
method1(method2(arg))

# bad
method1(method2 arg)
----

[#allowedmethods_-_foo_-stylenestedparenthesizedcalls]
==== AllowedMethods: [foo]

[source,ruby]
----
# good
method1(foo arg)
----

[#configurable-attributes-stylenestedparenthesizedcalls]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedMethods
| `be`, `be_a`, `be_an`, `be_between`, `be_falsey`, `be_kind_of`, `be_instance_of`, `be_truthy`, `be_within`, `eq`, `eql`, `end_with`, `include`, `match`, `raise_error`, `respond_to`, `start_with`
| Array
|===

[#stylenestedternaryoperator]
== Style/NestedTernaryOperator

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.86
|===

Checks for nested ternary op expressions.

[#examples-stylenestedternaryoperator]
=== Examples

[source,ruby]
----
# bad
a ? (b ? b1 : b2) : a2

# good
if a
  b ? b1 : b2
else
  a2
end
----

[#references-stylenestedternaryoperator]
=== References

* https://rubystyle.guide#no-nested-ternary

[#stylenext]
== Style/Next

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.22
| 1.75
|===

Use `next` to skip iteration instead of a condition at the end.

[#examples-stylenext]
=== Examples

[#enforcedstyle_-skip_modifier_ifs-_default_-stylenext]
==== EnforcedStyle: skip_modifier_ifs (default)

[source,ruby]
----
# bad
[1, 2].each do |a|
  if a == 1
    puts a
  end
end

# good
[1, 2].each do |a|
  next unless a == 1
  puts a
end

# good
[1, 2].each do |a|
  puts a if a == 1
end
----

[#enforcedstyle_-always-stylenext]
==== EnforcedStyle: always

[source,ruby]
----
# With `always` all conditions at the end of an iteration needs to be
# replaced by next - with `skip_modifier_ifs` the modifier if like
# this one are ignored: `[1, 2].each { |a| puts a if a == 1 }`

# bad
[1, 2].each do |a|
  puts a if a == 1
end

# bad
[1, 2].each do |a|
  if a == 1
    puts a
  end
end

# good
[1, 2].each do |a|
  next unless a == 1
  puts a
end
----

[#allowconsecutiveconditionals_-false-_default_-stylenext]
==== AllowConsecutiveConditionals: false (default)

[source,ruby]
----
# bad
[1, 2].each do |a|
  if a == 1
    puts a
  end
  if a == 2
    puts a
  end
end

# good
[1, 2].each do |a|
  if a == 1
    puts a
  end
  next unless a == 2
  puts a
end
----

[#allowconsecutiveconditionals_-true-stylenext]
==== AllowConsecutiveConditionals: true

[source,ruby]
----
# good
[1, 2].each do |a|
  if a == 1
    puts a
  end
  if a == 2
    puts a
  end
end
----

[#configurable-attributes-stylenext]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `skip_modifier_ifs`
| `skip_modifier_ifs`, `always`

| MinBodyLength
| `3`
| Integer

| AllowConsecutiveConditionals
| `false`
| Boolean
|===

[#references-stylenext]
=== References

* https://rubystyle.guide#no-nested-conditionals

[#stylenilcomparison]
== Style/NilComparison

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.12
| 0.59
|===

Checks for comparison of something with nil using `==` and
`nil?`.

Supported styles are: predicate, comparison.

[#examples-stylenilcomparison]
=== Examples

[#enforcedstyle_-predicate-_default_-stylenilcomparison]
==== EnforcedStyle: predicate (default)

[source,ruby]
----
# bad
if x == nil
end

# good
if x.nil?
end
----

[#enforcedstyle_-comparison-stylenilcomparison]
==== EnforcedStyle: comparison

[source,ruby]
----
# bad
if x.nil?
end

# good
if x == nil
end
----

[#configurable-attributes-stylenilcomparison]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `predicate`
| `predicate`, `comparison`
|===

[#references-stylenilcomparison]
=== References

* https://rubystyle.guide#predicate-methods

[#stylenillambda]
== Style/NilLambda

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.3
| 1.15
|===

Checks for lambdas and procs that always return nil,
which can be replaced with an empty lambda or proc instead.

[#examples-stylenillambda]
=== Examples

[source,ruby]
----
# bad
-> { nil }

lambda do
  next nil
end

proc { nil }

Proc.new do
  break nil
end

# good
-> {}

lambda do
end

-> (x) { nil if x }

proc {}

Proc.new { nil if x }
----

[#stylenonnilcheck]
== Style/NonNilCheck

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.20
| 0.22
|===

Checks for non-nil checks, which are usually redundant.

With `IncludeSemanticChanges` set to `false` by default, this cop
does not report offenses for `!x.nil?` and does no changes that might
change behavior.
Also `IncludeSemanticChanges` set to `false` with `EnforcedStyle: comparison` of
`Style/NilComparison` cop, this cop does not report offenses for `x != nil` and
does no changes to `!x.nil?` style.

With `IncludeSemanticChanges` set to `true`, this cop reports offenses
for `!x.nil?` and autocorrects that and `x != nil` to solely `x`, which
is *usually* OK, but might change behavior.

[#examples-stylenonnilcheck]
=== Examples

[source,ruby]
----
# bad
if x != nil
end

# good
if x
end

# Non-nil checks are allowed if they are the final nodes of predicate.
# good
def signed_in?
  !current_user.nil?
end
----

[#includesemanticchanges_-false-_default_-stylenonnilcheck]
==== IncludeSemanticChanges: false (default)

[source,ruby]
----
# good
if !x.nil?
end
----

[#includesemanticchanges_-true-stylenonnilcheck]
==== IncludeSemanticChanges: true

[source,ruby]
----
# bad
if !x.nil?
end
----

[#configurable-attributes-stylenonnilcheck]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| IncludeSemanticChanges
| `false`
| Boolean
|===

[#references-stylenonnilcheck]
=== References

* https://rubystyle.guide#no-non-nil-checks

[#stylenot]
== Style/Not

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.20
|===

Checks for uses of the keyword `not` instead of `!`.

[#examples-stylenot]
=== Examples

[source,ruby]
----
# bad - parentheses are required because of op precedence
x = (not something)

# good
x = !something
----

[#references-stylenot]
=== References

* https://rubystyle.guide#bang-not-not

[#stylenumberedparameters]
== Style/NumberedParameters

NOTE: Requires Ruby version 2.7

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| No
| 1.22
| -
|===

Checks for numbered parameters.

It can either restrict the use of numbered parameters to
single-lined blocks, or disallow completely numbered parameters.

[#examples-stylenumberedparameters]
=== Examples

[#enforcedstyle_-allow_single_line-_default_-stylenumberedparameters]
==== EnforcedStyle: allow_single_line (default)

[source,ruby]
----
# bad
collection.each do
  puts _1
end

# good
collection.each { puts _1 }
----

[#enforcedstyle_-disallow-stylenumberedparameters]
==== EnforcedStyle: disallow

[source,ruby]
----
# bad
collection.each { puts _1 }

# good
collection.each { |item| puts item }
----

[#configurable-attributes-stylenumberedparameters]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `allow_single_line`
| `allow_single_line`, `disallow`
|===

[#stylenumberedparameterslimit]
== Style/NumberedParametersLimit

NOTE: Requires Ruby version 2.7

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| No
| 1.22
| -
|===

Detects use of an excessive amount of numbered parameters in a
single block. Having too many numbered parameters can make code too
cryptic and hard to read.

The cop defaults to registering an offense if there is more than 1 numbered
parameter but this maximum can be configured by setting `Max`.

[#examples-stylenumberedparameterslimit]
=== Examples

[#max_-1-_default_-stylenumberedparameterslimit]
==== Max: 1 (default)

[source,ruby]
----
# bad
use_multiple_numbered_parameters { _1.call(_2, _3, _4) }

# good
array.each { use_array_element_as_numbered_parameter(_1) }
hash.each { use_only_hash_value_as_numbered_parameter(_2) }
----

[#configurable-attributes-stylenumberedparameterslimit]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| Max
| `1`
| Integer
|===

[#stylenumericliteralprefix]
== Style/NumericLiteralPrefix

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.41
| -
|===

Checks for octal, hex, binary, and decimal literals using
uppercase prefixes and corrects them to lowercase prefix
or no prefix (in case of decimals).

[#examples-stylenumericliteralprefix]
=== Examples

[#enforcedoctalstyle_-zero_with_o-_default_-stylenumericliteralprefix]
==== EnforcedOctalStyle: zero_with_o (default)

[source,ruby]
----
# bad - missing octal prefix
num = 01234

# bad - uppercase prefix
num = 0O1234
num = 0X12AB
num = 0B10101

# bad - redundant decimal prefix
num = 0D1234
num = 0d1234

# good
num = 0o1234
num = 0x12AB
num = 0b10101
num = 1234
----

[#enforcedoctalstyle_-zero_only-stylenumericliteralprefix]
==== EnforcedOctalStyle: zero_only

[source,ruby]
----
# bad
num = 0o1234
num = 0O1234

# good
num = 01234
----

[#configurable-attributes-stylenumericliteralprefix]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedOctalStyle
| `zero_with_o`
| `zero_with_o`, `zero_only`
|===

[#references-stylenumericliteralprefix]
=== References

* https://rubystyle.guide#numeric-literal-prefixes

[#stylenumericliterals]
== Style/NumericLiterals

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.48
|===

Checks for big numeric literals without `_` between groups
of digits in them.

Additional allowed patterns can be added by adding regexps to
the `AllowedPatterns` configuration. All regexps are treated
as anchored even if the patterns do not contain anchors (so
`\d{4}_\d{4}` will allow `1234_5678` but not `1234_5678_9012`).

NOTE: Even if `AllowedPatterns` are given, autocorrection will
only correct to the standard pattern of an `_` every 3 digits.

[#examples-stylenumericliterals]
=== Examples

[source,ruby]
----
# bad
1000000
1_00_000
1_0000

# good
1_000_000
1000
----

[#strict_-false-_default_-stylenumericliterals]
==== Strict: false (default)

[source,ruby]
----
# good
10_000_00 # typical representation of $10,000 in cents
----

[#strict_-true-stylenumericliterals]
==== Strict: true

[source,ruby]
----
# bad
10_000_00 # typical representation of $10,000 in cents
----

[#allowednumbers_-_3000_-stylenumericliterals]
==== AllowedNumbers: [3000]

[source,ruby]
----
# good
3000 # You can specify allowed numbers. (e.g. port number)
----

[#configurable-attributes-stylenumericliterals]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| MinDigits
| `5`
| Integer

| Strict
| `false`
| Boolean

| AllowedNumbers
| `[]`
| Array

| AllowedPatterns
| `[]`
| Array
|===

[#references-stylenumericliterals]
=== References

* https://rubystyle.guide#underscores-in-numerics

[#stylenumericpredicate]
== Style/NumericPredicate

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.42
| 0.59
|===

Checks for usage of comparison operators (`==`,
`>`, `<`) to test numbers as zero, positive, or negative.
These can be replaced by their respective predicate methods.
This cop can also be configured to do the reverse.

This cop's allowed methods can be customized with `AllowedMethods`.
By default, there are no allowed methods.

This cop disregards `#nonzero?` as its value is truthy or falsey,
but not `true` and `false`, and thus not always interchangeable with
`!= 0`.

This cop allows comparisons to global variables, since they are often
populated with objects which can be compared with integers, but are
not themselves `Integer` polymorphic.

[#safety-stylenumericpredicate]
=== Safety

This cop is unsafe because it cannot be guaranteed that the receiver
defines the predicates or can be compared to a number, which may lead
to a false positive for non-standard classes.

[#examples-stylenumericpredicate]
=== Examples

[#enforcedstyle_-predicate-_default_-stylenumericpredicate]
==== EnforcedStyle: predicate (default)

[source,ruby]
----
# bad
foo == 0
0 > foo
bar.baz > 0

# good
foo.zero?
foo.negative?
bar.baz.positive?
----

[#enforcedstyle_-comparison-stylenumericpredicate]
==== EnforcedStyle: comparison

[source,ruby]
----
# bad
foo.zero?
foo.negative?
bar.baz.positive?

# good
foo == 0
0 > foo
bar.baz > 0
----

[#allowedmethods_-__-_default_-with-enforcedstyle_-predicate-stylenumericpredicate]
==== AllowedMethods: [] (default) with EnforcedStyle: predicate

[source,ruby]
----
# bad
foo == 0
0 > foo
bar.baz > 0
----

[#allowedmethods_-____-with-enforcedstyle_-predicate-stylenumericpredicate]
==== AllowedMethods: [==] with EnforcedStyle: predicate

[source,ruby]
----
# good
foo == 0

# bad
0 > foo
bar.baz > 0
----

[#allowedpatterns_-__-_default_-with-enforcedstyle_-comparison-stylenumericpredicate]
==== AllowedPatterns: [] (default) with EnforcedStyle: comparison

[source,ruby]
----
# bad
foo.zero?
foo.negative?
bar.baz.positive?
----

[#allowedpatterns_-__zero__-with-enforcedstyle_-predicate-stylenumericpredicate]
==== AllowedPatterns: ['zero'] with EnforcedStyle: predicate

[source,ruby]
----
# good
# bad
foo.zero?

# bad
foo.negative?
bar.baz.positive?
----

[#configurable-attributes-stylenumericpredicate]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `predicate`
| `predicate`, `comparison`

| AllowedMethods
| `[]`
| Array

| AllowedPatterns
| `[]`
| Array

| Exclude
| `+spec/**/*+`
| Array
|===

[#references-stylenumericpredicate]
=== References

* https://rubystyle.guide#predicate-methods

[#styleobjectthen]
== Style/ObjectThen

NOTE: Requires Ruby version 2.6

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.28
| -
|===

Enforces the use of consistent method names
`Object#yield_self` or `Object#then`.

[#examples-styleobjectthen]
=== Examples

[#enforcedstyle_-then-_default_-styleobjectthen]
==== EnforcedStyle: then (default)

[source,ruby]
----
# bad
obj.yield_self { |x| x.do_something }

# good
obj.then { |x| x.do_something }
----

[#enforcedstyle_-yield_self-styleobjectthen]
==== EnforcedStyle: yield_self

[source,ruby]
----
# bad
obj.then { |x| x.do_something }

# good
obj.yield_self { |x| x.do_something }
----

[#configurable-attributes-styleobjectthen]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `then`
| `then`, `yield_self`
|===

[#references-styleobjectthen]
=== References

* https://rubystyle.guide#object-yield-self-vs-object-then

[#styleonelineconditional]
== Style/OneLineConditional

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.90
|===

Checks for uses of if/then/else/end constructs on a single line.
`AlwaysCorrectToMultiline` config option can be set to true to autocorrect all offenses to
multi-line constructs. When `AlwaysCorrectToMultiline` is false (default case) the
autocorrect will first try converting them to ternary operators.

[#examples-styleonelineconditional]
=== Examples

[source,ruby]
----
# bad
if foo then bar else baz end

# bad
unless foo then baz else bar end

# good
foo ? bar : baz

# good
bar if foo

# good
if foo then bar end

# good
if foo
  bar
else
  baz
end
----

[#alwayscorrecttomultiline_-false-_default_-styleonelineconditional]
==== AlwaysCorrectToMultiline: false (default)

[source,ruby]
----
# bad
if cond then run else dont end

# good
cond ? run : dont
----

[#alwayscorrecttomultiline_-true-styleonelineconditional]
==== AlwaysCorrectToMultiline: true

[source,ruby]
----
# bad
if cond then run else dont end

# good
if cond
  run
else
  dont
end
----

[#configurable-attributes-styleonelineconditional]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AlwaysCorrectToMultiline
| `false`
| Boolean
|===

[#references-styleonelineconditional]
=== References

* https://rubystyle.guide#ternary-operator

[#styleopenstructuse]
== Style/OpenStructUse

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| No
| 1.23
| 1.51
|===

Flags uses of `OpenStruct`, as it is now officially discouraged
to be used for performance, version compatibility, and potential security issues.

[#safety-styleopenstructuse]
=== Safety

Note that this cop may flag false positives; for instance, the following legal
use of a hand-rolled `OpenStruct` type would be considered an offense:

[source,ruby]
-----
module MyNamespace
  class OpenStruct # not the OpenStruct we're looking for
  end

  def new_struct
    OpenStruct.new # resolves to MyNamespace::OpenStruct
  end
end
-----

[#examples-styleopenstructuse]
=== Examples

[source,ruby]
----
# bad
point = OpenStruct.new(x: 0, y: 1)

# good
Point = Struct.new(:x, :y)
point = Point.new(0, 1)

# also good
point = { x: 0, y: 1 }

# bad
test_double = OpenStruct.new(a: 'b')

# good (assumes test using rspec-mocks)
test_double = double
allow(test_double).to receive(:a).and_return('b')
----

[#references-styleopenstructuse]
=== References

* https://docs.ruby-lang.org/en/3.0/OpenStruct.html#class-OpenStruct-label-Caveats

[#styleoperatormethodcall]
== Style/OperatorMethodCall

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.37
| -
|===

Checks for redundant dot before operator method call.
The target operator methods are `|`, `^`, `&`, ``<=>``, `==`, `===`, `=~`, `>`, `>=`, `<`,
``<=``, `<<`, `>>`, `+`, `-`, `*`, `/`, `%`, `**`, `~`, `!`, `!=`, and `!~`.

[#examples-styleoperatormethodcall]
=== Examples

[source,ruby]
----
# bad
foo.+ bar
foo.& bar

# good
foo + bar
foo & bar
----

[#references-styleoperatormethodcall]
=== References

* https://rubystyle.guide#operator-method-call

[#styleoptionhash]
== Style/OptionHash

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.33
| 0.34
|===

Checks for options hashes and discourages them if the
current Ruby version supports keyword arguments.

[#examples-styleoptionhash]
=== Examples

[source,ruby]
----
# bad
def fry(options = {})
  temperature = options.fetch(:temperature, 300)
  # ...
end

# good
def fry(temperature: 300)
  # ...
end
----

[#configurable-attributes-styleoptionhash]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| SuspiciousParamNames
| `options`, `opts`, `args`, `params`, `parameters`
| Array

| Allowlist
| `[]`
| Array
|===

[#references-styleoptionhash]
=== References

* https://rubystyle.guide#keyword-arguments-vs-option-hashes

[#styleoptionalarguments]
== Style/OptionalArguments

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| No
| 0.33
| 0.83
|===

Checks for optional arguments to methods
that do not come at the end of the argument list.

[#safety-styleoptionalarguments]
=== Safety

This cop is unsafe because changing a method signature will
implicitly change behavior.

[#examples-styleoptionalarguments]
=== Examples

[source,ruby]
----
# bad
def foo(a = 1, b, c)
end

# good
def baz(a, b, c = 1)
end

def foobar(a = 1, b = 2, c = 3)
end
----

[#references-styleoptionalarguments]
=== References

* https://rubystyle.guide#optional-arguments

[#styleoptionalbooleanparameter]
== Style/OptionalBooleanParameter

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| No
| 0.89
| -
|===

Checks for places where keyword arguments can be used instead of
boolean arguments when defining methods. `respond_to_missing?` method is allowed by default.
These are customizable with `AllowedMethods` option.

[#safety-styleoptionalbooleanparameter]
=== Safety

This cop is unsafe because changing a method signature will
implicitly change behavior.

[#examples-styleoptionalbooleanparameter]
=== Examples

[source,ruby]
----
# bad
def some_method(bar = false)
  puts bar
end

# bad - common hack before keyword args were introduced
def some_method(options = {})
  bar = options.fetch(:bar, false)
  puts bar
end

# good
def some_method(bar: false)
  puts bar
end
----

[#allowedmethods_-__some_method__-styleoptionalbooleanparameter]
==== AllowedMethods: ['some_method']

[source,ruby]
----
# good
def some_method(bar = false)
  puts bar
end
----

[#configurable-attributes-styleoptionalbooleanparameter]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedMethods
| `respond_to_missing?`
| Array
|===

[#references-styleoptionalbooleanparameter]
=== References

* https://rubystyle.guide#boolean-keyword-arguments

[#styleorassignment]
== Style/OrAssignment

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.50
| -
|===

Checks for potential usage of the `||=` operator.

[#examples-styleorassignment]
=== Examples

[source,ruby]
----
# bad
name = name ? name : 'Bozhidar'

# bad
name = if name
         name
       else
         'Bozhidar'
       end

# bad
unless name
  name = 'Bozhidar'
end

# bad
name = 'Bozhidar' unless name

# good - set name to 'Bozhidar', only if it's nil or false
name ||= 'Bozhidar'
----

[#references-styleorassignment]
=== References

* https://rubystyle.guide#double-pipe-for-uninit

[#styleparallelassignment]
== Style/ParallelAssignment

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.32
| -
|===

Checks for simple usages of parallel assignment.
This will only complain when the number of variables
being assigned matched the number of assigning variables.

[#examples-styleparallelassignment]
=== Examples

[source,ruby]
----
# bad
a, b, c = 1, 2, 3
a, b, c = [1, 2, 3]

# good
one, two = *foo
a, b = foo()
a, b = b, a

a = 1
b = 2
c = 3
----

[#references-styleparallelassignment]
=== References

* https://rubystyle.guide#parallel-assignment

[#styleparenthesesaroundcondition]
== Style/ParenthesesAroundCondition

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.56
|===

Checks for the presence of superfluous parentheses around the
condition of if/unless/while/until.

`AllowSafeAssignment` option for safe assignment.
By safe assignment we mean putting parentheses around
an assignment to indicate "I know I'm using an assignment
as a condition. It's not a mistake."

[#examples-styleparenthesesaroundcondition]
=== Examples

[source,ruby]
----
# bad
x += 1 while (x < 10)
foo unless (bar || baz)

if (x > 10)
elsif (x < 3)
end

# good
x += 1 while x < 10
foo unless bar || baz

if x > 10
elsif x < 3
end
----

[#allowsafeassignment_-true-_default_-styleparenthesesaroundcondition]
==== AllowSafeAssignment: true (default)

[source,ruby]
----
# good
foo unless (bar = baz)
----

[#allowsafeassignment_-false-styleparenthesesaroundcondition]
==== AllowSafeAssignment: false

[source,ruby]
----
# bad
foo unless (bar = baz)
----

[#allowinmultilineconditions_-false-_default_-styleparenthesesaroundcondition]
==== AllowInMultilineConditions: false (default)

[source,ruby]
----
# bad
if (x > 10 &&
   y > 10)
end

# good
 if x > 10 &&
    y > 10
 end
----

[#allowinmultilineconditions_-true-styleparenthesesaroundcondition]
==== AllowInMultilineConditions: true

[source,ruby]
----
# good
if (x > 10 &&
   y > 10)
end
----

[#configurable-attributes-styleparenthesesaroundcondition]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowSafeAssignment
| `true`
| Boolean

| AllowInMultilineConditions
| `false`
| Boolean
|===

[#references-styleparenthesesaroundcondition]
=== References

* https://rubystyle.guide#no-parens-around-condition

[#stylepercentliteraldelimiters]
== Style/PercentLiteralDelimiters

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.19
| 0.48
|===

Enforces the consistent usage of `%`-literal delimiters.

Specify the 'default' key to set all preferred delimiters at once. You
can continue to specify individual preferred delimiters to override the
default.

[#examples-stylepercentliteraldelimiters]
=== Examples

[source,ruby]
----
# Style/PercentLiteralDelimiters:
#   PreferredDelimiters:
#     default: '[]'
#     '%i':    '()'

# good
%w[alpha beta] + %i(gamma delta)

# bad
%W(alpha #{beta})

# bad
%I(alpha beta)
----

[#configurable-attributes-stylepercentliteraldelimiters]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| PreferredDelimiters
| `{"default" => "()", "%i" => "[]", "%I" => "[]", "%r" => "{}", "%w" => "[]", "%W" => "[]"}`
| 
|===

[#references-stylepercentliteraldelimiters]
=== References

* https://rubystyle.guide#percent-literal-braces

[#stylepercentqliterals]
== Style/PercentQLiterals

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.25
| -
|===

Checks for usage of the %Q() syntax when %q() would do.

[#examples-stylepercentqliterals]
=== Examples

[#enforcedstyle_-lower_case_q-_default_-stylepercentqliterals]
==== EnforcedStyle: lower_case_q (default)

[source,ruby]
----
# The `lower_case_q` style prefers `%q` unless
# interpolation is needed.
# bad
%Q[Mix the foo into the baz.]
%Q(They all said: 'Hooray!')

# good
%q[Mix the foo into the baz]
%q(They all said: 'Hooray!')
----

[#enforcedstyle_-upper_case_q-stylepercentqliterals]
==== EnforcedStyle: upper_case_q

[source,ruby]
----
# The `upper_case_q` style requires the sole use of `%Q`.
# bad
%q/Mix the foo into the baz./
%q{They all said: 'Hooray!'}

# good
%Q/Mix the foo into the baz./
%Q{They all said: 'Hooray!'}
----

[#configurable-attributes-stylepercentqliterals]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `lower_case_q`
| `lower_case_q`, `upper_case_q`
|===

[#styleperlbackrefs]
== Style/PerlBackrefs

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.13
| -
|===

Looks for uses of Perl-style regexp match
backreferences and their English versions like
$1, $2, $&, &+, $MATCH, $PREMATCH, etc.

[#examples-styleperlbackrefs]
=== Examples

[source,ruby]
----
# bad
puts $1

# good
puts Regexp.last_match(1)
----

[#references-styleperlbackrefs]
=== References

* https://rubystyle.guide#no-perl-regexp-last-matchers

[#stylepreferredhashmethods]
== Style/PreferredHashMethods

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.41
| 0.70
|===

Checks for uses of methods `Hash#has_key?` and
`Hash#has_value?`, and suggests using `Hash#key?` and `Hash#value?` instead.

It is configurable to enforce the verbose method names, by using the
`EnforcedStyle: verbose` configuration.

[#safety-stylepreferredhashmethods]
=== Safety

This cop is unsafe because it cannot be guaranteed that the receiver
is a `Hash` or responds to the replacement methods.

[#examples-stylepreferredhashmethods]
=== Examples

[#enforcedstyle_-short-_default_-stylepreferredhashmethods]
==== EnforcedStyle: short (default)

[source,ruby]
----
# bad
Hash#has_key?
Hash#has_value?

# good
Hash#key?
Hash#value?
----

[#enforcedstyle_-verbose-stylepreferredhashmethods]
==== EnforcedStyle: verbose

[source,ruby]
----
# bad
Hash#key?
Hash#value?

# good
Hash#has_key?
Hash#has_value?
----

[#configurable-attributes-stylepreferredhashmethods]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `short`
| `short`, `verbose`
|===

[#references-stylepreferredhashmethods]
=== References

* https://rubystyle.guide#hash-key

[#styleproc]
== Style/Proc

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.18
|===

Checks for uses of Proc.new where Kernel#proc
would be more appropriate.

[#examples-styleproc]
=== Examples

[source,ruby]
----
# bad
p = Proc.new { |n| puts n }

# good
p = proc { |n| puts n }
----

[#references-styleproc]
=== References

* https://rubystyle.guide#proc

[#stylequotedsymbols]
== Style/QuotedSymbols

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.16
| -
|===

Checks if the quotes used for quoted symbols match the configured defaults.
By default uses the same configuration as `Style/StringLiterals`; if that
cop is not enabled, the default `EnforcedStyle` is `single_quotes`.

String interpolation is always kept in double quotes.

NOTE: `Lint/SymbolConversion` can be used in parallel to ensure that symbols
are not quoted that don't need to be. This cop is for configuring the quoting
style to use for symbols that require quotes.

[#examples-stylequotedsymbols]
=== Examples

[#enforcedstyle_-same_as_string_literals-_default_--single_quotes-stylequotedsymbols]
==== EnforcedStyle: same_as_string_literals (default) / single_quotes

[source,ruby]
----
# bad
:"abc-def"

# good
:'abc-def'
:"#{str}"
:"a\'b"
----

[#enforcedstyle_-double_quotes-stylequotedsymbols]
==== EnforcedStyle: double_quotes

[source,ruby]
----
# bad
:'abc-def'

# good
:"abc-def"
:"#{str}"
:"a\'b"
----

[#configurable-attributes-stylequotedsymbols]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `same_as_string_literals`
| `same_as_string_literals`, `single_quotes`, `double_quotes`
|===

[#styleraiseargs]
== Style/RaiseArgs

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.14
| 1.61
|===

Checks the args passed to `fail` and `raise`.

Exploded style (default) enforces passing the exception class and message
arguments separately, rather than constructing an instance of the error.

Compact style enforces constructing an error instance.

Both styles allow passing just a message, or an error instance when there is more
than one argument.

The exploded style has an `AllowedCompactTypes` configuration
option that takes an `Array` of exception name Strings.

[#safety-styleraiseargs]
=== Safety

This cop is unsafe because `raise Foo` calls `Foo.exception`, not `Foo.new`.

[#examples-styleraiseargs]
=== Examples

[#enforcedstyle_-exploded-_default_-styleraiseargs]
==== EnforcedStyle: exploded (default)

[source,ruby]
----
# bad
raise StandardError.new('message')

# good
raise StandardError, 'message'
fail 'message'
raise MyCustomError
raise MyCustomError.new(arg1, arg2, arg3)
raise MyKwArgError.new(key1: val1, key2: val2)

# With `AllowedCompactTypes` set to ['MyWrappedError']
raise MyWrappedError.new(obj)
raise MyWrappedError.new(obj), 'message'
----

[#enforcedstyle_-compact-styleraiseargs]
==== EnforcedStyle: compact

[source,ruby]
----
# bad
raise StandardError, 'message'
raise RuntimeError, arg1, arg2, arg3

# good
raise StandardError.new('message')
raise MyCustomError
raise MyCustomError.new(arg1, arg2, arg3)
fail 'message'
----

[#configurable-attributes-styleraiseargs]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `exploded`
| `compact`, `exploded`

| AllowedCompactTypes
| `[]`
| Array
|===

[#references-styleraiseargs]
=== References

* https://rubystyle.guide#exception-class-messages

[#stylerandomwithoffset]
== Style/RandomWithOffset

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.52
| -
|===

Checks for the use of randomly generated numbers,
added/subtracted with integer literals, as well as those with
Integer#succ and Integer#pred methods. Prefer using ranges instead,
as it clearly states the intentions.

[#examples-stylerandomwithoffset]
=== Examples

[source,ruby]
----
# bad
rand(6) + 1
1 + rand(6)
rand(6) - 1
1 - rand(6)
rand(6).succ
rand(6).pred
Random.rand(6) + 1
Kernel.rand(6) + 1
rand(0..5) + 1

# good
rand(1..6)
rand(1...7)
----

[#references-stylerandomwithoffset]
=== References

* https://rubystyle.guide#random-numbers

[#styleredundantargument]
== Style/RedundantArgument

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.4
| 1.55
|===

Checks for a redundant argument passed to certain methods.

NOTE: This cop is limited to methods with single parameter.

Method names and their redundant arguments can be configured like this:

[source,yaml]
----
Methods:
  join: ''
  sum: 0
  split: ' '
  chomp: "\n"
  chomp!: "\n"
  foo: 2
----

[#safety-styleredundantargument]
=== Safety

This cop is unsafe because of the following limitations:

1. This cop matches by method names only and hence cannot tell apart
   methods with same name in different classes.
2. This cop may be unsafe if certain special global variables (e.g. `$;`, `$/`) are set.
   That depends on the nature of the target methods, of course. For example, the default
   argument to join is `$OUTPUT_FIELD_SEPARATOR` (or `$,`) rather than `''`, and if that
   global is changed, `''` is no longer a redundant argument.

[#examples-styleredundantargument]
=== Examples

[source,ruby]
----
# bad
array.join('')
[1, 2, 3].join("")
array.sum(0)
exit(true)
exit!(false)
string.split(" ")
"first\nsecond".split(" ")
string.chomp("\n")
string.chomp!("\n")
A.foo(2)

# good
array.join
[1, 2, 3].join
array.sum
exit
exit!
string.split
"first second".split
string.chomp
string.chomp!
A.foo
----

[#configurable-attributes-styleredundantargument]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| Methods
| `{"join" => "", "sum" => 0, "exit" => true, "exit!" => false, "split" => " ", "chomp" => "\n", "chomp!" => "\n"}`
| 
|===

[#styleredundantarrayconstructor]
== Style/RedundantArrayConstructor

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.52
| -
|===

Checks for the instantiation of array using redundant `Array` constructor.
Autocorrect replaces to array literal which is the simplest and fastest.

[#examples-styleredundantarrayconstructor]
=== Examples

[source,ruby]
----
# bad
Array.new([])
Array[]
Array([])
Array.new(['foo', 'foo', 'foo'])
Array['foo', 'foo', 'foo']
Array(['foo', 'foo', 'foo'])

# good
[]
['foo', 'foo', 'foo']
Array.new(3, 'foo')
Array.new(3) { 'foo' }
----

[#styleredundantarrayflatten]
== Style/RedundantArrayFlatten

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.76
| -
|===

Checks for redundant calls of `Array#flatten`.

`Array#join` joins nested arrays recursively, so flattening an array
beforehand is redundant.

[#safety-styleredundantarrayflatten]
=== Safety

Cop is unsafe because the receiver of `flatten` method might not
be an `Array`, so it's possible it won't respond to `join` method,
or the end result would be different.
Also, if the global variable `$,` is set to a value other than the default `nil`,
false positives may occur.

[#examples-styleredundantarrayflatten]
=== Examples

[source,ruby]
----
# bad
x.flatten.join
x.flatten(1).join

# good
x.join
----

[#styleredundantassignment]
== Style/RedundantAssignment

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.87
| -
|===

Checks for redundant assignment before returning.

[#examples-styleredundantassignment]
=== Examples

[source,ruby]
----
# bad
def test
  x = foo
  x
end

# bad
def test
  if x
    z = foo
    z
  elsif y
    z = bar
    z
  end
end

# good
def test
  foo
end

# good
def test
  if x
    foo
  elsif y
    bar
  end
end
----

[#styleredundantbegin]
== Style/RedundantBegin

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.10
| 0.21
|===

Checks for redundant `begin` blocks.

Currently it checks for code like this:

[#examples-styleredundantbegin]
=== Examples

[source,ruby]
----
# bad
def redundant
  begin
    ala
    bala
  rescue StandardError => e
    something
  end
end

# good
def preferred
  ala
  bala
rescue StandardError => e
  something
end

# bad
begin
  do_something
end

# good
do_something

# bad
# When using Ruby 2.5 or later.
do_something do
  begin
    something
  rescue => ex
    anything
  end
end

# good
# In Ruby 2.5 or later, you can omit `begin` in `do-end` block.
do_something do
  something
rescue => ex
  anything
end

# good
# Stabby lambdas don't support implicit `begin` in `do-end` blocks.
-> do
  begin
    foo
  rescue Bar
    baz
  end
end
----

[#references-styleredundantbegin]
=== References

* https://rubystyle.guide#begin-implicit

[#styleredundantcapitalw]
== Style/RedundantCapitalW

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.76
| -
|===

Checks for usage of the %W() syntax when %w() would do.

[#examples-styleredundantcapitalw]
=== Examples

[source,ruby]
----
# bad
%W(cat dog pig)
%W[door wall floor]

# good
%w/swim run bike/
%w[shirt pants shoes]
%W(apple #{fruit} grape)
----

[#styleredundantcondition]
== Style/RedundantCondition

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.76
| 1.73
|===

Checks for unnecessary conditional expressions.

NOTE: Since the intention of the comment cannot be automatically determined,
autocorrection is not applied when a comment is used, as shown below:

[source,ruby]
-----
if b
  # Important note.
  b
else
  c
end
-----

[#examples-styleredundantcondition]
=== Examples

[source,ruby]
----
# bad
a = b ? b : c

# good
a = b || c

# bad
if b
  b
else
  c
end

# good
b || c

# good
if b
  b
elsif cond
  c
end

# bad
a.nil? ? true : a

# good
a.nil? || a

# bad
if a.nil?
  true
else
  a
end

# good
a.nil? || a
----

[#allowedmethods_-__nonzero___-_default_-styleredundantcondition]
==== AllowedMethods: ['nonzero?'] (default)

[source,ruby]
----
# good
num.nonzero? ? true : false
----

[#configurable-attributes-styleredundantcondition]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedMethods
| `nonzero?`
| Array
|===

[#styleredundantconditional]
== Style/RedundantConditional

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.50
| -
|===

Checks for redundant returning of true/false in conditionals.

[#examples-styleredundantconditional]
=== Examples

[source,ruby]
----
# bad
x == y ? true : false

# bad
if x == y
  true
else
  false
end

# good
x == y

# bad
x == y ? false : true

# good
x != y
----

[#styleredundantconstantbase]
== Style/RedundantConstantBase

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.40
| -
|===

Avoid redundant `::` prefix on constant.

How Ruby searches constant is a bit complicated, and it can often be difficult to
understand from the code whether the `::` is intended or not. Where `Module.nesting`
is empty, there is no need to prepend `::`, so it would be nice to consistently
avoid such meaningless `::` prefix to avoid confusion.

NOTE: This cop is disabled if `Lint/ConstantResolution` cop is enabled to prevent
conflicting rules. Because it respects user configurations that want to enable
`Lint/ConstantResolution` cop which is disabled by default.

[#examples-styleredundantconstantbase]
=== Examples

[source,ruby]
----
# bad
::Const

# good
Const

# bad
class << self
  ::Const
end

# good
class << self
  Const
end

# good
class A
  ::Const
end

# good
module A
  ::Const
end
----

[#styleredundantcurrentdirectoryinpath]
== Style/RedundantCurrentDirectoryInPath

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.53
| -
|===

Checks for paths given to `require_relative` that start with
the current directory (`./`), which can be omitted.

[#examples-styleredundantcurrentdirectoryinpath]
=== Examples

[source,ruby]
----
# bad
require_relative './path/to/feature'

# good
require_relative 'path/to/feature'
----

[#styleredundantdoublesplathashbraces]
== Style/RedundantDoubleSplatHashBraces

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.41
| -
|===

Checks for redundant uses of double splat hash braces.

[#examples-styleredundantdoublesplathashbraces]
=== Examples

[source,ruby]
----
# bad
do_something(**{foo: bar, baz: qux})

# good
do_something(foo: bar, baz: qux)

# bad
do_something(**{foo: bar, baz: qux}.merge(options))

# good
do_something(foo: bar, baz: qux, **options)
----

[#styleredundanteach]
== Style/RedundantEach

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.38
| -
|===

Checks for redundant `each`.

[#safety-styleredundanteach]
=== Safety

This cop is unsafe, as it can produce false positives if the receiver
is not an `Enumerator`.

[#examples-styleredundanteach]
=== Examples

[source,ruby]
----
# bad
array.each.each { |v| do_something(v) }

# good
array.each { |v| do_something(v) }

# bad
array.each.each_with_index { |v, i| do_something(v, i) }

# good
array.each.with_index { |v, i| do_something(v, i) }
array.each_with_index { |v, i| do_something(v, i) }

# bad
array.each.each_with_object { |v, o| do_something(v, o) }

# good
array.each.with_object { |v, o| do_something(v, o) }
array.each_with_object { |v, o| do_something(v, o) }
----

[#styleredundantexception]
== Style/RedundantException

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.14
| 0.29
|===

Checks for `RuntimeError` as the argument of `raise`/`fail`.

[#examples-styleredundantexception]
=== Examples

[source,ruby]
----
# bad
raise RuntimeError, 'message'
raise RuntimeError.new('message')

# good
raise 'message'

# bad - message is not a string
raise RuntimeError, Object.new
raise RuntimeError.new(Object.new)

# good
raise Object.new.to_s
----

[#references-styleredundantexception]
=== References

* https://rubystyle.guide#no-explicit-runtimeerror

[#styleredundantfetchblock]
== Style/RedundantFetchBlock

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.86
| -
|===

Identifies places where `fetch(key) { value }` can be replaced by `fetch(key, value)`.

In such cases `fetch(key, value)` method is faster than `fetch(key) { value }`.

NOTE: The block string `'value'` in `hash.fetch(:key) { 'value' }` is detected
when frozen string literal magic comment is enabled (i.e. `# frozen_string_literal: true`),
but not when disabled.

[#safety-styleredundantfetchblock]
=== Safety

This cop is unsafe because it cannot be guaranteed that the receiver
does not have a different implementation of `fetch`.

[#examples-styleredundantfetchblock]
=== Examples

[#safeforconstants_-false-_default_-styleredundantfetchblock]
==== SafeForConstants: false (default)

[source,ruby]
----
# bad
hash.fetch(:key) { 5 }
hash.fetch(:key) { true }
hash.fetch(:key) { nil }
array.fetch(5) { :value }
ENV.fetch(:key) { 'value' }

# good
hash.fetch(:key, 5)
hash.fetch(:key, true)
hash.fetch(:key, nil)
array.fetch(5, :value)
ENV.fetch(:key, 'value')
----

[#safeforconstants_-true-styleredundantfetchblock]
==== SafeForConstants: true

[source,ruby]
----
# bad
ENV.fetch(:key) { VALUE }

# good
ENV.fetch(:key, VALUE)
----

[#configurable-attributes-styleredundantfetchblock]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| SafeForConstants
| `false`
| Boolean
|===

[#references-styleredundantfetchblock]
=== References

* https://github.com/fastruby/fast-ruby#hashfetch-with-argument-vs-hashfetch--block-code

[#styleredundantfileextensioninrequire]
== Style/RedundantFileExtensionInRequire

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.88
| -
|===

Checks for the presence of superfluous `.rb` extension in
the filename provided to `require` and `require_relative`.

NOTE: If the extension is omitted, Ruby tries adding '.rb', '.so',
      and so on to the name until found. If the file named cannot be found,
      a `LoadError` will be raised.
      There is an edge case where `foo.so` file is loaded instead of a `LoadError`
      if `foo.so` file exists when `require 'foo.rb'` will be changed to `require 'foo'`,
      but that seems harmless.

[#examples-styleredundantfileextensioninrequire]
=== Examples

[source,ruby]
----
# bad
require 'foo.rb'
require_relative '../foo.rb'

# good
require 'foo'
require 'foo.so'
require_relative '../foo'
require_relative '../foo.so'
----

[#references-styleredundantfileextensioninrequire]
=== References

* https://rubystyle.guide#no-explicit-rb-to-require

[#styleredundantfilterchain]
== Style/RedundantFilterChain

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always (Unsafe)
| 1.52
| 1.57
|===

Identifies usages of `any?`, `empty?` or `none?` predicate methods
chained to `select`/`filter`/`find_all` and change them to use predicate method instead.

[#safety-styleredundantfilterchain]
=== Safety

This cop's autocorrection is unsafe because `array.select.any?` evaluates all elements
through the `select` method, while `array.any?` uses short-circuit evaluation.
In other words, `array.select.any?` guarantees the evaluation of every element,
but `array.any?` does not necessarily evaluate all of them.

[#examples-styleredundantfilterchain]
=== Examples

[source,ruby]
----
# bad
arr.select { |x| x > 1 }.any?

# good
arr.any? { |x| x > 1 }

# bad
arr.select { |x| x > 1 }.empty?
arr.select { |x| x > 1 }.none?

# good
arr.none? { |x| x > 1 }

# good
relation.select(:name).any?
arr.select { |x| x > 1 }.any?(&:odd?)
----

[#allcops_activesupportextensionsenabled_-false-_default_-styleredundantfilterchain]
==== AllCops:ActiveSupportExtensionsEnabled: false (default)

[source,ruby]
----
# good
arr.select { |x| x > 1 }.many?

# good
arr.select { |x| x > 1 }.present?
----

[#allcops_activesupportextensionsenabled_-true-styleredundantfilterchain]
==== AllCops:ActiveSupportExtensionsEnabled: true

[source,ruby]
----
# bad
arr.select { |x| x > 1 }.many?

# good
arr.many? { |x| x > 1 }

# bad
arr.select { |x| x > 1 }.present?

# good
arr.any? { |x| x > 1 }
----

[#styleredundantformat]
== Style/RedundantFormat

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always (Unsafe)
| 1.72
| 1.72
|===

Checks for calls to `Kernel#format` or `Kernel#sprintf` that are redundant.

Calling `format` with only a single string or constant argument is redundant,
as it can be replaced by the string or constant itself.

Also looks for `format` calls where the arguments are literals that can be
inlined into a string easily. This applies to the `%s`, `%d`, `%i`, `%u`, and
`%f` format specifiers.

[#safety-styleredundantformat]
=== Safety

This cop's autocorrection is unsafe because string object returned by
`format` and `sprintf` are never frozen. If `format('string')` is autocorrected to
`'string'`, `FrozenError` may occur when calling a destructive method like `String#<<`.
Consider using `'string'.dup` instead of `format('string')`.
Additionally, since the necessity of `dup` cannot be determined automatically,
this autocorrection is inherently unsafe.

[source,ruby]
----
# frozen_string_literal: true

format('template').frozen? # => false
'template'.frozen?         # => true
----

[#examples-styleredundantformat]
=== Examples

[source,ruby]
----
# bad
format('the quick brown fox jumps over the lazy dog.')
sprintf('the quick brown fox jumps over the lazy dog.')

# good
'the quick brown fox jumps over the lazy dog.'

# bad
format(MESSAGE)
sprintf(MESSAGE)

# good
MESSAGE

# bad
format('%s %s', 'foo', 'bar')
sprintf('%s %s', 'foo', 'bar')

# good
'foo bar'
----

[#styleredundantfreeze]
== Style/RedundantFreeze

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.34
| 0.66
|===

Check for uses of `Object#freeze` on immutable objects.

NOTE: `Regexp` and `Range` literals are frozen objects since Ruby 3.0.

NOTE: From Ruby 3.0, this cop allows explicit freezing of interpolated
string literals when `# frozen-string-literal: true` is used.

[#examples-styleredundantfreeze]
=== Examples

[source,ruby]
----
# bad
CONST = 1.freeze

# good
CONST = 1
----

[#styleredundantheredocdelimiterquotes]
== Style/RedundantHeredocDelimiterQuotes

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.45
| -
|===

Checks for redundant heredoc delimiter quotes.

[#examples-styleredundantheredocdelimiterquotes]
=== Examples

[source,ruby]
----
# bad
do_something(<<~'EOS')
  no string interpolation style text
EOS

# good
do_something(<<~EOS)
  no string interpolation style text
EOS

do_something(<<~'EOS')
  #{string_interpolation_style_text_not_evaluated}
EOS

do_something(<<~'EOS')
  Preserve \
  newlines
EOS
----

[#styleredundantinitialize]
== Style/RedundantInitialize

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Command-line only (Unsafe)
| 1.27
| 1.61
|===

Checks for `initialize` methods that are redundant.

An initializer is redundant if it does not do anything, or if it only
calls `super` with the same arguments given to it. If the initializer takes
an argument that accepts multiple values (`restarg`, `kwrestarg`, etc.) it
will not register an offense, because it allows the initializer to take a different
number of arguments as its superclass potentially does.

NOTE: If an initializer takes any arguments and has an empty body, RuboCop
assumes it to *not* be redundant. This is to prevent potential `ArgumentError`.

NOTE: If an initializer argument has a default value, RuboCop assumes it
to *not* be redundant.

NOTE: Empty initializers are registered as offenses, but it is possible
to purposely create an empty `initialize` method to override a superclass's
initializer.

[#safety-styleredundantinitialize]
=== Safety

This cop is unsafe because removing an empty initializer may alter
the behavior of the code, particularly if the superclass initializer
raises an exception. In such cases, the empty initializer may act as
a safeguard to prevent unintended errors from propagating.

[#examples-styleredundantinitialize]
=== Examples

[source,ruby]
----
# bad
def initialize
end

# bad
def initialize
  super
end

# bad
def initialize(a, b)
  super
end

# bad
def initialize(a, b)
  super(a, b)
end

# good
def initialize
  do_something
end

# good
def initialize
  do_something
  super
end

# good (different number of parameters)
def initialize(a, b)
  super(a)
end

# good (default value)
def initialize(a, b = 5)
  super
end

# good (default value)
def initialize(a, b: 5)
  super
end

# good (changes the parameter requirements)
def initialize(_)
end

# good (changes the parameter requirements)
def initialize(*)
end

# good (changes the parameter requirements)
def initialize(**)
end

# good (changes the parameter requirements)
def initialize(...)
end
----

[#allowcomments_-true-_default_-styleredundantinitialize]
==== AllowComments: true (default)

[source,ruby]
----
# good
def initialize
  # Overriding to negate superclass `initialize` method.
end
----

[#allowcomments_-false-styleredundantinitialize]
==== AllowComments: false

[source,ruby]
----
# bad
def initialize
  # Overriding to negate superclass `initialize` method.
end
----

[#configurable-attributes-styleredundantinitialize]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowComments
| `true`
| Boolean
|===

[#styleredundantinterpolation]
== Style/RedundantInterpolation

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.76
| 1.30
|===

Checks for strings that are just an interpolated expression.

[#safety-styleredundantinterpolation]
=== Safety

Autocorrection is unsafe because when calling a destructive method to string,
the resulting string may have different behavior or raise `FrozenError`.

[source,ruby]
----
x = 'a'
y = "#{x}"
y << 'b'   # return 'ab'
x          # return 'a'
y = x.to_s
y << 'b'   # return 'ab'
x          # return 'ab'

x = 'a'.freeze
y = "#{x}"
y << 'b'   # return 'ab'.
y = x.to_s
y << 'b'   # raise `FrozenError`.
----

[#examples-styleredundantinterpolation]
=== Examples

[source,ruby]
----
# bad
"#{@var}"

# good
@var.to_s

# good if @var is already a String
@var
----

[#styleredundantinterpolationunfreeze]
== Style/RedundantInterpolationUnfreeze

NOTE: Requires Ruby version 3.0

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.66
| -
|===

Before Ruby 3.0, interpolated strings followed the frozen string literal
magic comment which sometimes made it necessary to explicitly unfreeze them.
Ruby 3.0 changed interpolated strings to always be unfrozen which makes
unfreezing them redundant.

[#examples-styleredundantinterpolationunfreeze]
=== Examples

[source,ruby]
----
# bad
+"#{foo} bar"

# bad
"#{foo} bar".dup

# good
"#{foo} bar"
----

[#styleredundantlinecontinuation]
== Style/RedundantLineContinuation

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.49
| -
|===

Check for redundant line continuation.

This cop marks a line continuation as redundant if removing the backslash
does not result in a syntax error.
However, a backslash at the end of a comment or
for string concatenation is not redundant and is not considered an offense.

[#examples-styleredundantlinecontinuation]
=== Examples

[source,ruby]
----
# bad
foo. \
  bar
foo \
  &.bar \
    .baz

# good
foo.
  bar
foo
  &.bar
    .baz

# bad
[foo, \
  bar]
{foo: \
  bar}

# good
[foo,
  bar]
{foo:
  bar}

# bad
foo(bar, \
  baz)

# good
foo(bar,
  baz)

# also good - backslash in string concatenation is not redundant
foo('bar' \
  'baz')

# also good - backslash at the end of a comment is not redundant
foo(bar, # \
  baz)

# also good - backslash at the line following the newline begins with a + or -,
# it is not redundant
1 \
  + 2 \
    - 3

# also good - backslash with newline between the method name and its arguments,
# it is not redundant.
some_method \
  (argument)
----

[#styleredundantparentheses]
== Style/RedundantParentheses

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.36
| -
|===

Checks for redundant parentheses.

[#examples-styleredundantparentheses]
=== Examples

[source,ruby]
----
# bad
(x) if ((y.z).nil?)

# good
x if y.z.nil?
----

[#styleredundantpercentq]
== Style/RedundantPercentQ

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.76
| -
|===

Checks for usage of the %q/%Q syntax when '' or "" would do.

[#examples-styleredundantpercentq]
=== Examples

[source,ruby]
----
# bad
name = %q(Bruce Wayne)
time = %q(8 o'clock)
question = %q("What did you say?")

# good
name = 'Bruce Wayne'
time = "8 o'clock"
question = '"What did you say?"'
----

[#references-styleredundantpercentq]
=== References

* https://rubystyle.guide#percent-q

[#styleredundantregexpargument]
== Style/RedundantRegexpArgument

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.53
| -
|===

Identifies places where argument can be replaced from
a deterministic regexp to a string.

[#examples-styleredundantregexpargument]
=== Examples

[source,ruby]
----
# bad
'foo'.byteindex(/f/)
'foo'.byterindex(/f/)
'foo'.gsub(/f/, 'x')
'foo'.gsub!(/f/, 'x')
'foo'.partition(/f/)
'foo'.rpartition(/f/)
'foo'.scan(/f/)
'foo'.split(/f/)
'foo'.start_with?(/f/)
'foo'.sub(/f/, 'x')
'foo'.sub!(/f/, 'x')

# good
'foo'.byteindex('f')
'foo'.byterindex('f')
'foo'.gsub('f', 'x')
'foo'.gsub!('f', 'x')
'foo'.partition('f')
'foo'.rpartition('f')
'foo'.scan('f')
'foo'.split('f')
'foo'.start_with?('f')
'foo'.sub('f', 'x')
'foo'.sub!('f', 'x')
----

[#styleredundantregexpcharacterclass]
== Style/RedundantRegexpCharacterClass

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.85
| -
|===

Checks for unnecessary single-element `Regexp` character classes.

[#examples-styleredundantregexpcharacterclass]
=== Examples

[source,ruby]
----
# bad
r = /[x]/

# good
r = /x/

# bad
r = /[\s]/

# good
r = /\s/

# bad
r = %r{/[b]}

# good
r = %r{/b}

# good
r = /[ab]/
----

[#styleredundantregexpconstructor]
== Style/RedundantRegexpConstructor

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.52
| -
|===

Checks for the instantiation of regexp using redundant `Regexp.new` or `Regexp.compile`.
Autocorrect replaces to regexp literal which is the simplest and fastest.

[#examples-styleredundantregexpconstructor]
=== Examples

[source,ruby]
----
# bad
Regexp.new(/regexp/)
Regexp.compile(/regexp/)

# good
/regexp/
Regexp.new('regexp')
Regexp.compile('regexp')
----

[#styleredundantregexpescape]
== Style/RedundantRegexpEscape

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.85
| -
|===

Checks for redundant escapes inside `Regexp` literals.

[#examples-styleredundantregexpescape]
=== Examples

[source,ruby]
----
# bad
%r{foo\/bar}

# good
%r{foo/bar}

# good
/foo\/bar/

# good
%r/foo\/bar/

# good
%r!foo\!bar!

# bad
/a\-b/

# good
/a-b/

# bad
/[\+\-]\d/

# good
/[+\-]\d/
----

[#styleredundantreturn]
== Style/RedundantReturn

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.10
| 0.14
|===

Checks for redundant `return` expressions.

[#examples-styleredundantreturn]
=== Examples

[source,ruby]
----
# These bad cases should be extended to handle methods whose body is
# if/else or a case expression with a default branch.

# bad
def test
  return something
end

# bad
def test
  one
  two
  three
  return something
end

# bad
def test
  return something if something_else
end

# good
def test
  something if something_else
end

# good
def test
  if x
  elsif y
  else
  end
end
----

[#allowmultiplereturnvalues_-false-_default_-styleredundantreturn]
==== AllowMultipleReturnValues: false (default)

[source,ruby]
----
# bad
def test
  return x, y
end
----

[#allowmultiplereturnvalues_-true-styleredundantreturn]
==== AllowMultipleReturnValues: true

[source,ruby]
----
# good
def test
  return x, y
end
----

[#configurable-attributes-styleredundantreturn]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowMultipleReturnValues
| `false`
| Boolean
|===

[#references-styleredundantreturn]
=== References

* https://rubystyle.guide#no-explicit-return

[#styleredundantself]
== Style/RedundantSelf

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.10
| 0.13
|===

Checks for redundant uses of `self`.

The usage of `self` is only needed when:

* Sending a message to same object with zero arguments in
  presence of a method name clash with an argument or a local
  variable.

* Calling an attribute writer to prevent a local variable assignment.

Note, with using explicit self you can only send messages with public or
protected scope, you cannot send private messages this way.

Note we allow uses of `self` with operators because it would be awkward
otherwise. Also allows the use of `self.it` without arguments in blocks,
as in `0.times { self.it }`, following `Lint/ItWithoutArgumentsInBlock` cop.

[#examples-styleredundantself]
=== Examples

[source,ruby]
----
# bad
def foo(bar)
  self.baz
end

# good
def foo(bar)
  self.bar  # Resolves name clash with the argument.
end

def foo
  bar = 1
  self.bar  # Resolves name clash with the local variable.
end

def foo
  %w[x y z].select do |bar|
    self.bar == bar  # Resolves name clash with argument of the block.
  end
end
----

[#references-styleredundantself]
=== References

* https://rubystyle.guide#no-self-unless-required

[#styleredundantselfassignment]
== Style/RedundantSelfAssignment

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.90
| -
|===

Checks for places where redundant assignments are made for in place
modification methods.

[#safety-styleredundantselfassignment]
=== Safety

This cop is unsafe, because it can produce false positives for
user defined methods having one of the expected names, but not modifying
its receiver in place.

[#examples-styleredundantselfassignment]
=== Examples

[source,ruby]
----
# bad
args = args.concat(ary)
hash = hash.merge!(other)

# good
args.concat(foo)
args += foo
hash.merge!(other)

# good
foo.concat(ary)
----

[#styleredundantselfassignmentbranch]
== Style/RedundantSelfAssignmentBranch

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.19
| -
|===

Checks for places where conditional branch makes redundant self-assignment.

It only detects local variable because it may replace state of instance variable,
class variable, and global variable that have state across methods with `nil`.

[#examples-styleredundantselfassignmentbranch]
=== Examples

[source,ruby]
----
# bad
foo = condition ? bar : foo

# good
foo = bar if condition

# bad
foo = condition ? foo : bar

# good
foo = bar unless condition
----

[#styleredundantsort]
== Style/RedundantSort

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.76
| 1.22
|===

Identifies instances of sorting and then
taking only the first or last element. The same behavior can
be accomplished without a relatively expensive sort by using
`Enumerable#min` instead of sorting and taking the first
element and `Enumerable#max` instead of sorting and taking the
last element. Similarly, `Enumerable#min_by` and
`Enumerable#max_by` can replace `Enumerable#sort_by` calls
after which only the first or last element is used.

[#safety-styleredundantsort]
=== Safety

This cop is unsafe, because `sort...last` and `max` may not return the
same element in all cases.

In an enumerable where there are multiple elements where ``a <=> b == 0``,
or where the transformation done by the `sort_by` block has the
same result, `sort.last` and `max` (or `sort_by.last` and `max_by`)
will return different elements. `sort.last` will return the last
element but `max` will return the first element.

For example:

[source,ruby]
----
  class MyString < String; end
  strings = [MyString.new('test'), 'test']
  strings.sort.last.class   #=> String
  strings.max.class         #=> MyString
----

[source,ruby]
----
  words = %w(dog horse mouse)
  words.sort_by { |word| word.length }.last   #=> 'mouse'
  words.max_by { |word| word.length }         #=> 'horse'
----

[#examples-styleredundantsort]
=== Examples

[source,ruby]
----
# bad
[2, 1, 3].sort.first
[2, 1, 3].sort[0]
[2, 1, 3].sort.at(0)
[2, 1, 3].sort.slice(0)

# good
[2, 1, 3].min

# bad
[2, 1, 3].sort.last
[2, 1, 3].sort[-1]
[2, 1, 3].sort.at(-1)
[2, 1, 3].sort.slice(-1)

# good
[2, 1, 3].max

# bad
arr.sort_by(&:foo).first
arr.sort_by(&:foo)[0]
arr.sort_by(&:foo).at(0)
arr.sort_by(&:foo).slice(0)

# good
arr.min_by(&:foo)

# bad
arr.sort_by(&:foo).last
arr.sort_by(&:foo)[-1]
arr.sort_by(&:foo).at(-1)
arr.sort_by(&:foo).slice(-1)

# good
arr.max_by(&:foo)
----

[#styleredundantsortby]
== Style/RedundantSortBy

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.36
| -
|===

Identifies places where `sort_by { ... }` can be replaced by
`sort`.

[#examples-styleredundantsortby]
=== Examples

[source,ruby]
----
# bad
array.sort_by { |x| x }
array.sort_by do |var|
  var
end

# good
array.sort
----

[#styleredundantstringescape]
== Style/RedundantStringEscape

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.37
| -
|===

Checks for redundant escapes in string literals.

[#examples-styleredundantstringescape]
=== Examples

[source,ruby]
----
# bad - no need to escape # without following {/$/@
"\#foo"

# bad - no need to escape single quotes inside double quoted string
"\'foo\'"

# bad - heredocs are also checked for unnecessary escapes
<<~STR
  \#foo \"foo\"
STR

# good
"#foo"

# good
"\#{no_interpolation}"

# good
"'foo'"

# good
"foo\
bar"

# good
<<~STR
  #foo "foo"
STR
----

[#styleregexpliteral]
== Style/RegexpLiteral

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.30
|===

Enforces using `//` or `%r` around regular expressions.

NOTE: The following `%r` cases using a regexp starts with a blank or `=`
as a method argument allowed to prevent syntax errors.

[source,ruby]
----
do_something %r{ regexp} # `do_something / regexp/` is an invalid syntax.
do_something %r{=regexp} # `do_something /=regexp/` is an invalid syntax.
----

[#examples-styleregexpliteral]
=== Examples

[#enforcedstyle_-slashes-_default_-styleregexpliteral]
==== EnforcedStyle: slashes (default)

[source,ruby]
----
# bad
snake_case = %r{^[\dA-Z_]+$}

# bad
regex = %r{
  foo
  (bar)
  (baz)
}x

# good
snake_case = /^[\dA-Z_]+$/

# good
regex = /
  foo
  (bar)
  (baz)
/x
----

[#enforcedstyle_-percent_r-styleregexpliteral]
==== EnforcedStyle: percent_r

[source,ruby]
----
# bad
snake_case = /^[\dA-Z_]+$/

# bad
regex = /
  foo
  (bar)
  (baz)
/x

# good
snake_case = %r{^[\dA-Z_]+$}

# good
regex = %r{
  foo
  (bar)
  (baz)
}x
----

[#enforcedstyle_-mixed-styleregexpliteral]
==== EnforcedStyle: mixed

[source,ruby]
----
# bad
snake_case = %r{^[\dA-Z_]+$}

# bad
regex = /
  foo
  (bar)
  (baz)
/x

# good
snake_case = /^[\dA-Z_]+$/

# good
regex = %r{
  foo
  (bar)
  (baz)
}x
----

[#allowinnerslashes_-false-_default_-styleregexpliteral]
==== AllowInnerSlashes: false (default)

[source,ruby]
----
# If `false`, the cop will always recommend using `%r` if one or more
# slashes are found in the regexp string.

# bad
x =~ /home\//

# good
x =~ %r{home/}
----

[#allowinnerslashes_-true-styleregexpliteral]
==== AllowInnerSlashes: true

[source,ruby]
----
# good
x =~ /home\//
----

[#configurable-attributes-styleregexpliteral]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `slashes`
| `slashes`, `percent_r`, `mixed`

| AllowInnerSlashes
| `false`
| Boolean
|===

[#references-styleregexpliteral]
=== References

* https://rubystyle.guide#percent-r

[#stylerequireorder]
== Style/RequireOrder

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| Always (Unsafe)
| 1.40
| -
|===

Sort `require` and `require_relative` in alphabetical order.

[#safety-stylerequireorder]
=== Safety

This cop's autocorrection is unsafe because it will obviously change the execution order.

[#examples-stylerequireorder]
=== Examples

[source,ruby]
----
# bad
require 'b'
require 'a'

# good
require 'a'
require 'b'

# bad
require_relative 'b'
require_relative 'a'

# good
require_relative 'a'
require_relative 'b'

# good (sorted within each section separated by a blank line)
require 'a'
require 'd'

require 'b'
require 'c'

# good
require 'b'
require_relative 'c'
require 'a'

# bad
require 'a'
require 'c' if foo
require 'b'

# good
require 'a'
require 'b'
require 'c' if foo

# bad
require 'c'
if foo
  require 'd'
  require 'b'
end
require 'a'

# good
require 'c'
if foo
  require 'b'
  require 'd'
end
require 'a'
----

[#stylerescuemodifier]
== Style/RescueModifier

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.34
|===

Checks for uses of `rescue` in its modifier form is added for following
reasons:

* The syntax of modifier form `rescue` can be misleading because it
  might lead us to believe that `rescue` handles the given exception
  but it actually rescue all exceptions to return the given rescue
  block. In this case, value returned by handle_error or
  SomeException.

* Modifier form `rescue` would rescue all the exceptions. It would
  silently skip all exception or errors and handle the error.
  Example: If `NoMethodError` is raised, modifier form rescue would
  handle the exception.

[#examples-stylerescuemodifier]
=== Examples

[source,ruby]
----
# bad
some_method rescue handle_error

# bad
some_method rescue SomeException

# good
begin
  some_method
rescue
  handle_error
end

# good
begin
  some_method
rescue SomeException
  handle_error
end
----

[#references-stylerescuemodifier]
=== References

* https://rubystyle.guide#no-rescue-modifiers

[#stylerescuestandarderror]
== Style/RescueStandardError

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.52
| -
|===

Checks for rescuing `StandardError`. There are two supported
styles `implicit` and `explicit`. This cop will not register an offense
if any error other than `StandardError` is specified.

[#examples-stylerescuestandarderror]
=== Examples

[#enforcedstyle_-explicit-_default_-stylerescuestandarderror]
==== EnforcedStyle: explicit (default)

[source,ruby]
----
# `explicit` will enforce using `rescue StandardError`
# instead of `rescue`.

# bad
begin
  foo
rescue
  bar
end

# good
begin
  foo
rescue StandardError
  bar
end

# good
begin
  foo
rescue OtherError
  bar
end

# good
begin
  foo
rescue StandardError, SecurityError
  bar
end
----

[#enforcedstyle_-implicit-stylerescuestandarderror]
==== EnforcedStyle: implicit

[source,ruby]
----
# `implicit` will enforce using `rescue` instead of
# `rescue StandardError`.

# bad
begin
  foo
rescue StandardError
  bar
end

# good
begin
  foo
rescue
  bar
end

# good
begin
  foo
rescue OtherError
  bar
end

# good
begin
  foo
rescue StandardError, SecurityError
  bar
end
----

[#configurable-attributes-stylerescuestandarderror]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `explicit`
| `implicit`, `explicit`
|===

[#stylereturnnil]
== Style/ReturnNil

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| Always
| 0.50
| -
|===

Enforces consistency between `return nil` and `return`.

This cop is disabled by default. Because there seems to be a perceived semantic difference
between `return` and `return nil`. The former can be seen as just halting evaluation,
while the latter might be used when the return value is of specific concern.

Supported styles are `return` and `return_nil`.

[#examples-stylereturnnil]
=== Examples

[#enforcedstyle_-return-_default_-stylereturnnil]
==== EnforcedStyle: return (default)

[source,ruby]
----
# bad
def foo(arg)
  return nil if arg
end

# good
def foo(arg)
  return if arg
end
----

[#enforcedstyle_-return_nil-stylereturnnil]
==== EnforcedStyle: return_nil

[source,ruby]
----
# bad
def foo(arg)
  return if arg
end

# good
def foo(arg)
  return nil if arg
end
----

[#configurable-attributes-stylereturnnil]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `return`
| `return`, `return_nil`
|===

[#stylereturnnilinpredicatemethoddefinition]
== Style/ReturnNilInPredicateMethodDefinition

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always (Unsafe)
| 1.53
| 1.67
|===

Checks for predicate method definitions that return `nil`.
A predicate method should only return a boolean value.

[#safety-stylereturnnilinpredicatemethoddefinition]
=== Safety

Autocorrection is marked as unsafe because the change of the return value
from `nil` to `false` could potentially lead to incompatibility issues.

[#examples-stylereturnnilinpredicatemethoddefinition]
=== Examples

[source,ruby]
----
# bad
def foo?
  return if condition

  do_something?
end

# bad
def foo?
  return nil if condition

  do_something?
end

# good
def foo?
  return false if condition

  do_something?
end

# bad
def foo?
  if condition
    nil
  else
    true
  end
end

# good
def foo?
  if condition
    false
  else
    true
  end
end
----

[#allowedmethods_-__foo___-stylereturnnilinpredicatemethoddefinition]
==== AllowedMethods: ['foo?']

[source,ruby]
----
# good
def foo?
  return if condition

  do_something?
end
----

[#allowedpatterns_-_foo_-stylereturnnilinpredicatemethoddefinition]
==== AllowedPatterns: [/foo/]

[source,ruby]
----
# good
def foo?
  return if condition

  do_something?
end
----

[#configurable-attributes-stylereturnnilinpredicatemethoddefinition]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedMethods
| `[]`
| Array

| AllowedPatterns
| `[]`
| Array
|===

[#references-stylereturnnilinpredicatemethoddefinition]
=== References

* https://rubystyle.guide#bool-methods-qmark

[#stylesafenavigation]
== Style/SafeNavigation

NOTE: Requires Ruby version 2.3

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.43
| 1.67
|===

Transforms usages of a method call safeguarded by a non `nil`
check for the variable whose method is being called to
safe navigation (`&.`). If there is a method chain, all of the methods
in the chain need to be checked for safety, and all of the methods will
need to be changed to use safe navigation.

The default for `ConvertCodeThatCanStartToReturnNil` is `false`.
When configured to `true`, this will
check for code in the format `!foo.nil? && foo.bar`. As it is written,
the return of this code is limited to `false` and whatever the return
of the method is. If this is converted to safe navigation,
`foo&.bar` can start returning `nil` as well as what the method
returns.

The default for `MaxChainLength` is `2`.
We have limited the cop to not register an offense for method chains
that exceed this option's value.

NOTE: This cop will recognize offenses but not autocorrect code when the
right hand side (RHS) of the `&&` statement is an `||` statement
(eg. `foo && (foo.bar? || foo.baz?)`). It can be corrected
manually by removing the `foo &&` and adding `&.` to each `foo` on the RHS.

[#safety-stylesafenavigation]
=== Safety

Autocorrection is unsafe because if a value is `false`, the resulting
code will have different behavior or raise an error.

[source,ruby]
----
x = false
x && x.foo  # return false
x&.foo      # raises NoMethodError
----

[#examples-stylesafenavigation]
=== Examples

[source,ruby]
----
# bad
foo.bar if foo
foo.bar.baz if foo
foo.bar(param1, param2) if foo
foo.bar { |e| e.something } if foo
foo.bar(param) { |e| e.something } if foo

foo.bar if !foo.nil?
foo.bar unless !foo
foo.bar unless foo.nil?

foo && foo.bar
foo && foo.bar.baz
foo && foo.bar(param1, param2)
foo && foo.bar { |e| e.something }
foo && foo.bar(param) { |e| e.something }

foo ? foo.bar : nil
foo.nil? ? nil : foo.bar
!foo.nil? ? foo.bar : nil
!foo ? nil : foo.bar

# good
foo&.bar
foo&.bar&.baz
foo&.bar(param1, param2)
foo&.bar { |e| e.something }
foo&.bar(param) { |e| e.something }
foo && foo.bar.baz.qux # method chain with more than 2 methods
foo && foo.nil? # method that `nil` responds to

# Method calls that do not use `.`
foo && foo < bar
foo < bar if foo

# When checking `foo&.empty?` in a conditional, `foo` being `nil` will actually
# do the opposite of what the author intends.
foo && foo.empty?

# This could start returning `nil` as well as the return of the method
foo.nil? || foo.bar
!foo || foo.bar

# Methods that are used on assignment, arithmetic operation or
# comparison should not be converted to use safe navigation
foo.baz = bar if foo
foo.baz + bar if foo
foo.bar > 2 if foo

foo ? foo[index] : nil    # Ignored `foo&.[](index)` due to unclear readability benefit.
foo ? foo[idx] = v : nil  # Ignored `foo&.[]=(idx, v)` due to unclear readability benefit.
foo ? foo * 42 : nil      # Ignored `foo&.*(42)` due to unclear readability benefit.
----

[#configurable-attributes-stylesafenavigation]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| ConvertCodeThatCanStartToReturnNil
| `false`
| Boolean

| AllowedMethods
| `present?`, `blank?`, `presence`, `try`, `try!`
| Array

| MaxChainLength
| `2`
| Integer
|===

[#stylesafenavigationchainlength]
== Style/SafeNavigationChainLength

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| No
| 1.68
| -
|===

Enforces safe navigation chains length to not exceed the configured maximum.
The longer the chain is, the harder it becomes to track what on it could be
returning `nil`.

There is a potential interplay with `Style/SafeNavigation` - if both are enabled
and their settings are "incompatible", one of the cops will complain about what
the other proposes.

E.g. if `Style/SafeNavigation` is configured with `MaxChainLength: 2` (default)
and this cop is configured with `Max: 1`, then for `foo.bar.baz if foo` the former
will suggest `foo&.bar&.baz`, which is an offense for the latter.

[#examples-stylesafenavigationchainlength]
=== Examples

[#max_-2-_default_-stylesafenavigationchainlength]
==== Max: 2 (default)

[source,ruby]
----
# bad
user&.address&.zip&.upcase

# good
user&.address&.zip
user.address.zip if user
----

[#configurable-attributes-stylesafenavigationchainlength]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| Max
| `2`
| Integer
|===

[#references-stylesafenavigationchainlength]
=== References

* https://rubystyle.guide#safe-navigation

[#stylesample]
== Style/Sample

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.30
| -
|===

Identifies usages of `shuffle.first`,
`shuffle.last`, and `shuffle[]` and change them to use
`sample` instead.

[#examples-stylesample]
=== Examples

[source,ruby]
----
# bad
[1, 2, 3].shuffle.first
[1, 2, 3].shuffle.first(2)
[1, 2, 3].shuffle.last
[2, 1, 3].shuffle.at(0)
[2, 1, 3].shuffle.slice(0)
[1, 2, 3].shuffle[2]
[1, 2, 3].shuffle[0, 2]    # sample(2) will do the same
[1, 2, 3].shuffle[0..2]    # sample(3) will do the same
[1, 2, 3].shuffle(random: Random.new).first

# good
[1, 2, 3].shuffle
[1, 2, 3].sample
[1, 2, 3].sample(3)
[1, 2, 3].shuffle[1, 3]    # sample(3) might return a longer Array
[1, 2, 3].shuffle[1..3]    # sample(3) might return a longer Array
[1, 2, 3].shuffle[foo, bar]
[1, 2, 3].shuffle(random: Random.new)
----

[#references-stylesample]
=== References

* https://github.com/fastruby/fast-ruby#arrayshufflefirst-vs-arraysample-code

[#styleselectbyregexp]
== Style/SelectByRegexp

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always (Unsafe)
| 1.22
| -
|===

Looks for places where a subset of an Enumerable (array,
range, set, etc.; see note below) is calculated based on a `Regexp`
match, and suggests `grep` or `grep_v` instead.

NOTE: Hashes do not behave as you may expect with `grep`, which
means that `hash.grep` is not equivalent to `hash.select`. Although
RuboCop is limited by static analysis, this cop attempts to avoid
registering an offense when the receiver is a hash (hash literal,
`Hash.new`, `Hash#[]`, or `to_h`/`to_hash`).

NOTE: `grep` and `grep_v` were optimized when used without a block
in Ruby 3.0, but may be slower in previous versions.
See https://bugs.ruby-lang.org/issues/17030

[#safety-styleselectbyregexp]
=== Safety

Autocorrection is marked as unsafe because `MatchData` will
not be created by `grep`, but may have previously been relied
upon after the `match?` or `=~` call.

Additionally, the cop cannot guarantee that the receiver of
`select` or `reject` is actually an array by static analysis,
so the correction may not be actually equivalent.

[#examples-styleselectbyregexp]
=== Examples

[source,ruby]
----
# bad (select, filter, or find_all)
array.select { |x| x.match? /regexp/ }
array.select { |x| /regexp/.match?(x) }
array.select { |x| x =~ /regexp/ }
array.select { |x| /regexp/ =~ x }

# bad (reject)
array.reject { |x| x.match? /regexp/ }
array.reject { |x| /regexp/.match?(x) }
array.reject { |x| x =~ /regexp/ }
array.reject { |x| /regexp/ =~ x }

# good
array.grep(regexp)
array.grep_v(regexp)
----

[#styleselfassignment]
== Style/SelfAssignment

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.19
| 0.29
|===

Enforces the use the shorthand for self-assignment.

[#examples-styleselfassignment]
=== Examples

[source,ruby]
----
# bad
x = x + 1

# good
x += 1
----

[#references-styleselfassignment]
=== References

* https://rubystyle.guide#self-assignment

[#stylesemicolon]
== Style/Semicolon

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.19
|===

Checks for multiple expressions placed on the same line.
It also checks for lines terminated with a semicolon.

This cop has `AllowAsExpressionSeparator` configuration option.
It allows `;` to separate several expressions on the same line.

[#examples-stylesemicolon]
=== Examples

[source,ruby]
----
# bad
foo = 1; bar = 2;
baz = 3;

# good
foo = 1
bar = 2
baz = 3
----

[#allowasexpressionseparator_-false-_default_-stylesemicolon]
==== AllowAsExpressionSeparator: false (default)

[source,ruby]
----
# bad
foo = 1; bar = 2
----

[#allowasexpressionseparator_-true-stylesemicolon]
==== AllowAsExpressionSeparator: true

[source,ruby]
----
# good
foo = 1; bar = 2
----

[#configurable-attributes-stylesemicolon]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowAsExpressionSeparator
| `false`
| Boolean
|===

[#references-stylesemicolon]
=== References

* https://rubystyle.guide#no-semicolon

[#stylesend]
== Style/Send

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.33
| -
|===

Checks for the use of the send method.

[#examples-stylesend]
=== Examples

[source,ruby]
----
# bad
Foo.send(bar)
quuz.send(fred)

# good
Foo.__send__(bar)
quuz.public_send(fred)
----

[#references-stylesend]
=== References

* https://rubystyle.guide#prefer-public-send

[#stylesendwithliteralmethodname]
== Style/SendWithLiteralMethodName

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.64
| -
|===

Detects the use of the `public_send` method with a literal method name argument.
Since the `send` method can be used to call private methods, by default,
only the `public_send` method is detected.

NOTE: Writer methods with names ending in `=` are always permitted because their
behavior differs as follows:

[source,ruby]
----
def foo=(foo)
  @foo = foo
  42
end

self.foo = 1   # => 1
send(:foo=, 1) # => 42
----

[#safety-stylesendwithliteralmethodname]
=== Safety

This cop is not safe because it can incorrectly detect based on the receiver.
Additionally, when `AllowSend` is set to `true`, it cannot determine whether
the `send` method being detected is calling a private method.

[#examples-stylesendwithliteralmethodname]
=== Examples

[source,ruby]
----
# bad
obj.public_send(:method_name)
obj.public_send('method_name')

# good
obj.method_name
----

[#allowsend_-true-_default_-stylesendwithliteralmethodname]
==== AllowSend: true (default)

[source,ruby]
----
# good
obj.send(:method_name)
obj.send('method_name')
obj.__send__(:method_name)
obj.__send__('method_name')
----

[#allowsend_-false-stylesendwithliteralmethodname]
==== AllowSend: false

[source,ruby]
----
# bad
obj.send(:method_name)
obj.send('method_name')
obj.__send__(:method_name)
obj.__send__('method_name')

# good
obj.method_name
----

[#configurable-attributes-stylesendwithliteralmethodname]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowSend
| `true`
| Boolean
|===

[#stylesignalexception]
== Style/SignalException

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.11
| 0.37
|===

Checks for uses of `fail` and `raise`.

[#examples-stylesignalexception]
=== Examples

[#enforcedstyle_-only_raise-_default_-stylesignalexception]
==== EnforcedStyle: only_raise (default)

[source,ruby]
----
# The `only_raise` style enforces the sole use of `raise`.
# bad
begin
  fail
rescue Exception
  # handle it
end

def watch_out
  fail
rescue Exception
  # handle it
end

Kernel.fail

# good
begin
  raise
rescue Exception
  # handle it
end

def watch_out
  raise
rescue Exception
  # handle it
end

Kernel.raise
----

[#enforcedstyle_-only_fail-stylesignalexception]
==== EnforcedStyle: only_fail

[source,ruby]
----
# The `only_fail` style enforces the sole use of `fail`.
# bad
begin
  raise
rescue Exception
  # handle it
end

def watch_out
  raise
rescue Exception
  # handle it
end

Kernel.raise

# good
begin
  fail
rescue Exception
  # handle it
end

def watch_out
  fail
rescue Exception
  # handle it
end

Kernel.fail
----

[#enforcedstyle_-semantic-stylesignalexception]
==== EnforcedStyle: semantic

[source,ruby]
----
# The `semantic` style enforces the use of `fail` to signal an
# exception, then will use `raise` to trigger an offense after
# it has been rescued.
# bad
begin
  raise
rescue Exception
  # handle it
end

def watch_out
  # Error thrown
rescue Exception
  fail
end

Kernel.fail
Kernel.raise

# good
begin
  fail
rescue Exception
  # handle it
end

def watch_out
  fail
rescue Exception
  raise 'Preferably with descriptive message'
end

explicit_receiver.fail
explicit_receiver.raise
----

[#configurable-attributes-stylesignalexception]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `only_raise`
| `only_raise`, `only_fail`, `semantic`
|===

[#references-stylesignalexception]
=== References

* https://rubystyle.guide#prefer-raise-over-fail

[#stylesingleargumentdig]
== Style/SingleArgumentDig

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.89
| -
|===

Sometimes using `dig` method ends up with just a single
argument. In such cases, dig should be replaced with `[]`.

Since replacing `hash&.dig(:key)` with `hash[:key]` could potentially lead to error,
calls to the `dig` method using safe navigation will be ignored.

[#safety-stylesingleargumentdig]
=== Safety

This cop is unsafe because it cannot be guaranteed that the receiver
is an `Enumerable` or does not have a nonstandard implementation
of `dig`.

[#examples-stylesingleargumentdig]
=== Examples

[source,ruby]
----
# bad
{ key: 'value' }.dig(:key)
[1, 2, 3].dig(0)

# good
{ key: 'value' }[:key]
[1, 2, 3][0]

# good
{ key1: { key2: 'value' } }.dig(:key1, :key2)
[1, [2, [3]]].dig(1, 1)

# good
keys = %i[key1 key2]
{ key1: { key2: 'value' } }.dig(*keys)
----

[#stylesinglelineblockparams]
== Style/SingleLineBlockParams

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| Always
| 0.16
| 1.6
|===

Checks whether the block parameters of a single-line
method accepting a block match the names specified via configuration.

For instance one can configure `reduce`(`inject`) to use |a, e| as
parameters.

Configuration option: Methods
Should be set to use this cop. `Array` of hashes, where each key is the
method name and value - array of argument names.

[#examples-stylesinglelineblockparams]
=== Examples

[#methods_-__reduce_-_w_a-b___-stylesinglelineblockparams]
==== Methods: [{reduce: %w[a b]}]

[source,ruby]
----
# bad
foo.reduce { |c, d| c + d }
foo.reduce { |_, _d| 1 }

# good
foo.reduce { |a, b| a + b }
foo.reduce { |a, _b| a }
foo.reduce { |a, (id, _)| a + id }
foo.reduce { true }

# good
foo.reduce do |c, d|
  c + d
end
----

[#configurable-attributes-stylesinglelineblockparams]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| Methods
| `{"reduce" => ["acc", "elem"]}`, `{"inject" => ["acc", "elem"]}`
| Array
|===

[#stylesinglelinedoendblock]
== Style/SingleLineDoEndBlock

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.57
| -
|===

Checks for single-line `do`...`end` block.

In practice a single line `do`...`end` is autocorrected when `EnforcedStyle: semantic`
is configured for `Style/BlockDelimiters`. The autocorrection maintains the
`do` ... `end` syntax to preserve semantics and does not change it to `{`...`}` block.

NOTE: If `InspectBlocks` is set to `true` for `Layout/RedundantLineBreak`, blocks will
be autocorrected to be on a single line if possible. This cop respects that configuration
by not registering an offense if it would subsequently cause a
`Layout/RedundantLineBreak` offense.

[#examples-stylesinglelinedoendblock]
=== Examples

[source,ruby]
----
# bad
foo do |arg| bar(arg) end

# good
foo do |arg|
  bar(arg)
end

# bad
->(arg) do bar(arg) end

# good
->(arg) { bar(arg) }
----

[#references-stylesinglelinedoendblock]
=== References

* https://rubystyle.guide#single-line-do-end-block

[#stylesinglelinemethods]
== Style/SingleLineMethods

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 1.8
|===

Checks for single-line method definitions that contain a body.
It will accept single-line methods with no body.

Endless methods added in Ruby 3.0 are also accepted by this cop.

If `Style/EndlessMethod` is enabled with `EnforcedStyle: allow_single_line`, `allow_always`,
`require_single_line`, or `require_always`, single-line methods will be autocorrected
to endless methods if there is only one statement in the body.

[#examples-stylesinglelinemethods]
=== Examples

[source,ruby]
----
# bad
def some_method; body end
def link_to(url); {:name => url}; end
def @table.columns; super; end

# good
def self.resource_class=(klass); end
def @table.columns; end
def some_method() = body
----

[#allowifmethodisempty_-true-_default_-stylesinglelinemethods]
==== AllowIfMethodIsEmpty: true (default)

[source,ruby]
----
# good
def no_op; end
----

[#allowifmethodisempty_-false-stylesinglelinemethods]
==== AllowIfMethodIsEmpty: false

[source,ruby]
----
# bad
def no_op; end
----

[#configurable-attributes-stylesinglelinemethods]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowIfMethodIsEmpty
| `true`
| Boolean
|===

[#references-stylesinglelinemethods]
=== References

* https://rubystyle.guide#no-single-line-methods

[#styleslicingwithrange]
== Style/SlicingWithRange

NOTE: Requires Ruby version 2.6

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.83
| -
|===

Checks that arrays are not sliced with the redundant `ary[0..-1]`, replacing it with `ary`,
and ensures arrays are sliced with endless ranges instead of `ary[start..-1]` on Ruby 2.6+,
and with beginless ranges instead of `ary[nil..end]` on Ruby 2.7+.

[#safety-styleslicingwithrange]
=== Safety

This cop is unsafe because `x..-1` and `x..` are only guaranteed to
be equivalent for `Array#[]`, `String#[]`, and the cop cannot determine what class
the receiver is.

For example:
[source,ruby]
----
sum = proc { |ary| ary.sum }
sum[-3..-1] # => -6
sum[-3..] # Hangs forever
----

[#examples-styleslicingwithrange]
=== Examples

[source,ruby]
----
# bad
items[0..-1]
items[0..nil]
items[0...nil]

# good
items

# bad
items[1..-1]   # Ruby 2.6+
items[1..nil]  # Ruby 2.6+

# good
items[1..]     # Ruby 2.6+

# bad
items[nil..42] # Ruby 2.7+

# good
items[..42]    # Ruby 2.7+
items[0..42]   # Ruby 2.7+
----

[#references-styleslicingwithrange]
=== References

* https://rubystyle.guide#slicing-with-ranges

[#stylesolenestedconditional]
== Style/SoleNestedConditional

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.89
| 1.5
|===

If the branch of a conditional consists solely of a conditional node,
its conditions can be combined with the conditions of the outer branch.
This helps to keep the nesting level from getting too deep.

[#examples-stylesolenestedconditional]
=== Examples

[source,ruby]
----
# bad
if condition_a
  if condition_b
    do_something
  end
end

# bad
if condition_b
  do_something
end if condition_a

# good
if condition_a && condition_b
  do_something
end
----

[#allowmodifier_-false-_default_-stylesolenestedconditional]
==== AllowModifier: false (default)

[source,ruby]
----
# bad
if condition_a
  do_something if condition_b
end

# bad
if condition_b
  do_something
end if condition_a
----

[#allowmodifier_-true-stylesolenestedconditional]
==== AllowModifier: true

[source,ruby]
----
# good
if condition_a
  do_something if condition_b
end

# good
if condition_b
  do_something
end if condition_a
----

[#configurable-attributes-stylesolenestedconditional]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowModifier
| `false`
| Boolean
|===

[#stylespecialglobalvars]
== Style/SpecialGlobalVars

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.13
| 0.36
|===

Looks for uses of Perl-style global variables.
Correcting to global variables in the 'English' library
will add a require statement to the top of the file if
enabled by RequireEnglish config.

[#safety-stylespecialglobalvars]
=== Safety

Autocorrection is marked as unsafe because if `RequireEnglish` is not
true, replacing perl-style variables with english variables will break.

[#examples-stylespecialglobalvars]
=== Examples

[#enforcedstyle_-use_english_names-_default_-stylespecialglobalvars]
==== EnforcedStyle: use_english_names (default)

[source,ruby]
----
# good
require 'English' # or this could be in another file.

puts $LOAD_PATH
puts $LOADED_FEATURES
puts $PROGRAM_NAME
puts $ERROR_INFO
puts $ERROR_POSITION
puts $FIELD_SEPARATOR # or $FS
puts $OUTPUT_FIELD_SEPARATOR # or $OFS
puts $INPUT_RECORD_SEPARATOR # or $RS
puts $OUTPUT_RECORD_SEPARATOR # or $ORS
puts $INPUT_LINE_NUMBER # or $NR
puts $LAST_READ_LINE
puts $DEFAULT_OUTPUT
puts $DEFAULT_INPUT
puts $PROCESS_ID # or $PID
puts $CHILD_STATUS
puts $LAST_MATCH_INFO
puts $IGNORECASE
puts $ARGV # or ARGV
----

[#enforcedstyle_-use_perl_names-stylespecialglobalvars]
==== EnforcedStyle: use_perl_names

[source,ruby]
----
# good
puts $:
puts $"
puts $0
puts $!
puts $@
puts $;
puts $,
puts $/
puts $\
puts $.
puts $_
puts $>
puts $<
puts $$
puts $?
puts $~
puts $=
puts $*
----

[#enforcedstyle_-use_builtin_english_names-stylespecialglobalvars]
==== EnforcedStyle: use_builtin_english_names

[source,ruby]
----
# good
# Like `use_perl_names` but allows builtin global vars.
puts $LOAD_PATH
puts $LOADED_FEATURES
puts $PROGRAM_NAME
puts ARGV
puts $:
puts $"
puts $0
puts $!
puts $@
puts $;
puts $,
puts $/
puts $\
puts $.
puts $_
puts $>
puts $<
puts $$
puts $?
puts $~
puts $=
puts $*
----

[#configurable-attributes-stylespecialglobalvars]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| RequireEnglish
| `true`
| Boolean

| EnforcedStyle
| `use_english_names`
| `use_perl_names`, `use_english_names`, `use_builtin_english_names`
|===

[#references-stylespecialglobalvars]
=== References

* https://rubystyle.guide#no-cryptic-perlisms

[#stylestabbylambdaparentheses]
== Style/StabbyLambdaParentheses

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.35
| -
|===

Check for parentheses around stabby lambda arguments.
There are two different styles. Defaults to `require_parentheses`.

[#examples-stylestabbylambdaparentheses]
=== Examples

[#enforcedstyle_-require_parentheses-_default_-stylestabbylambdaparentheses]
==== EnforcedStyle: require_parentheses (default)

[source,ruby]
----
# bad
->a,b,c { a + b + c }

# good
->(a,b,c) { a + b + c}
----

[#enforcedstyle_-require_no_parentheses-stylestabbylambdaparentheses]
==== EnforcedStyle: require_no_parentheses

[source,ruby]
----
# bad
->(a,b,c) { a + b + c }

# good
->a,b,c { a + b + c}
----

[#configurable-attributes-stylestabbylambdaparentheses]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `require_parentheses`
| `require_parentheses`, `require_no_parentheses`
|===

[#references-stylestabbylambdaparentheses]
=== References

* https://rubystyle.guide#stabby-lambda-with-args

[#stylestaticclass]
== Style/StaticClass

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| No
| Always (Unsafe)
| 1.3
| -
|===

Checks for places where classes with only class methods can be
replaced with a module. Classes should be used only when it makes sense to create
instances out of them.

[#safety-stylestaticclass]
=== Safety

This cop is unsafe, because it is possible that this class is a parent
for some other subclass, monkey-patched with instance methods or
a dummy instance is instantiated from it somewhere.

[#examples-stylestaticclass]
=== Examples

[source,ruby]
----
# bad
class SomeClass
  def self.some_method
    # body omitted
  end

  def self.some_other_method
    # body omitted
  end
end

# good
module SomeModule
  module_function

  def some_method
    # body omitted
  end

  def some_other_method
    # body omitted
  end
end

# good - has instance method
class SomeClass
  def instance_method; end
  def self.class_method; end
end
----

[#references-stylestaticclass]
=== References

* https://rubystyle.guide#modules-vs-classes

[#stylestderrputs]
== Style/StderrPuts

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.51
| -
|===

Identifies places where `$stderr.puts` can be replaced by
`warn`. The latter has the advantage of easily being disabled by,
the `-W0` interpreter flag or setting `$VERBOSE` to `nil`.

[#examples-stylestderrputs]
=== Examples

[source,ruby]
----
# bad
$stderr.puts('hello')

# good
warn('hello')
----

[#references-stylestderrputs]
=== References

* https://rubystyle.guide#warn

[#stylestringchars]
== Style/StringChars

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| No
| Always (Unsafe)
| 1.12
| -
|===

Checks for uses of `String#split` with empty string or regexp literal argument.

[#safety-stylestringchars]
=== Safety

This cop is unsafe because it cannot be guaranteed that the receiver
is actually a string. If another class has a `split` method with
different behavior, it would be registered as a false positive.

[#examples-stylestringchars]
=== Examples

[source,ruby]
----
# bad
string.split(//)
string.split('')

# good
string.chars
----

[#references-stylestringchars]
=== References

* https://rubystyle.guide#string-chars

[#stylestringconcatenation]
== Style/StringConcatenation

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.89
| 1.18
|===

Checks for places where string concatenation
can be replaced with string interpolation.

The cop can autocorrect simple cases but will skip autocorrecting
more complex cases where the resulting code would be harder to read.
In those cases, it might be useful to extract statements to local
variables or methods which you can then interpolate in a string.

NOTE: When concatenation between two strings is broken over multiple
lines, this cop does not register an offense; instead,
`Style/LineEndConcatenation` will pick up the offense if enabled.

Two modes are supported:
1. `aggressive` style checks and corrects all occurrences of `+` where
either the left or right side of `+` is a string literal.
2. `conservative` style on the other hand, checks and corrects only if
left side (receiver of `+` method call) is a string literal.
This is useful when the receiver is some expression that returns string like `Pathname`
instead of a string literal.

[#safety-stylestringconcatenation]
=== Safety

This cop is unsafe in `aggressive` mode, as it cannot be guaranteed that
the receiver is actually a string, which can result in a false positive.

[#examples-stylestringconcatenation]
=== Examples

[#mode_-aggressive-_default_-stylestringconcatenation]
==== Mode: aggressive (default)

[source,ruby]
----
# bad
email_with_name = user.name + ' <' + user.email + '>'
Pathname.new('/') + 'test'

# good
email_with_name = "#{user.name} <#{user.email}>"
email_with_name = format('%s <%s>', user.name, user.email)
"#{Pathname.new('/')}test"

# accepted, line-end concatenation
name = 'First' +
  'Last'
----

[#mode_-conservative-stylestringconcatenation]
==== Mode: conservative

[source,ruby]
----
# bad
'Hello' + user.name

# good
"Hello #{user.name}"
user.name + '!!'
Pathname.new('/') + 'test'
----

[#configurable-attributes-stylestringconcatenation]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| Mode
| `aggressive`
| String
|===

[#references-stylestringconcatenation]
=== References

* https://rubystyle.guide#string-interpolation

[#stylestringhashkeys]
== Style/StringHashKeys

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| No
| Always (Unsafe)
| 0.52
| 0.75
|===

Checks for the use of strings as keys in hashes. The use of
symbols is preferred instead.

[#safety-stylestringhashkeys]
=== Safety

This cop is unsafe because while symbols are preferred for hash keys,
there are instances when string keys are required.

[#examples-stylestringhashkeys]
=== Examples

[source,ruby]
----
# bad
{ 'one' => 1, 'two' => 2, 'three' => 3 }

# good
{ one: 1, two: 2, three: 3 }
----

[#references-stylestringhashkeys]
=== References

* https://rubystyle.guide#symbols-as-keys

[#stylestringliterals]
== Style/StringLiterals

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.36
|===

Checks if uses of quotes match the configured preference.

[#examples-stylestringliterals]
=== Examples

[#enforcedstyle_-single_quotes-_default_-stylestringliterals]
==== EnforcedStyle: single_quotes (default)

[source,ruby]
----
# bad
"No special symbols"
"No string interpolation"
"Just text"

# good
'No special symbols'
'No string interpolation'
'Just text'
"Wait! What's #{this}!"
----

[#enforcedstyle_-double_quotes-stylestringliterals]
==== EnforcedStyle: double_quotes

[source,ruby]
----
# bad
'Just some text'
'No special chars or interpolation'

# good
"Just some text"
"No special chars or interpolation"
"Every string in #{project} uses double_quotes"
----

[#configurable-attributes-stylestringliterals]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `single_quotes`
| `single_quotes`, `double_quotes`

| ConsistentQuotesInMultiline
| `false`
| Boolean
|===

[#references-stylestringliterals]
=== References

* https://rubystyle.guide#consistent-string-literals

[#stylestringliteralsininterpolation]
== Style/StringLiteralsInInterpolation

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.27
| -
|===

Checks that quotes inside string, symbol, and regexp interpolations
match the configured preference.

[#examples-stylestringliteralsininterpolation]
=== Examples

[#enforcedstyle_-single_quotes-_default_-stylestringliteralsininterpolation]
==== EnforcedStyle: single_quotes (default)

[source,ruby]
----
# bad
string = "Tests #{success ? "PASS" : "FAIL"}"
symbol = :"Tests #{success ? "PASS" : "FAIL"}"
heredoc = <<~TEXT
  Tests #{success ? "PASS" : "FAIL"}
TEXT
regexp = /Tests #{success ? "PASS" : "FAIL"}/

# good
string = "Tests #{success ? 'PASS' : 'FAIL'}"
symbol = :"Tests #{success ? 'PASS' : 'FAIL'}"
heredoc = <<~TEXT
  Tests #{success ? 'PASS' : 'FAIL'}
TEXT
regexp = /Tests #{success ? 'PASS' : 'FAIL'}/
----

[#enforcedstyle_-double_quotes-stylestringliteralsininterpolation]
==== EnforcedStyle: double_quotes

[source,ruby]
----
# bad
string = "Tests #{success ? 'PASS' : 'FAIL'}"
symbol = :"Tests #{success ? 'PASS' : 'FAIL'}"
heredoc = <<~TEXT
  Tests #{success ? 'PASS' : 'FAIL'}
TEXT
regexp = /Tests #{success ? 'PASS' : 'FAIL'}/

# good
string = "Tests #{success ? "PASS" : "FAIL"}"
symbol = :"Tests #{success ? "PASS" : "FAIL"}"
heredoc = <<~TEXT
  Tests #{success ? "PASS" : "FAIL"}
TEXT
regexp = /Tests #{success ? "PASS" : "FAIL"}/
----

[#configurable-attributes-stylestringliteralsininterpolation]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `single_quotes`
| `single_quotes`, `double_quotes`
|===

[#stylestringmethods]
== Style/StringMethods

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| Always
| 0.34
| 0.34
|===

Enforces the use of consistent method names
from the `String` class.

[#examples-stylestringmethods]
=== Examples

[source,ruby]
----
# bad
'name'.intern
'var'.unfavored_method

# good
'name'.to_sym
'var'.preferred_method
----

[#configurable-attributes-stylestringmethods]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| PreferredMethods
| `{"intern" => "to_sym"}`
| 
|===

[#stylestrip]
== Style/Strip

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.36
| -
|===

Identifies places where `lstrip.rstrip` can be replaced by
`strip`.

[#examples-stylestrip]
=== Examples

[source,ruby]
----
# bad
'abc'.lstrip.rstrip
'abc'.rstrip.lstrip

# good
'abc'.strip
----

[#stylestructinheritance]
== Style/StructInheritance

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always (Unsafe)
| 0.29
| 1.20
|===

Checks for inheritance from `Struct.new`. Inheriting from `Struct.new`
adds a superfluous level in inheritance tree.

[#safety-stylestructinheritance]
=== Safety

Autocorrection is unsafe because it will change the inheritance
tree (e.g. return value of `Module#ancestors`) of the constant.

[#examples-stylestructinheritance]
=== Examples

[source,ruby]
----
# bad
class Person < Struct.new(:first_name, :last_name)
  def age
    42
  end
end

Person.ancestors
# => [Person, #<Class:0x000000010b4e14a0>, Struct, (...)]

# good
Person = Struct.new(:first_name, :last_name) do
  def age
    42
  end
end

Person.ancestors
# => [Person, Struct, (...)]
----

[#references-stylestructinheritance]
=== References

* https://rubystyle.guide#no-extend-struct-new

[#stylesuperarguments]
== Style/SuperArguments

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.64
| -
|===

Checks for redundant argument forwarding when calling super with arguments identical to
the method definition.

Using zero arity `super` within a `define_method` block results in `RuntimeError`:

[source,ruby]
----
def m
  define_method(:foo) { super() } # => OK
end

def m
  define_method(:foo) { super }   # => RuntimeError
end
----

Furthermore, any arguments accompanied by a block may potentially be delegating to
`define_method`, therefore, `super` used within these blocks will be allowed.
This approach might result in false negatives, yet ensuring safe detection takes precedence.

NOTE: When forwarding the same arguments but replacing the block argument with a new inline
block, it is not necessary to explicitly list the non-block arguments. As such, an offense
will be registered in this case.

[#examples-stylesuperarguments]
=== Examples

[source,ruby]
----
# bad
def method(*args, **kwargs)
  super(*args, **kwargs)
end

# good - implicitly passing all arguments
def method(*args, **kwargs)
  super
end

# good - forwarding a subset of the arguments
def method(*args, **kwargs)
  super(*args)
end

# good - forwarding no arguments
def method(*args, **kwargs)
  super()
end

# bad - forwarding with overridden block
def method(*args, **kwargs, &block)
  super(*args, **kwargs) { do_something }
end

# good - implicitly passing all non-block arguments
def method(*args, **kwargs, &block)
  super { do_something }
end

# good - assigning to the block variable before calling super
def method(&block)
  # Assigning to the block variable would pass the old value to super,
  # under this circumstance the block must be referenced explicitly.
  block ||= proc { 'fallback behavior' }
  super(&block)
end
----

[#stylesuperwithargsparentheses]
== Style/SuperWithArgsParentheses

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.58
| -
|===

Enforces the presence of parentheses in `super` containing arguments.

`super` is a keyword and is provided as a distinct cop from those designed for method call.

[#examples-stylesuperwithargsparentheses]
=== Examples

[source,ruby]
----
# bad
super name, age

# good
super(name, age)
----

[#references-stylesuperwithargsparentheses]
=== References

* https://rubystyle.guide#super-with-args

[#styleswapvalues]
== Style/SwapValues

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always (Unsafe)
| 1.1
| -
|===

Enforces the use of shorthand-style swapping of 2 variables.

[#safety-styleswapvalues]
=== Safety

Autocorrection is unsafe, because the temporary variable used to
swap variables will be removed, but may be referred to elsewhere.

[#examples-styleswapvalues]
=== Examples

[source,ruby]
----
# bad
tmp = x
x = y
y = tmp

# good
x, y = y, x
----

[#references-styleswapvalues]
=== References

* https://rubystyle.guide#values-swapping

[#stylesymbolarray]
== Style/SymbolArray

NOTE: Requires Ruby version 2.0

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.49
|===

Checks for array literals made up of symbols that are not
using the %i() syntax.

Alternatively, it checks for symbol arrays using the %i() syntax on
projects which do not want to use that syntax, perhaps because they
support a version of Ruby lower than 2.0.

Configuration option: MinSize
If set, arrays with fewer elements than this value will not trigger the
cop. For example, a `MinSize` of `3` will not enforce a style on an
array of 2 or fewer elements.

[#examples-stylesymbolarray]
=== Examples

[#enforcedstyle_-percent-_default_-stylesymbolarray]
==== EnforcedStyle: percent (default)

[source,ruby]
----
# good
%i[foo bar baz]

# bad
[:foo, :bar, :baz]

# bad (contains spaces)
%i[foo\ bar baz\ quux]

# bad (contains [] with spaces)
%i[foo \[ \]]

# bad (contains () with spaces)
%i(foo \( \))
----

[#enforcedstyle_-brackets-stylesymbolarray]
==== EnforcedStyle: brackets

[source,ruby]
----
# good
[:foo, :bar, :baz]

# bad
%i[foo bar baz]
----

[#configurable-attributes-stylesymbolarray]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `percent`
| `percent`, `brackets`

| MinSize
| `2`
| Integer
|===

[#references-stylesymbolarray]
=== References

* https://rubystyle.guide#percent-i

[#stylesymbolliteral]
== Style/SymbolLiteral

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.30
| -
|===

Checks symbol literal syntax.

[#examples-stylesymbolliteral]
=== Examples

[source,ruby]
----
# bad
:"symbol"

# good
:symbol
----

[#stylesymbolproc]
== Style/SymbolProc

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.26
| 1.64
|===

Use symbols as procs when possible.

If you prefer a style that allows block for method with arguments,
please set `true` to `AllowMethodsWithArguments`.
`define_method?` methods are allowed by default.
These are customizable with `AllowedMethods` option.

[#safety-stylesymbolproc]
=== Safety

This cop is unsafe because there is a difference that a `Proc`
generated from `Symbol#to_proc` behaves as a lambda, while
a `Proc` generated from a block does not.
For example, a lambda will raise an `ArgumentError` if the
number of arguments is wrong, but a non-lambda `Proc` will not.

For example:

[source,ruby]
----
class Foo
  def bar
    :bar
  end
end

def call(options = {}, &block)
  block.call(Foo.new, options)
end

call { |x| x.bar }
#=> :bar
call(&:bar)
# ArgumentError: wrong number of arguments (given 1, expected 0)
----

It is also unsafe because `Symbol#to_proc` does not work with
`protected` methods which would otherwise be accessible.

For example:

[source,ruby]
----
class Box
  def initialize
    @secret = rand
  end

  def normal_matches?(*others)
    others.map { |other| other.secret }.any?(secret)
  end

  def symbol_to_proc_matches?(*others)
    others.map(&:secret).any?(secret)
  end

  protected

  attr_reader :secret
end

boxes = [Box.new, Box.new]
Box.new.normal_matches?(*boxes)
# => false
boxes.first.normal_matches?(*boxes)
# => true
Box.new.symbol_to_proc_matches?(*boxes)
# => NoMethodError: protected method `secret' called for #<Box...>
boxes.first.symbol_to_proc_matches?(*boxes)
# => NoMethodError: protected method `secret' called for #<Box...>
----

[#examples-stylesymbolproc]
=== Examples

[source,ruby]
----
# bad
something.map { |s| s.upcase }
something.map { _1.upcase }

# good
something.map(&:upcase)
----

[#allowmethodswitharguments_-false-_default_-stylesymbolproc]
==== AllowMethodsWithArguments: false (default)

[source,ruby]
----
# bad
something.do_something(foo) { |o| o.bar }

# good
something.do_something(foo, &:bar)
----

[#allowmethodswitharguments_-true-stylesymbolproc]
==== AllowMethodsWithArguments: true

[source,ruby]
----
# good
something.do_something(foo) { |o| o.bar }
----

[#allowcomments_-false-_default_-stylesymbolproc]
==== AllowComments: false (default)

[source,ruby]
----
# bad
something.do_something do |s| # some comment
  # some comment
  s.upcase # some comment
  # some comment
end
----

[#allowcomments_-true-stylesymbolproc]
==== AllowComments: true

[source,ruby]
----
# good  - if there are comment in either position
something.do_something do |s| # some comment
  # some comment
  s.upcase # some comment
  # some comment
end
----

[#allowedmethods_-_define_method_-_default_-stylesymbolproc]
==== AllowedMethods: [define_method] (default)

[source,ruby]
----
# good
define_method(:foo) { |foo| foo.bar }
----

[#allowedpatterns_-__-_default_-stylesymbolproc]
==== AllowedPatterns: [] (default)

[source,ruby]
----
# bad
something.map { |s| s.upcase }
----

[#allowedpatterns_-__map__-_default_-stylesymbolproc]
==== AllowedPatterns: ['map'] (default)

[source,ruby]
----
# good
something.map { |s| s.upcase }
----

[#allcops_activesupportextensionsenabled_-false-_default_-stylesymbolproc]
==== AllCops:ActiveSupportExtensionsEnabled: false (default)

[source,ruby]
----
# bad
->(x) { x.foo }
proc { |x| x.foo }
Proc.new { |x| x.foo }

# good
lambda(&:foo)
proc(&:foo)
Proc.new(&:foo)
----

[#allcops_activesupportextensionsenabled_-true-stylesymbolproc]
==== AllCops:ActiveSupportExtensionsEnabled: true

[source,ruby]
----
# good
->(x) { x.foo }
proc { |x| x.foo }
Proc.new { |x| x.foo }
----

[#configurable-attributes-stylesymbolproc]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowMethodsWithArguments
| `false`
| Boolean

| AllowedMethods
| `define_method`
| Array

| AllowedPatterns
| `[]`
| Array

| AllowComments
| `false`
| Boolean
|===

[#styleternaryparentheses]
== Style/TernaryParentheses

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.42
| 0.46
|===

Checks for the presence of parentheses around ternary
conditions. It is configurable to enforce inclusion or omission of
parentheses using `EnforcedStyle`. Omission is only enforced when
removing the parentheses won't cause a different behavior.

`AllowSafeAssignment` option for safe assignment.
By safe assignment we mean putting parentheses around
an assignment to indicate "I know I'm using an assignment
as a condition. It's not a mistake."

[#examples-styleternaryparentheses]
=== Examples

[#enforcedstyle_-require_no_parentheses-_default_-styleternaryparentheses]
==== EnforcedStyle: require_no_parentheses (default)

[source,ruby]
----
# bad
foo = (bar?) ? a : b
foo = (bar.baz?) ? a : b
foo = (bar && baz) ? a : b

# good
foo = bar? ? a : b
foo = bar.baz? ? a : b
foo = bar && baz ? a : b
----

[#enforcedstyle_-require_parentheses-styleternaryparentheses]
==== EnforcedStyle: require_parentheses

[source,ruby]
----
# bad
foo = bar? ? a : b
foo = bar.baz? ? a : b
foo = bar && baz ? a : b

# good
foo = (bar?) ? a : b
foo = (bar.baz?) ? a : b
foo = (bar && baz) ? a : b
----

[#enforcedstyle_-require_parentheses_when_complex-styleternaryparentheses]
==== EnforcedStyle: require_parentheses_when_complex

[source,ruby]
----
# bad
foo = (bar?) ? a : b
foo = (bar.baz?) ? a : b
foo = bar && baz ? a : b

# good
foo = bar? ? a : b
foo = bar.baz? ? a : b
foo = (bar && baz) ? a : b
----

[#allowsafeassignment_-true-_default_-styleternaryparentheses]
==== AllowSafeAssignment: true (default)

[source,ruby]
----
# good
foo = (bar = baz) ? a : b
----

[#allowsafeassignment_-false-styleternaryparentheses]
==== AllowSafeAssignment: false

[source,ruby]
----
# bad
foo = (bar = baz) ? a : b
----

[#configurable-attributes-styleternaryparentheses]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `require_no_parentheses`
| `require_parentheses`, `require_no_parentheses`, `require_parentheses_when_complex`

| AllowSafeAssignment
| `true`
| Boolean
|===

[#styletoplevelmethoddefinition]
== Style/TopLevelMethodDefinition

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 1.15
| -
|===

Newcomers to ruby applications may write top-level methods,
when ideally they should be organized in appropriate classes or modules.
This cop looks for definitions of top-level methods and warns about them.

However for ruby scripts it is perfectly fine to use top-level methods.
Hence this cop is disabled by default.

[#examples-styletoplevelmethoddefinition]
=== Examples

[source,ruby]
----
# bad
def some_method
end

# bad
def self.some_method
end

# bad
define_method(:foo) { puts 1 }

# good
module Foo
  def some_method
  end
end

# good
class Foo
  def self.some_method
  end
end

# good
Struct.new do
  def some_method
  end
end

# good
class Foo
  define_method(:foo) { puts 1 }
end
----

[#references-styletoplevelmethoddefinition]
=== References

* https://rubystyle.guide#top-level-methods

[#styletrailingbodyonclass]
== Style/TrailingBodyOnClass

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.53
| -
|===

Checks for trailing code after the class definition.

[#examples-styletrailingbodyonclass]
=== Examples

[source,ruby]
----
# bad
class Foo; def foo; end
end

# good
class Foo
  def foo; end
end
----

[#styletrailingbodyonmethoddefinition]
== Style/TrailingBodyOnMethodDefinition

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.52
| -
|===

Checks for trailing code after the method definition.

NOTE: It always accepts endless method definitions that are basically on the same line.

[#examples-styletrailingbodyonmethoddefinition]
=== Examples

[source,ruby]
----
# bad
def some_method; do_stuff
end

def f(x); b = foo
  b[c: x]
end

# good
def some_method
  do_stuff
end

def f(x)
  b = foo
  b[c: x]
end

def endless_method = do_stuff
----

[#styletrailingbodyonmodule]
== Style/TrailingBodyOnModule

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.53
| -
|===

Checks for trailing code after the module definition.

[#examples-styletrailingbodyonmodule]
=== Examples

[source,ruby]
----
# bad
module Foo extend self
end

# good
module Foo
  extend self
end
----

[#styletrailingcommainarguments]
== Style/TrailingCommaInArguments

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.36
| -
|===

Checks for trailing comma in argument lists.
The supported styles are:

* `consistent_comma`: Requires a comma after the last argument,
for all parenthesized multi-line method calls with arguments.
* `comma`: Requires a comma after the last argument, but only for
parenthesized method calls where each argument is on its own line.
* `no_comma`: Requires that there is no comma after the last
argument.

Regardless of style, trailing commas are not allowed in
single-line method calls.

[#examples-styletrailingcommainarguments]
=== Examples

[#enforcedstyleformultiline_-consistent_comma-styletrailingcommainarguments]
==== EnforcedStyleForMultiline: consistent_comma

[source,ruby]
----
# bad
method(1, 2,)

# good
method(1, 2)

# good
method(
  1, 2,
  3,
)

# good
method(
  1, 2, 3,
)

# good
method(
  1,
  2,
)
----

[#enforcedstyleformultiline_-comma-styletrailingcommainarguments]
==== EnforcedStyleForMultiline: comma

[source,ruby]
----
# bad
method(1, 2,)

# good
method(1, 2)

# bad
method(
  1, 2,
  3,
)

# good
method(
  1, 2,
  3
)

# bad
method(
  1, 2, 3,
)

# good
method(
  1, 2, 3
)

# good
method(
  1,
  2,
)
----

[#enforcedstyleformultiline_-no_comma-_default_-styletrailingcommainarguments]
==== EnforcedStyleForMultiline: no_comma (default)

[source,ruby]
----
# bad
method(1, 2,)

# bad
object[1, 2,]

# good
method(1, 2)

# good
object[1, 2]

# good
method(
  1,
  2
)
----

[#configurable-attributes-styletrailingcommainarguments]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyleForMultiline
| `no_comma`
| `comma`, `consistent_comma`, `no_comma`
|===

[#references-styletrailingcommainarguments]
=== References

* https://rubystyle.guide#no-trailing-params-comma

[#styletrailingcommainarrayliteral]
== Style/TrailingCommaInArrayLiteral

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.53
| -
|===

Checks for trailing comma in array literals.
The configuration options are:

* `consistent_comma`: Requires a comma after the last item of all non-empty, multiline array
literals.
* `comma`: Requires a comma after the last item in an array, but only when each item is on
its own line.
* `diff_comma`: Requires a comma after the last item in an array, but only when that item is
followed by an immediate newline, even if there is an inline comment on the same line.
* `no_comma`: Does not require a comma after the last item in an array

[#examples-styletrailingcommainarrayliteral]
=== Examples

[#enforcedstyleformultiline_-consistent_comma-styletrailingcommainarrayliteral]
==== EnforcedStyleForMultiline: consistent_comma

[source,ruby]
----
# bad
a = [1, 2,]

# good
a = [1, 2]

# good
a = [
  1, 2,
  3,
]

# good
a = [
  1, 2, 3,
]

# good
a = [
  1,
  2,
]

# bad
a = [1, 2,
     3, 4]

# good
a = [1, 2,
     3, 4,]
----

[#enforcedstyleformultiline_-comma-styletrailingcommainarrayliteral]
==== EnforcedStyleForMultiline: comma

[source,ruby]
----
# bad
a = [1, 2,]

# good
a = [1, 2]

# bad
a = [
  1, 2,
  3,
]

# good
a = [
  1, 2,
  3
]

# bad
a = [
  1, 2, 3,
]

# good
a = [
  1, 2, 3
]

# good
a = [
  1,
  2,
]
----

[#enforcedstyleformultiline_-diff_comma-styletrailingcommainarrayliteral]
==== EnforcedStyleForMultiline: diff_comma

[source,ruby]
----
# bad
a = [1, 2,]

# good
a = [1, 2]

# good
a = [
  1, 2,
  3,
]

# good
a = [
  1, 2, 3,
]

# good
a = [
  1,
  2,
]

# bad
a = [1, 2,
     3, 4,]

# good
a = [1, 2,
     3, 4]
----

[#enforcedstyleformultiline_-no_comma-_default_-styletrailingcommainarrayliteral]
==== EnforcedStyleForMultiline: no_comma (default)

[source,ruby]
----
# bad
a = [1, 2,]

# good
a = [
  1,
  2
]
----

[#configurable-attributes-styletrailingcommainarrayliteral]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyleForMultiline
| `no_comma`
| `comma`, `consistent_comma`, `diff_comma`, `no_comma`
|===

[#references-styletrailingcommainarrayliteral]
=== References

* https://rubystyle.guide#no-trailing-array-commas

[#styletrailingcommainblockargs]
== Style/TrailingCommaInBlockArgs

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| No
| Always (Unsafe)
| 0.81
| -
|===

Checks whether trailing commas in block arguments are
required. Blocks with only one argument and a trailing comma require
that comma to be present. Blocks with more than one argument never
require a trailing comma.

[#safety-styletrailingcommainblockargs]
=== Safety

This cop is unsafe because a trailing comma can indicate there are
more parameters that are not used.

For example:
[source,ruby]
----
# with a trailing comma
{foo: 1, bar: 2, baz: 3}.map {|key,| key }
#=> [:foo, :bar, :baz]

# without a trailing comma
{foo: 1, bar: 2, baz: 3}.map {|key| key }
#=> [[:foo, 1], [:bar, 2], [:baz, 3]]
----

This can be fixed by replacing the trailing comma with a placeholder
argument (such as `|key, _value|`).

[#examples-styletrailingcommainblockargs]
=== Examples

[source,ruby]
----
# bad
add { |foo, bar,| foo + bar }

# good
add { |foo, bar| foo + bar }

# good
add { |foo,| foo }

# good
add { foo }

# bad
add do |foo, bar,|
  foo + bar
end

# good
add do |foo, bar|
  foo + bar
end

# good
add do |foo,|
  foo
end

# good
add do
  foo + bar
end
----

[#styletrailingcommainhashliteral]
== Style/TrailingCommaInHashLiteral

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.53
| -
|===

Checks for trailing comma in hash literals.
The configuration options are:

* `consistent_comma`: Requires a comma after the last item of all non-empty, multiline hash
literals.
* `comma`: Requires a comma after the last item in a hash, but only when each item is on its
own line.
* `diff_comma`: Requires a comma after the last item in a hash, but only when that item is
followed by an immediate newline, even if there is an inline comment on the same line.
* `no_comma`: Does not require a comma after the last item in a hash

[#examples-styletrailingcommainhashliteral]
=== Examples

[#enforcedstyleformultiline_-consistent_comma-styletrailingcommainhashliteral]
==== EnforcedStyleForMultiline: consistent_comma

[source,ruby]
----
# bad
a = { foo: 1, bar: 2, }

# good
a = { foo: 1, bar: 2 }

# good
a = {
  foo: 1, bar: 2,
  qux: 3,
}

# good
a = {
  foo: 1, bar: 2, qux: 3,
}

# good
a = {
  foo: 1,
  bar: 2,
}

# bad
a = { foo: 1, bar: 2,
      baz: 3, qux: 4 }

# good
a = { foo: 1, bar: 2,
      baz: 3, qux: 4, }
----

[#enforcedstyleformultiline_-comma-styletrailingcommainhashliteral]
==== EnforcedStyleForMultiline: comma

[source,ruby]
----
# bad
a = { foo: 1, bar: 2, }

# good
a = { foo: 1, bar: 2 }

# bad
a = {
  foo: 1, bar: 2,
  qux: 3,
}

# good
a = {
  foo: 1, bar: 2,
  qux: 3
}

# bad
a = {
  foo: 1, bar: 2, qux: 3,
}

# good
a = {
  foo: 1, bar: 2, qux: 3
}

# good
a = {
  foo: 1,
  bar: 2,
}
----

[#enforcedstyleformultiline_-diff_comma-styletrailingcommainhashliteral]
==== EnforcedStyleForMultiline: diff_comma

[source,ruby]
----
# bad
a = { foo: 1, bar: 2, }

# good
a = { foo: 1, bar: 2 }

# good
a = {
  foo: 1, bar: 2,
  qux: 3,
}

# good
a = {
  foo: 1, bar: 2, qux: 3,
}

# good
a = {
  foo: 1,
  bar: 2,
}

# bad
a = { foo: 1, bar: 2,
      baz: 3, qux: 4, }

# good
a = { foo: 1, bar: 2,
      baz: 3, qux: 4 }
----

[#enforcedstyleformultiline_-no_comma-_default_-styletrailingcommainhashliteral]
==== EnforcedStyleForMultiline: no_comma (default)

[source,ruby]
----
# bad
a = { foo: 1, bar: 2, }

# good
a = {
  foo: 1,
  bar: 2
}
----

[#configurable-attributes-styletrailingcommainhashliteral]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyleForMultiline
| `no_comma`
| `comma`, `consistent_comma`, `diff_comma`, `no_comma`
|===

[#styletrailingmethodendstatement]
== Style/TrailingMethodEndStatement

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.52
| -
|===

Checks for trailing code after the method definition.

[#examples-styletrailingmethodendstatement]
=== Examples

[source,ruby]
----
# bad
def some_method
do_stuff; end

def do_this(x)
  baz.map { |b| b.this(x) } end

def foo
  block do
    bar
  end end

# good
def some_method
  do_stuff
end

def do_this(x)
  baz.map { |b| b.this(x) }
end

def foo
  block do
    bar
  end
end
----

[#styletrailingunderscorevariable]
== Style/TrailingUnderscoreVariable

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.31
| 0.35
|===

Checks for extra underscores in variable assignment.

[#examples-styletrailingunderscorevariable]
=== Examples

[source,ruby]
----
# bad
a, b, _ = foo()
a, b, _, = foo()
a, _, _ = foo()
a, _, _, = foo()

# good
a, b, = foo()
a, = foo()
*a, b, _ = foo()
# => We need to know to not include 2 variables in a
a, *b, _ = foo()
# => The correction `a, *b, = foo()` is a syntax error
----

[#allownamedunderscorevariables_-true-_default_-styletrailingunderscorevariable]
==== AllowNamedUnderscoreVariables: true (default)

[source,ruby]
----
# good
a, b, _something = foo()
----

[#allownamedunderscorevariables_-false-styletrailingunderscorevariable]
==== AllowNamedUnderscoreVariables: false

[source,ruby]
----
# bad
a, b, _something = foo()
----

[#configurable-attributes-styletrailingunderscorevariable]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowNamedUnderscoreVariables
| `true`
| Boolean
|===

[#styletrivialaccessors]
== Style/TrivialAccessors

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 1.15
|===

Looks for trivial reader/writer methods, that could
have been created with the attr_* family of functions automatically.
`to_ary`, `to_a`, `to_c`, `to_enum`, `to_h`, `to_hash`, `to_i`, `to_int`, `to_io`,
`to_open`, `to_path`, `to_proc`, `to_r`, `to_regexp`, `to_str`, `to_s`, and `to_sym` methods
are allowed by default. These are customizable with `AllowedMethods` option.

[#examples-styletrivialaccessors]
=== Examples

[source,ruby]
----
# bad
def foo
  @foo
end

def bar=(val)
  @bar = val
end

def self.baz
  @baz
end

# good
attr_reader :foo
attr_writer :bar

class << self
  attr_reader :baz
end
----

[#exactnamematch_-true-_default_-styletrivialaccessors]
==== ExactNameMatch: true (default)

[source,ruby]
----
# good
def name
  @other_name
end
----

[#exactnamematch_-false-styletrivialaccessors]
==== ExactNameMatch: false

[source,ruby]
----
# bad
def name
  @other_name
end
----

[#allowpredicates_-true-_default_-styletrivialaccessors]
==== AllowPredicates: true (default)

[source,ruby]
----
# good
def foo?
  @foo
end
----

[#allowpredicates_-false-styletrivialaccessors]
==== AllowPredicates: false

[source,ruby]
----
# bad
def foo?
  @foo
end

# good
attr_reader :foo
----

[#allowdslwriters_-true-_default_-styletrivialaccessors]
==== AllowDSLWriters: true (default)

[source,ruby]
----
# good
def on_exception(action)
  @on_exception=action
end
----

[#allowdslwriters_-false-styletrivialaccessors]
==== AllowDSLWriters: false

[source,ruby]
----
# bad
def on_exception(action)
  @on_exception=action
end

# good
attr_writer :on_exception
----

[#ignoreclassmethods_-false-_default_-styletrivialaccessors]
==== IgnoreClassMethods: false (default)

[source,ruby]
----
# bad
def self.foo
  @foo
end

# good
class << self
  attr_reader :foo
end
----

[#ignoreclassmethods_-true-styletrivialaccessors]
==== IgnoreClassMethods: true

[source,ruby]
----
# good
def self.foo
  @foo
end
----

[#allowedmethods_-__allowed_method__-styletrivialaccessors]
==== AllowedMethods: ['allowed_method']

[source,ruby]
----
# good
def allowed_method
  @foo
end
----

[#configurable-attributes-styletrivialaccessors]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| ExactNameMatch
| `true`
| Boolean

| AllowPredicates
| `true`
| Boolean

| AllowDSLWriters
| `true`
| Boolean

| IgnoreClassMethods
| `false`
| Boolean

| AllowedMethods
| `to_ary`, `to_a`, `to_c`, `to_enum`, `to_h`, `to_hash`, `to_i`, `to_int`, `to_io`, `to_open`, `to_path`, `to_proc`, `to_r`, `to_regexp`, `to_str`, `to_s`, `to_sym`
| Array
|===

[#references-styletrivialaccessors]
=== References

* https://rubystyle.guide#attr_family

[#styleunlesselse]
== Style/UnlessElse

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| -
|===

Looks for `unless` expressions with `else` clauses.

[#examples-styleunlesselse]
=== Examples

[source,ruby]
----
# bad
unless foo_bar.nil?
  # do something...
else
  # do a different thing...
end

# good
if foo_bar.present?
  # do something...
else
  # do a different thing...
end
----

[#references-styleunlesselse]
=== References

* https://rubystyle.guide#no-else-with-unless

[#styleunlesslogicaloperators]
== Style/UnlessLogicalOperators

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 1.11
| -
|===

Checks for the use of logical operators in an `unless` condition.
It discourages such code, as the condition becomes more difficult
to read and understand.

This cop supports two styles:

- `forbid_mixed_logical_operators` (default)
- `forbid_logical_operators`

`forbid_mixed_logical_operators` style forbids the use of more than one type
of logical operators. This makes the `unless` condition easier to read
because either all conditions need to be met or any condition need to be met
in order for the expression to be truthy or falsey.

`forbid_logical_operators` style forbids any use of logical operator.
This makes it even more easy to read the `unless` condition as
there is only one condition in the expression.

[#examples-styleunlesslogicaloperators]
=== Examples

[#enforcedstyle_-forbid_mixed_logical_operators-_default_-styleunlesslogicaloperators]
==== EnforcedStyle: forbid_mixed_logical_operators (default)

[source,ruby]
----
# bad
return unless a || b && c
return unless a && b || c
return unless a && b and c
return unless a || b or c
return unless a && b or c
return unless a || b and c

# good
return unless a && b && c
return unless a || b || c
return unless a and b and c
return unless a or b or c
return unless a?
----

[#enforcedstyle_-forbid_logical_operators-styleunlesslogicaloperators]
==== EnforcedStyle: forbid_logical_operators

[source,ruby]
----
# bad
return unless a || b
return unless a && b
return unless a or b
return unless a and b

# good
return unless a
return unless a?
----

[#configurable-attributes-styleunlesslogicaloperators]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `forbid_mixed_logical_operators`
| `forbid_mixed_logical_operators`, `forbid_logical_operators`
|===

[#styleunpackfirst]
== Style/UnpackFirst

NOTE: Requires Ruby version 2.4

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.54
| -
|===

Checks for accessing the first element of `String#unpack`
which can be replaced with the shorter method `unpack1`.

[#examples-styleunpackfirst]
=== Examples

[source,ruby]
----
# bad
'foo'.unpack('h*').first
'foo'.unpack('h*')[0]
'foo'.unpack('h*').slice(0)
'foo'.unpack('h*').at(0)

# good
'foo'.unpack1('h*')
----

[#stylevariableinterpolation]
== Style/VariableInterpolation

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.20
|===

Checks for variable interpolation (like "#@ivar").

[#examples-stylevariableinterpolation]
=== Examples

[source,ruby]
----
# bad
"His name is #$name"
/check #$pattern/
"Let's go to the #@store"

# good
"His name is #{$name}"
/check #{$pattern}/
"Let's go to the #{@store}"
----

[#references-stylevariableinterpolation]
=== References

* https://rubystyle.guide#curlies-interpolate

[#stylewhenthen]
== Style/WhenThen

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| -
|===

Checks for `when;` uses in `case` expressions.

[#examples-stylewhenthen]
=== Examples

[source,ruby]
----
# bad
case foo
when 1; 'baz'
when 2; 'bar'
end

# good
case foo
when 1 then 'baz'
when 2 then 'bar'
end
----

[#references-stylewhenthen]
=== References

* https://rubystyle.guide#no-when-semicolons

[#stylewhileuntildo]
== Style/WhileUntilDo

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| -
|===

Checks for uses of `do` in multi-line `while/until` statements.

[#examples-stylewhileuntildo]
=== Examples

[source,ruby]
----
# bad
while x.any? do
  do_something(x.pop)
end

# good
while x.any?
  do_something(x.pop)
end

# bad
until x.empty? do
  do_something(x.pop)
end

# good
until x.empty?
  do_something(x.pop)
end
----

[#references-stylewhileuntildo]
=== References

* https://rubystyle.guide#no-multiline-while-do

[#stylewhileuntilmodifier]
== Style/WhileUntilModifier

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 0.30
|===

Checks for while and until statements that would fit on one line
if written as a modifier while/until. The maximum line length is
configured in the `Layout/LineLength` cop.

[#examples-stylewhileuntilmodifier]
=== Examples

[source,ruby]
----
# bad
while x < 10
  x += 1
end

# good
x += 1 while x < 10

# bad
until x > 10
  x += 1
end

# good
x += 1 until x > 10

# bad
x += 100 while x < 500 # a long comment that makes code too long if it were a single line

# good
while x < 500 # a long comment that makes code too long if it were a single line
  x += 100
end
----

[#references-stylewhileuntilmodifier]
=== References

* https://rubystyle.guide#while-as-a-modifier

[#stylewordarray]
== Style/WordArray

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| 0.9
| 1.19
|===

Checks for array literals made up of word-like
strings, that are not using the %w() syntax.

Alternatively, it can check for uses of the %w() syntax, in projects
which do not want to include that syntax.

NOTE: When using the `percent` style, %w() arrays containing a space
will be registered as offenses.

Configuration option: MinSize
If set, arrays with fewer elements than this value will not trigger the
cop. For example, a `MinSize` of `3` will not enforce a style on an
array of 2 or fewer elements.

[#examples-stylewordarray]
=== Examples

[#enforcedstyle_-percent-_default_-stylewordarray]
==== EnforcedStyle: percent (default)

[source,ruby]
----
# good
%w[foo bar baz]

# bad
['foo', 'bar', 'baz']

# bad (contains spaces)
%w[foo\ bar baz\ quux]

# bad
[
  ['one', 'One'],
  ['two', 'Two']
]

# good
[
  %w[one One],
  %w[two Two]
]

# good (2d array containing spaces)
[
  ['one', 'One'],
  ['two', 'Two'],
  ['forty two', 'Forty Two']
]
----

[#enforcedstyle_-brackets-stylewordarray]
==== EnforcedStyle: brackets

[source,ruby]
----
# good
['foo', 'bar', 'baz']

# bad
%w[foo bar baz]

# good (contains spaces)
['foo bar', 'baz quux']

# good
[
  ['one', 'One'],
  ['two', 'Two']
]

# bad
[
  %w[one One],
  %w[two Two]
]
----

[#configurable-attributes-stylewordarray]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `percent`
| `percent`, `brackets`

| MinSize
| `2`
| Integer

| WordRegex
| `(?-mix:\A(?:\p{Word}\|\p{Word}-\p{Word}\|\n\|\t)+\z)`
| 
|===

[#references-stylewordarray]
=== References

* https://rubystyle.guide#percent-w

[#styleyamlfileread]
== Style/YAMLFileRead

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Pending
| Yes
| Always
| 1.53
| -
|===

Checks for the use of `YAML.load`, `YAML.safe_load`, and `YAML.parse` with
`File.read` argument.

NOTE: `YAML.safe_load_file` was introduced in Ruby 3.0.

[#examples-styleyamlfileread]
=== Examples

[source,ruby]
----
# bad
YAML.load(File.read(path))
YAML.parse(File.read(path))

# good
YAML.load_file(path)
YAML.parse_file(path)

# bad
YAML.safe_load(File.read(path)) # Ruby 3.0 and newer

# good
YAML.safe_load_file(path)       # Ruby 3.0 and newer
----

[#styleyodacondition]
== Style/YodaCondition

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.49
| 0.75
|===

Enforces or forbids Yoda conditions,
i.e. comparison operations where the order of expression is reversed.
eg. `5 == x`

[#safety-styleyodacondition]
=== Safety

This cop is unsafe because comparison operators can be defined
differently on different classes, and are not guaranteed to
have the same result if reversed.

For example:

[source,ruby]
----
class MyKlass
  def ==(other)
    true
  end
end

obj = MyKlass.new
obj == 'string'   #=> true
'string' == obj   #=> false
----

[#examples-styleyodacondition]
=== Examples

[#enforcedstyle_-forbid_for_all_comparison_operators-_default_-styleyodacondition]
==== EnforcedStyle: forbid_for_all_comparison_operators (default)

[source,ruby]
----
# bad
99 == foo
"bar" != foo
42 >= foo
10 < bar
99 == CONST

# good
foo == 99
foo == "bar"
foo <= 42
bar > 10
CONST == 99
"#{interpolation}" == foo
/#{interpolation}/ == foo
----

[#enforcedstyle_-forbid_for_equality_operators_only-styleyodacondition]
==== EnforcedStyle: forbid_for_equality_operators_only

[source,ruby]
----
# bad
99 == foo
"bar" != foo

# good
99 >= foo
3 < a && a < 5
----

[#enforcedstyle_-require_for_all_comparison_operators-styleyodacondition]
==== EnforcedStyle: require_for_all_comparison_operators

[source,ruby]
----
# bad
foo == 99
foo == "bar"
foo <= 42
bar > 10

# good
99 == foo
"bar" != foo
42 >= foo
10 < bar
----

[#enforcedstyle_-require_for_equality_operators_only-styleyodacondition]
==== EnforcedStyle: require_for_equality_operators_only

[source,ruby]
----
# bad
99 >= foo
3 < a && a < 5

# good
99 == foo
"bar" != foo
----

[#configurable-attributes-styleyodacondition]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| EnforcedStyle
| `forbid_for_all_comparison_operators`
| `forbid_for_all_comparison_operators`, `forbid_for_equality_operators_only`, `require_for_all_comparison_operators`, `require_for_equality_operators_only`
|===

[#references-styleyodacondition]
=== References

* https://en.wikipedia.org/wiki/Yoda_conditions

[#styleyodaexpression]
== Style/YodaExpression

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| No
| Always (Unsafe)
| 1.42
| 1.43
|===

Forbids Yoda expressions, i.e. binary operations (using `*`, `+`, `&`, `|`,
and `^` operators) where the order of expression is reversed, eg. `1 + x`.
This cop complements `Style/YodaCondition` cop, which has a similar purpose.

This cop is disabled by default to respect user intentions such as:

[source,ruby]
----
config.server_port = 9000 + ENV["TEST_ENV_NUMBER"].to_i
----

[#safety-styleyodaexpression]
=== Safety

This cop is unsafe because binary operators can be defined
differently on different classes, and are not guaranteed to
have the same result if reversed.

[#examples-styleyodaexpression]
=== Examples

[#supportedoperators_-_____-____-____-____-____-_default_-styleyodaexpression]
==== SupportedOperators: ['*', '+', '&', '|', '^'] (default)

[source,ruby]
----
# bad
10 * y
1 + x
1 & z
1 | x
1 ^ x
1 + CONST

# good
y * 10
x + 1
z & 1
x | 1
x ^ 1
CONST + 1
60 * 24
----

[#stylezerolengthpredicate]
== Style/ZeroLengthPredicate

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| No
| Always (Unsafe)
| 0.37
| 0.39
|===

Checks for numeric comparisons that can be replaced
by a predicate method, such as `receiver.length == 0`,
`receiver.length > 0`, and `receiver.length != 0`,
`receiver.length < 1` and `receiver.size == 0` that can be
replaced by `receiver.empty?` and `!receiver.empty?`.

NOTE: `File`, `Tempfile`, and `StringIO` do not have `empty?`
so allow `size == 0` and `size.zero?`.

[#safety-stylezerolengthpredicate]
=== Safety

This cop is unsafe because it cannot be guaranteed that the receiver
has an `empty?` method that is defined in terms of `length`. If there
is a non-standard class that redefines `length` or `empty?`, the cop
may register a false positive.

[#examples-stylezerolengthpredicate]
=== Examples

[source,ruby]
----
# bad
[1, 2, 3].length == 0
0 == "foobar".length
array.length < 1
{a: 1, b: 2}.length != 0
string.length > 0
hash.size > 0

# good
[1, 2, 3].empty?
"foobar".empty?
array.empty?
!{a: 1, b: 2}.empty?
!string.empty?
!hash.empty?
----
