= Metrics

== Metrics/AbcSize

|===
| Enabled by default | Safe | Supports autocorrection | VersionAdded | VersionChanged

| Enabled
| Yes
| No
| 0.27
| 0.81
|===

This cop checks that the ABC size of methods is not higher than the
configured maximum. The ABC size is based on assignments, branches
(method calls), and conditions. See http://c2.com/cgi/wiki?AbcMetric
and https://en.wikipedia.org/wiki/ABC_Software_Metric.

=== Configurable attributes

|===
| Name | Default value | Configurable values

| IgnoredMethods
| `[]`
| Array

| Max
| `17`
| Integer
|===

=== References

* http://c2.com/cgi/wiki?AbcMetric
* https://en.wikipedia.org/wiki/ABC_Software_Metric

== Metrics/BlockLength

|===
| Enabled by default | Safe | Supports autocorrection | VersionAdded | VersionChanged

| Enabled
| Yes
| No
| 0.44
| 0.87
|===

This cop checks if the length of a block exceeds some maximum value.
Comment lines can optionally be ignored.
The maximum allowed length is configurable.
The cop can be configured to ignore blocks passed to certain methods.

You can set literals you want to fold with `CountAsOne`.
Available are: 'array', 'hash', and 'heredoc'. Each literal
will be counted as one line regardless of its actual size.

=== Examples

==== CountAsOne: ['array', 'heredoc']

[source,ruby]
----
something do
  array = [         # +1
    1,
    2
  ]

  hash = {          # +3
    key: 'value'
  }

  msg = <<~HEREDOC  # +1
    Heredoc
    content.
  HEREDOC
end                 # 5 points
----

=== Configurable attributes

|===
| Name | Default value | Configurable values

| CountComments
| `false`
| Boolean

| Max
| `25`
| Integer

| CountAsOne
| `[]`
| Array

| ExcludedMethods
| `refine`
| Array

| Exclude
| `**/*.gemspec`
| Array
|===

== Metrics/BlockNesting

|===
| Enabled by default | Safe | Supports autocorrection | VersionAdded | VersionChanged

| Enabled
| Yes
| No
| 0.25
| 0.47
|===

This cop checks for excessive nesting of conditional and looping
constructs.

You can configure if blocks are considered using the `CountBlocks`
option. When set to `false` (the default) blocks are not counted
towards the nesting level. Set to `true` to count blocks as well.

The maximum level of nesting allowed is configurable.

=== Configurable attributes

|===
| Name | Default value | Configurable values

| CountBlocks
| `false`
| Boolean

| Max
| `3`
| Integer
|===

=== References

* https://rubystyle.guide#three-is-the-number-thou-shalt-count

== Metrics/ClassLength

|===
| Enabled by default | Safe | Supports autocorrection | VersionAdded | VersionChanged

| Enabled
| Yes
| No
| 0.25
| 0.87
|===

This cop checks if the length a class exceeds some maximum value.
Comment lines can optionally be ignored.
The maximum allowed length is configurable.

You can set literals you want to fold with `CountAsOne`.
Available are: 'array', 'hash', and 'heredoc'. Each literal
will be counted as one line regardless of its actual size.

=== Examples

==== CountAsOne: ['array', 'heredoc']

[source,ruby]
----
class Foo
  ARRAY = [         # +1
    1,
    2
  ]

  HASH = {          # +3
    key: 'value'
  }

  MSG = <<~HEREDOC  # +1
    Heredoc
    content.
  HEREDOC
end                 # 5 points
----

=== Configurable attributes

|===
| Name | Default value | Configurable values

| CountComments
| `false`
| Boolean

| Max
| `100`
| Integer

| CountAsOne
| `[]`
| Array
|===

== Metrics/CyclomaticComplexity

|===
| Enabled by default | Safe | Supports autocorrection | VersionAdded | VersionChanged

| Enabled
| Yes
| No
| 0.25
| 0.81
|===

This cop checks that the cyclomatic complexity of methods is not higher
than the configured maximum. The cyclomatic complexity is the number of
linearly independent paths through a method. The algorithm counts
decision points and adds one.

An if statement (or unless or ?:) increases the complexity by one. An
else branch does not, since it doesn't add a decision point. The &&
operator (or keyword and) can be converted to a nested if statement,
and ||/or is shorthand for a sequence of ifs, so they also add one.
Loops can be said to have an exit condition, so they add one.
Blocks that are calls to builtin iteration methods
(e.g. `ary.map{...}) also add one, others are ignored.

  def each_child_node(*types)               # count begins: 1
    unless block_given?                     # unless: +1
      return to_enum(__method__, *types)

    children.each do |child|                # each{}: +1
      next unless child.is_a?(Node)         # unless: +1

      yield child if types.empty? ||        # if: +1, ||: +1
                     types.include?(child.type)
    end

    self
  end                                       # total: 6

=== Configurable attributes

|===
| Name | Default value | Configurable values

| IgnoredMethods
| `[]`
| Array

| Max
| `7`
| Integer
|===

== Metrics/MethodLength

|===
| Enabled by default | Safe | Supports autocorrection | VersionAdded | VersionChanged

| Enabled
| Yes
| No
| 0.25
| 0.87
|===

This cop checks if the length of a method exceeds some maximum value.
Comment lines can optionally be ignored.
The maximum allowed length is configurable.

You can set literals you want to fold with `CountAsOne`.
Available are: 'array', 'hash', and 'heredoc'. Each literal
will be counted as one line regardless of its actual size.

=== Examples

==== CountAsOne: ['array', 'heredoc']

[source,ruby]
----
def m
  array = [       # +1
    1,
    2
  ]

  hash = {        # +3
    key: 'value'
  }

  <<~HEREDOC      # +1
    Heredoc
    content.
  HEREDOC
end               # 5 points
----

=== Configurable attributes

|===
| Name | Default value | Configurable values

| CountComments
| `false`
| Boolean

| Max
| `10`
| Integer

| CountAsOne
| `[]`
| Array

| ExcludedMethods
| `[]`
| Array
|===

=== References

* https://rubystyle.guide#short-methods

== Metrics/ModuleLength

|===
| Enabled by default | Safe | Supports autocorrection | VersionAdded | VersionChanged

| Enabled
| Yes
| No
| 0.31
| 0.87
|===

This cop checks if the length a module exceeds some maximum value.
Comment lines can optionally be ignored.
The maximum allowed length is configurable.

You can set literals you want to fold with `CountAsOne`.
Available are: 'array', 'hash', and 'heredoc'. Each literal
will be counted as one line regardless of its actual size.

=== Examples

==== CountAsOne: ['array', 'heredoc']

[source,ruby]
----
module M
  ARRAY = [         # +1
    1,
    2
  ]

  HASH = {          # +3
    key: 'value'
  }

  MSG = <<~HEREDOC  # +1
    Heredoc
    content.
  HEREDOC
end                 # 5 points
----

=== Configurable attributes

|===
| Name | Default value | Configurable values

| CountComments
| `false`
| Boolean

| Max
| `100`
| Integer

| CountAsOne
| `[]`
| Array
|===

== Metrics/ParameterLists

|===
| Enabled by default | Safe | Supports autocorrection | VersionAdded | VersionChanged

| Enabled
| Yes
| No
| 0.25
| -
|===

This cop checks for methods with too many parameters.
The maximum number of parameters is configurable.
Keyword arguments can optionally be excluded from the total count.

=== Configurable attributes

|===
| Name | Default value | Configurable values

| Max
| `5`
| Integer

| CountKeywordArgs
| `true`
| Boolean
|===

=== References

* https://rubystyle.guide#too-many-params

== Metrics/PerceivedComplexity

|===
| Enabled by default | Safe | Supports autocorrection | VersionAdded | VersionChanged

| Enabled
| Yes
| No
| 0.25
| 0.81
|===

This cop tries to produce a complexity score that's a measure of the
complexity the reader experiences when looking at a method. For that
reason it considers `when` nodes as something that doesn't add as much
complexity as an `if` or a `&&`. Except if it's one of those special
`case`/`when` constructs where there's no expression after `case`. Then
the cop treats it as an `if`/`elsif`/`elsif`... and lets all the `when`
nodes count. In contrast to the CyclomaticComplexity cop, this cop
considers `else` nodes as adding complexity.

=== Examples

[source,ruby]
----
def my_method                   # 1
  if cond                       # 1
    case var                    # 2 (0.8 + 4 * 0.2, rounded)
    when 1 then func_one
    when 2 then func_two
    when 3 then func_three
    when 4..10 then func_other
    end
  else                          # 1
    do_something until a && b   # 2
  end                           # ===
end                             # 7 complexity points
----

=== Configurable attributes

|===
| Name | Default value | Configurable values

| IgnoredMethods
| `[]`
| Array

| Max
| `8`
| Integer
|===
